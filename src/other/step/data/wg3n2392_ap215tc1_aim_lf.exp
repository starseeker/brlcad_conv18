(*
  AIM EXPRESS long form for ISO 10303-215 TC1
  2007-07-06
  Pete Lazo
  ISO TC184/SC4 WG3 N2392
*)


(* ************************************************************************** *)


SCHEMA Ship_arrangement_schema;



(* ***********************************
Constants in the schema Ship_arrangement_schema
*********************************** *)


   CONSTANT
      dummy_gri : geometric_representation_item := representation_item('') || geometric_representation_item();
      dummy_tri : topological_representation_item := representation_item('') || topological_representation_item();
   END_CONSTANT;


(* ***********************************
Entities in the schema Ship_arrangement_schema
*********************************** *)


   ENTITY action;
      name : label;
      description : OPTIONAL text;
      chosen_method : action_method;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY action_assignment
   ABSTRACT SUPERTYPE;
      assigned_action : action;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY action_method;
      name : label;
      description : OPTIONAL text;
      consequence : text;
      purpose : text;
   END_ENTITY;



   ENTITY action_relationship;
      name : label;
      description : OPTIONAL text;
      relating_action : action;
      related_action : action;
   END_ENTITY;



   ENTITY action_request_assignment
   ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY action_request_solution;
      method : action_method;
      request : versioned_action_request;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY address;
      internal_location : OPTIONAL label;
      street_number : OPTIONAL label;
      street : OPTIONAL label;
      postal_box : OPTIONAL label;
      town : OPTIONAL label;
      region : OPTIONAL label;
      postal_code : OPTIONAL label;
      country : OPTIONAL label;
      facsimile_number : OPTIONAL label;
      telephone_number : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number : OPTIONAL label;
   DERIVE
      name : label := get_name_value(SELF);
      url : identifier := get_id_value(SELF);
   WHERE
      WR1:
         ((((((((((EXISTS(internal_location) OR EXISTS(street_number)) OR EXISTS(street)) OR EXISTS(postal_box)) OR EXISTS(town)) OR EXISTS(region)) OR EXISTS(postal_code)) OR EXISTS(country)) OR EXISTS(facsimile_number)) OR EXISTS(telephone_number)) OR EXISTS(electronic_mail_address)) OR EXISTS(telex_number);
   END_ENTITY;



   ENTITY advanced_face
   SUBTYPE OF (face_surface);
   WHERE
      WR1:
         SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.ELEMENTARY_SURFACE', 'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_SURFACE', 'SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE' ] * TYPEOF(face_geometry)) = 1;
      WR2:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT ('SHIP_ARRANGEMENT_SCHEMA.EDGE_CURVE' IN TYPEOF(oe\oriented_edge.edge_element)))) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.LINE', 'SHIP_ARRANGEMENT_SCHEMA.CONIC', 'SHIP_ARRANGEMENT_SCHEMA.POLYLINE', 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE', 'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT ((('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(oe\edge.edge_start)) AND ('SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT' IN TYPEOF(oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(oe\edge.edge_end)) AND ('SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT' IN TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_PATH' IN TYPEOF(elp_fbnds.bound)))) = 0;
      WR6:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.LINE', 'SHIP_ARRANGEMENT_SCHEMA.CONIC', 'SHIP_ARRANGEMENT_SCHEMA.POLYLINE', 'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE' ] * TYPEOF(face_geometry\swept_surface.swept_curve)) = 1);
      WR7:
         SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) = 0;
      WR8:
         SIZEOF(QUERY (bnd <* bounds| NOT (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP', 'SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' ] * TYPEOF(bnd.bound)) = 1))) = 0;
      WR9:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN TYPEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(QUERY (sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(sc_ag)))) = 0))) = 0))) = 0;
      WR10:
         (NOT ('SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR (NOT ('SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN TYPEOF(face_geometry\swept_surface.swept_curve)) OR (SIZEOF(face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN TYPEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3))) = 0))) = 0);
   END_ENTITY;



   ENTITY amount_of_substance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY amount_of_substance_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY application_context;
      application : label;
   DERIVE
      description : text := get_description_value(SELF);
      id : identifier := get_id_value(SELF);
   INVERSE
      context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY application_context_element
   SUPERTYPE OF (ONEOF(product_context, product_definition_context));
      name : label;
      frame_of_reference : application_context;
   END_ENTITY;



   ENTITY application_protocol_definition;
      status : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year : year_number;
      application : application_context;
   END_ENTITY;



   ENTITY applied_action_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_item;
   END_ENTITY;



   ENTITY applied_action_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF action_request_item;
   END_ENTITY;



   ENTITY applied_approval_assignment
   SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
   END_ENTITY;



   ENTITY applied_classification_assignment
   SUBTYPE OF (classification_assignment);
      items : SET [1:?] OF classification_item;
   END_ENTITY;



   ENTITY applied_date_and_time_assignment
   SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
   END_ENTITY;



   ENTITY applied_document_reference
   SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_reference_item;
   END_ENTITY;



   ENTITY applied_effectivity_assignment
   SUBTYPE OF (effectivity_assignment);
      items : SET [1:?] OF effectivity_item;
   END_ENTITY;



   ENTITY applied_external_identification_assignment
   SUBTYPE OF (external_identification_assignment);
      items : SET [1:?] OF external_identification_item;
   END_ENTITY;



   ENTITY applied_group_assignment
   SUBTYPE OF (group_assignment);
      items : SET [1:?] OF group_item;
   END_ENTITY;



   ENTITY applied_identification_assignment
   SUBTYPE OF (identification_assignment);
      items : SET [1:?] OF identification_item;
   END_ENTITY;



   ENTITY applied_organization_assignment
   SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
   END_ENTITY;



   ENTITY applied_person_and_organization_assignment
   SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
   END_ENTITY;



   ENTITY applied_person_assignment
   SUBTYPE OF (person_assignment);
      items : SET [1:?] OF person_item;
   END_ENTITY;



   ENTITY approval;
      status : approval_status;
      level : label;
   END_ENTITY;



   ENTITY approval_assignment
   ABSTRACT SUPERTYPE;
      assigned_approval : approval;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY approval_date_time;
      date_time : date_time_select;
      dated_approval : approval;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role : approval_role;
   END_ENTITY;



   ENTITY approval_role;
      role : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY approval_status;
      name : label;
   END_ENTITY;



   ENTITY area_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY axis1_placement
   SUBTYPE OF (placement);
      axis : OPTIONAL direction;
   DERIVE
      z : direction := NVL(normalise(axis), dummy_gri || direction([ 0.00000, 0.00000, 1.00000 ]));
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
   DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
      axis : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
   DERIVE
      p : LIST [3:3] OF direction := build_axes(axis, ref_direction);
   WHERE
      WR1:
         SELF\placement.location.dim = 3;
      WR2:
         NOT EXISTS(axis) OR (axis.dim = 3);
      WR3:
         NOT EXISTS(ref_direction) OR (ref_direction.dim = 3);
      WR4:
         (NOT EXISTS(axis) OR NOT EXISTS(ref_direction)) OR (cross_product(axis, ref_direction).magnitude > 0.00000);
   END_ENTITY;



   ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF(uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve)
   SUBTYPE OF (bounded_curve);
      degree : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form : b_spline_curve_form;
      closed_curve : LOGICAL;
      self_intersect : LOGICAL;
   DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(control_points_list) - 1;
      control_points : ARRAY [0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list, 0, upper_index_on_control_points);
   WHERE
      WR1:
         ((('SHIP_ARRANGEMENT_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR ('SHIP_ARRANGEMENT_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF))) OR ('SHIP_ARRANGEMENT_SCHEMA.BEZIER_CURVE' IN TYPEOF(SELF))) OR ('SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots : LIST [2:?] OF parameter_value;
      knot_spec : knot_type;
   DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
   WHERE
      WR1:
         constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots);
      WR2:
         SIZEOF(knot_multiplicities) = upper_index_on_knots;
   END_ENTITY;



   ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF(b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface)
   SUBTYPE OF (bounded_surface);
      u_degree : INTEGER;
      v_degree : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form : b_spline_surface_form;
      u_closed : LOGICAL;
      v_closed : LOGICAL;
      self_intersect : LOGICAL;
   DERIVE
      u_upper : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF cartesian_point := make_array_of_array(control_points_list, 0, u_upper, 0, v_upper);
   WHERE
      WR1:
         ((('SHIP_ARRANGEMENT_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('SHIP_ARRANGEMENT_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF))) OR ('SHIP_ARRANGEMENT_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF))) OR ('SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots : LIST [2:?] OF parameter_value;
      v_knots : LIST [2:?] OF parameter_value;
      knot_spec : knot_type;
   DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
   WHERE
      WR1:
         constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper, u_multiplicities, u_knots);
      WR2:
         constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper, v_multiplicities, v_knots);
      WR3:
         SIZEOF(u_multiplicities) = knot_u_upper;
      WR4:
         SIZEOF(v_multiplicities) = knot_v_upper;
   END_ENTITY;



   ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY bounded_curve
   SUPERTYPE OF (ONEOF(polyline, b_spline_curve, bounded_pcurve, bounded_surface_curve, composite_curve))
   SUBTYPE OF (curve);
   END_ENTITY;



   ENTITY bounded_pcurve
   SUBTYPE OF (pcurve, bounded_curve);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]);
   END_ENTITY;



   ENTITY bounded_surface
   SUPERTYPE OF (b_spline_surface)
   SUBTYPE OF (surface);
   END_ENTITY;



   ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve, bounded_curve);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d);
   END_ENTITY;



   ENTITY calendar_date
   SUBTYPE OF (date);
      day_component : day_in_month_number;
      month_component : month_in_year_number;
   WHERE
      WR1:
         valid_calendar_date(SELF);
   END_ENTITY;



   ENTITY cartesian_point
   SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
   END_ENTITY;



   ENTITY cartesian_transformation_operator
   SUPERTYPE OF (cartesian_transformation_operator_3d)
   SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
      axis1 : OPTIONAL direction;
      axis2 : OPTIONAL direction;
      local_origin : cartesian_point;
      scale : OPTIONAL REAL;
   DERIVE
      scl : REAL := NVL(scale, 1.00000);
   WHERE
      WR1:
         scl > 0.00000;
   END_ENTITY;



   ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
   DERIVE
      u : LIST [3:3] OF direction := base_axis(3, SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2, axis3);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY characterized_object;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY circle
   SUBTYPE OF (conic);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY class
   SUBTYPE OF (group);
   WHERE
      WR1:
         SIZEOF(QUERY (oa <* USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.GROUP_ASSIGNMENT.ASSIGNED_GROUP')| NOT ('SHIP_ARRANGEMENT_SCHEMA.APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(oa)))) = 0;
   END_ENTITY;



   ENTITY classification_assignment
   ABSTRACT SUPERTYPE;
      assigned_class : group;
      role : classification_role;
   END_ENTITY;



   ENTITY classification_role;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
   END_ENTITY;



   ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
      segments : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
   DERIVE
      n_segments : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
   WHERE
      WR1:
         NOT closed_curve AND (SIZEOF(QUERY (temp <* segments| (temp.transition = discontinuous))) = 1) OR closed_curve AND (SIZEOF(QUERY (temp <* segments| (temp.transition = discontinuous))) = 0);
   END_ENTITY;



   ENTITY composite_curve_on_surface
   SUBTYPE OF (composite_curve);
   DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
   WHERE
      WR1:
         SIZEOF(basis_surface) > 0;
      WR2:
         constraints_composite_curve_on_surface(SELF);
   END_ENTITY;



   ENTITY composite_curve_segment
   SUBTYPE OF (founded_item);
      transition : transition_code;
      same_sense : BOOLEAN;
      parent_curve : curve;
   INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve);
   END_ENTITY;



   ENTITY compound_representation_item
   SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
   END_ENTITY;



   ENTITY conic
   SUPERTYPE OF (ONEOF(circle, ellipse, hyperbola, parabola))
   SUBTYPE OF (curve);
      position : axis2_placement;
   END_ENTITY;



   ENTITY conical_surface
   SUBTYPE OF (elementary_surface);
      radius : length_measure;
      semi_angle : plane_angle_measure;
   WHERE
      WR1:
         radius >= 0.00000;
   END_ENTITY;



   ENTITY connected_face_set
   SUPERTYPE OF (ONEOF(closed_shell, open_shell))
   SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
   END_ENTITY;



   ENTITY context_dependent_unit
   SUBTYPE OF (named_unit);
      name : label;
   END_ENTITY;



   ENTITY conversion_based_unit
   SUBTYPE OF (named_unit);
      name : label;
      conversion_factor : measure_with_unit;
   END_ENTITY;



   ENTITY coordinated_universal_time_offset;
      hour_offset : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense : ahead_or_behind;
   DERIVE
      actual_minute_offset : INTEGER := NVL(minute_offset, 0);
   WHERE
      WR1:
         (0 <= hour_offset) AND (hour_offset < 24);
      WR2:
         (0 <= actual_minute_offset) AND (actual_minute_offset <= 59);
      WR3:
         NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = exact));
   END_ENTITY;



   ENTITY curve
   SUPERTYPE OF (ONEOF(line, conic, pcurve, surface_curve, offset_curve_3d, curve_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY curve_replica
   SUBTYPE OF (curve);
      parent_curve : curve;
      transformation : cartesian_transformation_operator;
   WHERE
      WR1:
         transformation.dim = parent_curve.dim;
      WR2:
         acyclic_curve_replica(SELF, parent_curve);
   END_ENTITY;



   ENTITY cylindrical_surface
   SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY date
   SUPERTYPE OF (ONEOF(calendar_date, ordinal_date, week_of_year_and_day_date));
      year_component : year_number;
   END_ENTITY;



   ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
   END_ENTITY;



   ENTITY date_and_time_assignment
   ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role : date_time_role;
   END_ENTITY;



   ENTITY date_time_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY definitional_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
   END_ENTITY;



   ENTITY degenerate_pcurve
   SUBTYPE OF (point);
      basis_surface : surface;
      reference_to_curve : definitional_representation;
   WHERE
      WR1:
         SIZEOF(reference_to_curve\representation.items) = 1;
      WR2:
         'SHIP_ARRANGEMENT_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
      WR3:
         reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
   WHERE
      WR1:
         major_radius < minor_radius;
   END_ENTITY;



   ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
   DERIVE
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         (SIZEOF(elements) > 1) OR (SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.00000);
      WR2:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY derived_unit_element;
      unit : named_unit;
      exponent : REAL;
   END_ENTITY;



   ENTITY description_attribute;
      attribute_value : text;
      described_item : description_attribute_select;
   END_ENTITY;



   ENTITY descriptive_representation_item
   SUBTYPE OF (representation_item);
      description : text;
   END_ENTITY;



   ENTITY dimensional_exponents;
      length_exponent : REAL;
      mass_exponent : REAL;
      time_exponent : REAL;
      electric_current_exponent : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent : REAL;
      luminous_intensity_exponent : REAL;
   END_ENTITY;



   ENTITY direction
   SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
   WHERE
      WR1:
         SIZEOF(QUERY (tmp <* direction_ratios| (tmp <> 0.00000))) > 0;
   END_ENTITY;



   ENTITY document;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      kind : document_type;
   INVERSE
      representation_types : SET [0:?] OF document_representation_type FOR represented_document;
   END_ENTITY;



   ENTITY document_reference
   ABSTRACT SUPERTYPE;
      assigned_document : document;
      source : label;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY document_representation_type;
      name : label;
      represented_document : document;
   END_ENTITY;



   ENTITY document_type;
      product_data_type : label;
   END_ENTITY;



   ENTITY document_usage_constraint;
      source : document;
      subject_element : label;
      subject_element_value : text;
   END_ENTITY;



   ENTITY edge
   SUPERTYPE OF (ONEOF(edge_curve, oriented_edge))
   SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end : vertex;
   END_ENTITY;



   ENTITY edge_curve
   SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense : BOOLEAN;
   END_ENTITY;



   ENTITY edge_loop
   SUBTYPE OF (loop, path);
   DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
   WHERE
      WR1:
         SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].edge_end;
   END_ENTITY;



   ENTITY effectivity
   SUPERTYPE OF (serial_numbered_effectivity);
      id : identifier;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY effectivity_assignment
   ABSTRACT SUPERTYPE;
      assigned_effectivity : effectivity;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY electric_current_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY electric_current_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY elementary_surface
   SUPERTYPE OF (ONEOF(plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))
   SUBTYPE OF (surface);
      position : axis2_placement_3d;
   END_ENTITY;



   ENTITY ellipse
   SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
   END_ENTITY;



   ENTITY evaluated_degenerate_pcurve
   SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
   END_ENTITY;



   ENTITY executed_action
   SUBTYPE OF (action);
   END_ENTITY;



   ENTITY external_identification_assignment
   ABSTRACT SUPERTYPE
   SUBTYPE OF (identification_assignment);
      source : external_source;
   END_ENTITY;



   ENTITY external_source;
      source_id : source_item;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY external_source_relationship;
      name : label;
      description : OPTIONAL text;
      relating_source : external_source;
      related_source : external_source;
   END_ENTITY;



   ENTITY face
   SUPERTYPE OF (ONEOF(face_surface, oriented_face))
   SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
   WHERE
      WR1:
         NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)));
      WR2:
         SIZEOF(QUERY (temp <* bounds| ('SHIP_ARRANGEMENT_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp)))) <= 1;
   END_ENTITY;



   ENTITY face_based_surface_model
   SUBTYPE OF (geometric_representation_item);
      fbsm_faces : SET [1:?] OF connected_face_set;
   END_ENTITY;



   ENTITY face_bound
   SUBTYPE OF (topological_representation_item);
      bound : loop;
      orientation : BOOLEAN;
   END_ENTITY;



   ENTITY face_outer_bound
   SUBTYPE OF (face_bound);
   END_ENTITY;



   ENTITY face_surface
   SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense : BOOLEAN;
   WHERE
      WR1:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
   END_ENTITY;



   ENTITY founded_item;
   END_ENTITY;



   ENTITY functionally_defined_transformation;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY geometric_representation_context
   SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
   END_ENTITY;



   ENTITY geometric_representation_item
   SUPERTYPE OF (ONEOF(point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, face_based_surface_model))
   SUBTYPE OF (representation_item);
   DERIVE
      dim : dimension_count := dimension_of(SELF);
   WHERE
      WR1:
         SIZEOF(QUERY (using_rep <* using_representations(SELF)| NOT ('SHIP_ARRANGEMENT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(using_rep.context_of_items)))) = 0;
   END_ENTITY;



   ENTITY global_uncertainty_assigned_context
   SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
   END_ENTITY;



   ENTITY global_unit_assigned_context
   SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
   END_ENTITY;



   ENTITY group;
      name : label;
      description : OPTIONAL text;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY group_assignment
   ABSTRACT SUPERTYPE;
      assigned_group : group;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY group_relationship;
      name : label;
      description : OPTIONAL text;
      relating_group : group;
      related_group : group;
   END_ENTITY;



   ENTITY hyperbola
   SUBTYPE OF (conic);
      semi_axis : positive_length_measure;
      semi_imag_axis : positive_length_measure;
   END_ENTITY;



   ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
   END_ENTITY;



   ENTITY identification_assignment
   ABSTRACT SUPERTYPE;
      assigned_id : identifier;
      role : identification_role;
   END_ENTITY;



   ENTITY identification_assignment_relationship;
      name : label;
      description : OPTIONAL text;
      relating_identification_assignment : identification_assignment;
      related_identification_assignment : identification_assignment;
   END_ENTITY;



   ENTITY identification_role;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY intersection_curve
   SUBTYPE OF (surface_curve);
   WHERE
      WR1:
         SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2:
         associated_surface(SELF\surface_curve.associated_geometry[1]) <> associated_surface(SELF\surface_curve.associated_geometry[2]);
   END_ENTITY;



   ENTITY item_defined_transformation;
      name : label;
      description : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
   END_ENTITY;



   ENTITY length_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY length_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 1.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY line
   SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
   WHERE
      WR1:
         dir.dim = pnt.dim;
   END_ENTITY;



   ENTITY local_time;
      hour_component : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone : coordinated_universal_time_offset;
   WHERE
      WR1:
         valid_time(SELF);
   END_ENTITY;



   ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
   SUBTYPE OF (topological_representation_item);
   END_ENTITY;



   ENTITY luminous_intensity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY luminous_intensity_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.00000);
   END_ENTITY;



   ENTITY mapped_item
   SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
   WHERE
      WR1:
         acyclic_mapped_representation(using_representations(SELF), [ SELF ]);
   END_ENTITY;



   ENTITY mass_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY mass_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 1.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY measure_with_unit
   SUPERTYPE OF (ONEOF(length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit));
      value_component : measure_value;
      unit_component : unit;
   WHERE
      WR1:
         valid_units(SELF);
   END_ENTITY;



   ENTITY name_attribute;
      attribute_value : label;
      named_item : name_attribute_select;
   END_ENTITY;



   ENTITY named_unit
   SUPERTYPE OF (ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, ratio_unit));
      dimensions : dimensional_exponents;
   END_ENTITY;



   ENTITY non_manifold_surface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL', 'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM', 'SHIP_ARRANGEMENT_SCHEMA.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL', 'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)))| NOT (('SHIP_ARRANGEMENT_SCHEMA.' + 'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY (mr_it <* mi\mapped_item.mapping_source.mapped_representation.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(mr_it)))) > 0)))) = 0;
      WR4:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE', 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_FACE' ] * TYPEOF(fa)) = 1))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (f_sf <* QUERY (fa <* cfs.cfs_faces| ('SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)))| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf)) OR nmsf_surface_check(f_sf\face_surface.face_geometry)))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (o_fa <* QUERY (fa <* cfs.cfs_faces| ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_FACE' IN TYPEOF(fa)))| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(o_fa\oriented_face.face_element)) OR nmsf_surface_check(o_fa\oriented_face.face_element\face_surface.face_geometry)))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (bnds <* fa.bounds| NOT (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP', 'SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' ] * TYPEOF(bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ('SHIP_ARRANGEMENT_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe_cv <* QUERY (oe <* elp_fbnds\path.edge_list| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))| NOT (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE', 'SHIP_ARRANGEMENT_SCHEMA.CONIC', 'SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA', 'SHIP_ARRANGEMENT_SCHEMA.LINE', 'SHIP_ARRANGEMENT_SCHEMA.OFFSET_CURVE_3D', 'SHIP_ARRANGEMENT_SCHEMA.PCURVE', 'SHIP_ARRANGEMENT_SCHEMA.POLYLINE', 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' ] * TYPEOF(oe_cv.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT nmsf_curve_check(oe.edge_element\edge_curve.edge_geometry))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT (('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_start)) AND ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ((SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT', 'SHIP_ARRANGEMENT_SCHEMA.DEGENERATE_PCURVE', 'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_CURVE', 'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1) AND (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT', 'SHIP_ARRANGEMENT_SCHEMA.DEGENERATE_PCURVE', 'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_CURVE', 'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR13:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) = 0))) = 0;
      WR14:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT', 'SHIP_ARRANGEMENT_SCHEMA.DEGENERATE_PCURVE', 'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_CURVE', 'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) = 1))) = 0)))) = 0))) = 0))) = 0;
   END_ENTITY;



   ENTITY object_role;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY offset_curve_3d
   SUBTYPE OF (curve);
      basis_curve : curve;
      distance : length_measure;
      self_intersect : LOGICAL;
      ref_direction : direction;
   WHERE
      WR1:
         (basis_curve.dim = 3) AND (ref_direction.dim = 3);
   END_ENTITY;



   ENTITY offset_surface
   SUBTYPE OF (surface);
      basis_surface : surface;
      distance : length_measure;
      self_intersect : LOGICAL;
   END_ENTITY;



   ENTITY open_shell
   SUBTYPE OF (connected_face_set);
   END_ENTITY;



   ENTITY ordinal_date
   SUBTYPE OF (date);
      day_component : day_in_year_number;
   WHERE
      WR1:
         NOT leap_year(SELF.year_component) AND ((1 <= day_component) AND (day_component <= 365)) OR leap_year(SELF.year_component) AND ((1 <= day_component) AND (day_component <= 366));
   END_ENTITY;



   ENTITY organization;
      id : OPTIONAL identifier;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY organization_assignment
   ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role : organization_role;
   END_ENTITY;



   ENTITY organization_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY organizational_address
   SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY organizational_project;
      name : label;
      description : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation : BOOLEAN;
   DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation, SELF.closed_shell_element.cfs_faces);
   WHERE
      WR1:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element));
   END_ENTITY;



   ENTITY oriented_edge
   SUBTYPE OF (edge);
      edge_element : edge;
      orientation : BOOLEAN;
   DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation, SELF.edge_element.edge_start, SELF.edge_element.edge_end);
      SELF\edge.edge_end : vertex := boolean_choose(SELF.orientation, SELF.edge_element.edge_end, SELF.edge_element.edge_start);
   WHERE
      WR1:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
   END_ENTITY;



   ENTITY oriented_face
   SUBTYPE OF (face);
      face_element : face;
      orientation : BOOLEAN;
   DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.orientation, SELF.face_element.bounds);
   WHERE
      WR1:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
   END_ENTITY;



   ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation : BOOLEAN;
   DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation, SELF.open_shell_element.cfs_faces);
   WHERE
      WR1:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF.open_shell_element));
   END_ENTITY;



   ENTITY oriented_path
   SUBTYPE OF (path);
      path_element : path;
      orientation : BOOLEAN;
   DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := conditional_reverse(SELF.orientation, SELF.path_element.edge_list);
   WHERE
      WR1:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
   END_ENTITY;



   ENTITY oriented_surface
   SUBTYPE OF (surface);
      orientation : BOOLEAN;
   END_ENTITY;



   ENTITY parabola
   SUBTYPE OF (conic);
      focal_dist : length_measure;
   WHERE
      WR1:
         focal_dist <> 0.00000;
   END_ENTITY;



   ENTITY parametric_representation_context
   SUBTYPE OF (representation_context);
   END_ENTITY;



   ENTITY path
   SUPERTYPE OF (ONEOF(edge_loop, oriented_path))
   SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
   WHERE
      WR1:
         path_head_to_tail(SELF);
   END_ENTITY;



   ENTITY pcurve
   SUBTYPE OF (curve);
      basis_surface : surface;
      reference_to_curve : definitional_representation;
   WHERE
      WR1:
         SIZEOF(reference_to_curve\representation.items) = 1;
      WR2:
         'SHIP_ARRANGEMENT_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
      WR3:
         reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY person;
      id : identifier;
      last_name : OPTIONAL label;
      first_name : OPTIONAL label;
      middle_names : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
   WHERE
      WR1:
         EXISTS(last_name) OR EXISTS(first_name);
   END_ENTITY;



   ENTITY person_and_organization;
      the_person : person;
      the_organization : organization;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY person_and_organization_assignment
   ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role : person_and_organization_role;
   END_ENTITY;



   ENTITY person_and_organization_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY person_assignment
   ABSTRACT SUPERTYPE;
      assigned_person : person;
      role : person_role;
   END_ENTITY;



   ENTITY person_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY personal_address
   SUBTYPE OF (address);
      people : SET [1:?] OF person;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY placement
   SUPERTYPE OF (ONEOF(axis1_placement, axis2_placement_2d, axis2_placement_3d))
   SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
   END_ENTITY;



   ENTITY plane
   SUBTYPE OF (elementary_surface);
   END_ENTITY;



   ENTITY plane_angle_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY plane_angle_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY point
   SUPERTYPE OF (ONEOF(cartesian_point, point_on_curve, point_on_surface, degenerate_pcurve))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY point_on_curve
   SUBTYPE OF (point);
      basis_curve : curve;
      point_parameter : parameter_value;
   END_ENTITY;



   ENTITY point_on_surface
   SUBTYPE OF (point);
      basis_surface : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
   END_ENTITY;



   ENTITY poly_loop
   SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
   END_ENTITY;



   ENTITY polyline
   SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
   END_ENTITY;



   ENTITY product;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
   END_ENTITY;



   ENTITY product_category;
      name : label;
      description : OPTIONAL text;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY product_category_relationship;
      name : label;
      description : OPTIONAL text;
      category : product_category;
      sub_category : product_category;
   WHERE
      WR1:
         acyclic_product_category_relationship(SELF, [ SELF.sub_category ]);
   END_ENTITY;



   ENTITY product_context
   SUBTYPE OF (application_context_element);
      discipline_type : label;
   END_ENTITY;



   ENTITY product_definition;
      id : identifier;
      description : OPTIONAL text;
      formation : product_definition_formation;
      frame_of_reference : product_definition_context;
   DERIVE
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY product_definition_context
   SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
   END_ENTITY;



   ENTITY product_definition_formation;
      id : identifier;
      description : OPTIONAL text;
      of_product : product;
   UNIQUE
      UR1 : id, of_product;
   END_ENTITY;



   ENTITY product_definition_relationship;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition : product_definition;
   END_ENTITY;



   ENTITY product_definition_shape
   SUBTYPE OF (property_definition);
   UNIQUE
      UR1 : SELF\property_definition.definition;
   WHERE
      WR1:
         SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'SHIP_ARRANGEMENT_SCHEMA.CHARACTERIZED_OBJECT' ] * TYPEOF(SELF\property_definition.definition)) > 0;
   END_ENTITY;



   ENTITY product_definition_with_associated_documents
   SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
   END_ENTITY;



   ENTITY product_related_product_category
   SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
   END_ENTITY;



   ENTITY property_definition;
      name : label;
      description : OPTIONAL text;
      definition : characterized_definition;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY property_definition_relationship;
      name : label;
      description : text;
      relating_property_definition : property_definition;
      related_property_definition : property_definition;
   END_ENTITY;



   ENTITY property_definition_representation;
      definition : represented_definition;
      used_representation : representation;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY ratio_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY ratio_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
   DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := list_to_array(weights_data, 0, upper_index_on_control_points);
   WHERE
      WR1:
         SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.control_points_list);
      WR2:
         curve_weights_positive(SELF);
   END_ENTITY;



   ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
   DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := make_array_of_array(weights_data, 0, u_upper, 0, v_upper);
   WHERE
      WR1:
         (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
      WR2:
         surface_weights_positive(SELF);
   END_ENTITY;



   ENTITY representation;
      name : label;
      items : SET [1:?] OF representation_item;
      context_of_items : representation_context;
   DERIVE
      id : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY representation_context;
      context_identifier : identifier;
      context_type : text;
   INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
   END_ENTITY;



   ENTITY representation_item;
      name : label;
   WHERE
      WR1:
         SIZEOF(using_representations(SELF)) > 0;
   END_ENTITY;



   ENTITY representation_map;
      mapping_origin : representation_item;
      mapped_representation : representation;
   INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
   WHERE
      WR1:
         item_in_context(SELF.mapping_origin, SELF.mapped_representation.context_of_items);
   END_ENTITY;



   ENTITY representation_relationship;
      name : label;
      description : OPTIONAL text;
      rep_1 : representation;
      rep_2 : representation;
   END_ENTITY;



   ENTITY role_association;
      role : object_role;
      item_with_role : role_select;
   END_ENTITY;



   ENTITY seam_curve
   SUBTYPE OF (surface_curve);
   WHERE
      WR1:
         SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2:
         associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2]);
      WR3:
         'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
      WR4:
         'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
   END_ENTITY;



   ENTITY serial_numbered_effectivity
   SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id : OPTIONAL identifier;
   END_ENTITY;



   ENTITY shape_aspect;
      name : label;
      description : OPTIONAL text;
      of_shape : product_definition_shape;
      product_definitional : LOGICAL;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY shape_definition_representation
   SUBTYPE OF (property_definition_representation);
   WHERE
      WR1:
         ('SHIP_ARRANGEMENT_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF.definition)) OR ('SHIP_ARRANGEMENT_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition));
      WR2:
         'SHIP_ARRANGEMENT_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
   END_ENTITY;



   ENTITY shape_representation
   SUBTYPE OF (representation);
   END_ENTITY;



   ENTITY si_unit
   SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name : si_unit_name;
   DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
   END_ENTITY;



   ENTITY solid_angle_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY solid_angle_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY surface
   SUPERTYPE OF (ONEOF(elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY surface_curve
   SUPERTYPE OF (ONEOF(intersection_curve, seam_curve) ANDOR bounded_surface_curve)
   SUBTYPE OF (curve);
      curve_3d : curve;
      associated_geometry : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
   DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
   WHERE
      WR1:
         curve_3d.dim = 3;
      WR2:
         ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation <> pcurve_s1);
      WR3:
         ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation <> pcurve_s2);
      WR4:
         NOT ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
   END_ENTITY;



   ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
   END_ENTITY;



   ENTITY surface_of_revolution
   SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis_position.location, representation_item('') || geometric_representation_item() || vector(axis_position.z, 1.00000));
   END_ENTITY;



   ENTITY surface_replica
   SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
   WHERE
      WR1:
         acyclic_surface_replica(SELF, parent_surface);
   END_ENTITY;



   ENTITY swept_surface
   SUPERTYPE OF (ONEOF(surface_of_linear_extrusion, surface_of_revolution))
   SUBTYPE OF (surface);
      swept_curve : curve;
   END_ENTITY;



   ENTITY thermodynamic_temperature_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY thermodynamic_temperature_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY time_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY time_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 1.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_face_set, loop ANDOR path))
   SUBTYPE OF (representation_item);
   END_ENTITY;



   ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
   END_ENTITY;



   ENTITY uncertainty_measure_with_unit
   SUBTYPE OF (measure_with_unit);
      name : label;
      description : OPTIONAL text;
   WHERE
      WR1:
         valid_measure_value(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY value_representation_item
   SUBTYPE OF (representation_item);
      value_component : measure_value;
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* using_representations(SELF)| NOT ('SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(rep.context_of_items)))) = 0;
   END_ENTITY;



   ENTITY vector
   SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude : length_measure;
   WHERE
      WR1:
         magnitude >= 0.00000;
   END_ENTITY;



   ENTITY versioned_action_request;
      id : identifier;
      version : label;
      purpose : text;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY vertex
   SUBTYPE OF (topological_representation_item);
   END_ENTITY;



   ENTITY vertex_loop
   SUBTYPE OF (loop);
      loop_vertex : vertex;
   END_ENTITY;



   ENTITY vertex_point
   SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
   END_ENTITY;



   ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
   END_ENTITY;



   ENTITY volume_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SHIP_ARRANGEMENT_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY week_of_year_and_day_date
   SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component : OPTIONAL day_in_week_number;
   END_ENTITY;



   ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
   WHERE
      WR1:
         NOT mixed_loop_type_set(wire_shell_extent);
   END_ENTITY;


(* ***********************************
Types in the schema Ship_arrangement_schema
*********************************** *)


   TYPE action_item = SELECT
      (action_request_solution,
       document,
       executed_action,
       group,
       product,
       product_definition,
       product_definition_relationship,
       product_definition_shape,
       product_related_product_category,
       property_definition);
   END_TYPE;



   TYPE action_request_item = SELECT
      (action,
       executed_action);
   END_TYPE;



   TYPE ahead_or_behind = ENUMERATION OF
      (ahead,
       exact,
       behind);
   END_TYPE;



   TYPE amount_of_substance_measure = REAL;
   END_TYPE;



   TYPE approval_item = SELECT
      (product_definition,
       product_definition_shape,
       product_related_product_category,
       property_definition);
   END_TYPE;



   TYPE area_measure = REAL;
   END_TYPE;



   TYPE attribute_type = SELECT
      (label,
       text);
   END_TYPE;



   TYPE axis2_placement = SELECT
      (axis2_placement_2d,
       axis2_placement_3d);
   END_TYPE;



   TYPE b_spline_curve_form = ENUMERATION OF
      (polyline_form,
       circular_arc,
       elliptic_arc,
       parabolic_arc,
       hyperbolic_arc,
       unspecified);
   END_TYPE;



   TYPE b_spline_surface_form = ENUMERATION OF
      (plane_surf,
       cylindrical_surf,
       conical_surf,
       spherical_surf,
       toroidal_surf,
       surf_of_revolution,
       ruled_surf,
       generalised_cone,
       quadric_surf,
       surf_of_linear_extrusion,
       unspecified);
   END_TYPE;



   TYPE characterized_action_definition = SELECT
      (action,
       action_method,
       action_relationship);
   END_TYPE;



   TYPE characterized_definition = SELECT
      (characterized_object,
       characterized_product_definition,
       shape_definition);
   END_TYPE;



   TYPE characterized_product_definition = SELECT
      (product_definition,
       product_definition_relationship);
   END_TYPE;



   TYPE classification_item = SELECT
      (action,
       action_request_solution,
       applied_action_request_assignment,
       approval,
       compound_representation_item,
       document,
       executed_action,
       external_source,
       group,
       identification_assignment_relationship,
       product,
       product_definition,
       product_definition_relationship,
       product_definition_shape,
       product_related_product_category,
       property_definition,
       property_definition_representation,
       representation,
       representation_item,
       shape_aspect,
       surface,
       versioned_action_request);
   END_TYPE;



   TYPE compound_item_definition = SELECT
      (list_representation_item,
       set_representation_item);
   END_TYPE;



   TYPE configuration_design_item = SELECT
      (product_definition,
       product_definition_formation);
   END_TYPE;



   TYPE context_dependent_measure = REAL;
   END_TYPE;



   TYPE count_measure = NUMBER;
   END_TYPE;



   TYPE curve_on_surface = SELECT
      (pcurve,
       surface_curve,
       composite_curve_on_surface);
   END_TYPE;



   TYPE date_and_time_item = SELECT
      (action,
       action_request_solution,
       executed_action,
       product_definition,
       property_definition,
       property_definition_representation,
       versioned_action_request);
   END_TYPE;



   TYPE date_time_or_event_occurrence = SELECT
      (date_time_select);
   END_TYPE;



   TYPE date_time_select = SELECT
      (date,
       local_time,
       date_and_time);
   END_TYPE;



   TYPE day_in_month_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 31);
   END_TYPE;



   TYPE day_in_week_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 7);
   END_TYPE;



   TYPE day_in_year_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 366);
   END_TYPE;



   TYPE derived_property_select = SELECT
      (property_definition);
   END_TYPE;



   TYPE description_attribute_select = SELECT
      (action_request_solution,
       application_context,
       approval_role,
       date_time_role,
       effectivity,
       external_source,
       organization_role,
       person_and_organization_role,
       person_and_organization,
       person_role,
       property_definition_representation,
       representation);
   END_TYPE;



   TYPE dimension_count = INTEGER;
   WHERE
      WR1:
         SELF > 0;
   END_TYPE;



   TYPE document_reference_item = SELECT
      (action,
       product,
       product_definition,
       property_definition);
   END_TYPE;



   TYPE effectivity_item = SELECT
      (product_definition,
       product_definition_shape,
       product_related_product_category,
       property_definition);
   END_TYPE;



   TYPE electric_current_measure = REAL;
   END_TYPE;



   TYPE external_identification_item = SELECT
      (action,
       document,
       product,
       product_definition,
       property_definition);
   END_TYPE;



   TYPE founded_item_select = SELECT
      (founded_item,
       representation_item);
   END_TYPE;



   TYPE geometric_set_select = SELECT
      (point,
       curve,
       surface);
   END_TYPE;



   TYPE group_item = SELECT
      (applied_external_identification_assignment,
       approval,
       document,
       group,
       identification_assignment_relationship,
       product,
       product_definition,
       product_definition_relationship,
       product_definition_shape,
       product_related_product_category,
       property_definition);
   END_TYPE;



   TYPE hour_in_day = INTEGER;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF < 24);
   END_TYPE;



   TYPE id_attribute_select = SELECT
      (action,
       address,
       product_category,
       property_definition,
       shape_aspect,
       application_context,
       group,
       organizational_project,
       representation);
   END_TYPE;



   TYPE identification_item = SELECT
      (action,
       action_request_solution,
       compound_representation_item,
       document,
       executed_action,
       group,
       product,
       product_definition,
       product_definition_relationship,
       product_definition_shape,
       product_related_product_category,
       property_definition,
       surface,
       versioned_action_request);
   END_TYPE;



   TYPE identifier = STRING;
   END_TYPE;



   TYPE knot_type = ENUMERATION OF
      (uniform_knots,
       quasi_uniform_knots,
       piecewise_bezier_knots,
       unspecified);
   END_TYPE;



   TYPE label = STRING;
   END_TYPE;



   TYPE length_measure = REAL;
   END_TYPE;



   TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
   END_TYPE;



   TYPE list_representation_item = LIST [1:?] OF representation_item;
   END_TYPE;



   TYPE luminous_intensity_measure = REAL;
   END_TYPE;



   TYPE mass_measure = REAL;
   END_TYPE;



   TYPE measure_value = SELECT
      (length_measure,
       mass_measure,
       time_measure,
       electric_current_measure,
       thermodynamic_temperature_measure,
       amount_of_substance_measure,
       luminous_intensity_measure,
       plane_angle_measure,
       solid_angle_measure,
       area_measure,
       volume_measure,
       ratio_measure,
       parameter_value,
       context_dependent_measure,
       positive_length_measure,
       positive_plane_angle_measure,
       count_measure);
   END_TYPE;



   TYPE minute_in_hour = INTEGER;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF <= 59);
   END_TYPE;



   TYPE month_in_year_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 12);
   END_TYPE;



   TYPE name_attribute_select = SELECT
      (action_request_solution,
       address,
       derived_unit,
       effectivity,
       person_and_organization,
       product_definition,
       property_definition_representation);
   END_TYPE;



   TYPE organization_item = SELECT
      (document,
       product_definition,
       property_definition);
   END_TYPE;



   TYPE parameter_value = REAL;
   END_TYPE;



   TYPE pcurve_or_surface = SELECT
      (pcurve,
       surface);
   END_TYPE;



   TYPE person_and_organization_item = SELECT
      (action,
       action_request_solution,
       document,
       executed_action,
       versioned_action_request);
   END_TYPE;



   TYPE person_item = SELECT
      (document);
   END_TYPE;



   TYPE person_organization_select = SELECT
      (person,
       organization,
       person_and_organization);
   END_TYPE;



   TYPE plane_angle_measure = REAL;
   END_TYPE;



   TYPE positive_length_measure = length_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE positive_plane_angle_measure = plane_angle_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE preferred_surface_curve_representation = ENUMERATION OF
      (curve_3d,
       pcurve_s1,
       pcurve_s2);
   END_TYPE;



   TYPE product_or_formation_or_definition = SELECT
      (product,
       product_definition_formation,
       product_definition);
   END_TYPE;



   TYPE property_or_shape_select = SELECT
      (property_definition,
       shape_definition);
   END_TYPE;



   TYPE ratio_measure = REAL;
   END_TYPE;



   TYPE represented_definition = SELECT
      (property_definition,
       property_definition_relationship,
       shape_aspect);
   END_TYPE;



   TYPE reversible_topology = SELECT
      (reversible_topology_item,
       list_of_reversible_topology_item,
       set_of_reversible_topology_item);
   END_TYPE;



   TYPE reversible_topology_item = SELECT
      (edge,
       path,
       face,
       face_bound,
       closed_shell,
       open_shell);
   END_TYPE;



   TYPE role_select = SELECT
      (action_assignment,
       action_request_assignment,
       approval_assignment,
       approval_date_time,
       document_reference,
       effectivity_assignment,
       group_assignment);
   END_TYPE;



   TYPE second_in_minute = REAL;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF <= 60.0000);
   END_TYPE;



   TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
   END_TYPE;



   TYPE set_representation_item = SET [1:?] OF representation_item;
   END_TYPE;



   TYPE shape_definition = SELECT
      (product_definition_shape,
       shape_aspect);
   END_TYPE;



   TYPE shell = SELECT
      (vertex_shell,
       wire_shell,
       open_shell,
       closed_shell);
   END_TYPE;



   TYPE si_prefix = ENUMERATION OF
      (exa,
       peta,
       tera,
       giga,
       mega,
       kilo,
       hecto,
       deca,
       deci,
       centi,
       milli,
       micro,
       nano,
       pico,
       femto,
       atto);
   END_TYPE;



   TYPE si_unit_name = ENUMERATION OF
      (metre,
       gram,
       second,
       ampere,
       kelvin,
       mole,
       candela,
       radian,
       steradian,
       hertz,
       newton,
       pascal,
       joule,
       watt,
       coulomb,
       volt,
       farad,
       ohm,
       siemens,
       weber,
       tesla,
       henry,
       degree_celsius,
       lumen,
       lux,
       becquerel,
       gray,
       sievert);
   END_TYPE;



   TYPE solid_angle_measure = REAL;
   END_TYPE;



   TYPE source_item = SELECT
      (identifier);
   END_TYPE;



   TYPE supported_item = SELECT
      (action,
       action_method);
   END_TYPE;



   TYPE surface_boundary = SELECT
      (degenerate_pcurve);
   END_TYPE;



   TYPE surface_model = SELECT
      (face_based_surface_model);
   END_TYPE;



   TYPE text = STRING;
   END_TYPE;



   TYPE thermodynamic_temperature_measure = REAL;
   END_TYPE;



   TYPE time_measure = REAL;
   END_TYPE;



   TYPE transformation = SELECT
      (item_defined_transformation,
       functionally_defined_transformation);
   END_TYPE;



   TYPE transition_code = ENUMERATION OF
      (discontinuous,
       continuous,
       cont_same_gradient,
       cont_same_gradient_same_curvature);
   END_TYPE;



   TYPE trimming_select = SELECT
      (cartesian_point,
       parameter_value);
   END_TYPE;



   TYPE unit = SELECT
      (named_unit,
       derived_unit);
   END_TYPE;



   TYPE vector_or_direction = SELECT
      (vector,
       direction);
   END_TYPE;



   TYPE volume_measure = REAL;
   END_TYPE;



   TYPE week_in_year_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 53);
   END_TYPE;



   TYPE year_number = INTEGER;
   END_TYPE;


(* ***********************************
Functions in the schema Ship_arrangement_schema
*********************************** *)


   FUNCTION WHICH_CLASS
      (T : GENERIC ) : LIST OF STRING;
   LOCAL
      elements : BAG OF applied_classification_assignment;
      class_list : LIST OF STRING := [];
   END_LOCAL;
      elements := USEDIN(T, 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS');
      REPEAT i := 1 TO HIINDEX(elements);
         IF elements[i]\classification_assignment.role.name = 'class membership' THEN
            class_list := class_list + elements[i]\classification_assignment.assigned_class\group.name;
         END_IF;
      END_REPEAT;
      RETURN (class_list);
   END_FUNCTION;



   FUNCTION acyclic_curve_replica
      (rep : curve_replica;
       parent : curve ) : BOOLEAN;
      IF NOT ('SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_curve_replica(rep, parent\curve_replica.parent_curve));
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_mapped_representation
      (parent_set : SET OF representation;
       children_set : SET OF representation_item ) : BOOLEAN;
   LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
   END_LOCAL;
      x := QUERY (z <* children_set| 'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM' IN TYPEOF(z));
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            IF x[i]\mapped_item.mapping_source.mapped_representation IN parent_set THEN
               RETURN (FALSE);
            END_IF;
            IF NOT acyclic_mapped_representation((parent_set + x[i]\mapped_item.mapping_source.mapped_representation), x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      x := children_set - x;
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            y := QUERY (z <* bag_to_set(USEDIN(x[i], ''))| 'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
            IF NOT acyclic_mapped_representation(parent_set, y) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_product_category_relationship
      (relation : product_category_relationship;
       children : SET OF product_category ) : BOOLEAN;
   LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(children);
         IF relation.category :=: children[i] THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      x := bag_to_set(USEDIN(relation.category, 'SHIP_ARRANGEMENT_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
      local_children := children + relation.category;
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_surface_replica
      (rep : surface_replica;
       parent : surface ) : BOOLEAN;
      IF NOT ('SHIP_ARRANGEMENT_SCHEMA.SURFACE_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_surface_replica(rep, parent\surface_replica.parent_surface));
      END_IF;
   END_FUNCTION;



   FUNCTION associated_surface
      (arg : pcurve_or_surface ) : surface;
   LOCAL
      surf : surface;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
         surf := arg.basis_surface;
      ELSE
         surf := arg;
      END_IF;
      RETURN (surf);
   END_FUNCTION;



   FUNCTION bag_to_set
      (the_bag : BAG OF GENERIC : intype ) : SET OF GENERIC : intype;
   LOCAL
      the_set : SET OF GENERIC : intype := [];
   END_LOCAL;
      IF SIZEOF(the_bag) > 0 THEN
         REPEAT i := 1 TO HIINDEX(the_bag);
            the_set := the_set + the_bag[i];
         END_REPEAT;
      END_IF;
      RETURN (the_set);
   END_FUNCTION;



   FUNCTION base_axis
      (dim : INTEGER;
       axis1 : direction;
       axis2 : direction;
       axis3 : direction ) : LIST [2:3] OF direction;
   LOCAL
      u : LIST [2:3] OF direction;
      factor : REAL;
      d1 : direction;
      d2 : direction;
   END_LOCAL;
      IF dim = 3 THEN
         d1 := NVL(normalise(axis3), dummy_gri || direction([ 0.00000, 0.00000, 1.00000 ]));
         d2 := first_proj_axis(d1, axis1);
         u := [ d2, second_proj_axis(d1, d2, axis2), d1 ];
      ELSE
         IF EXISTS(axis1) THEN
            d1 := normalise(axis1);
            u := [ d1, orthogonal_complement(d1) ];
            IF EXISTS(axis2) THEN
               factor := dot_product(axis2, u[2]);
               IF factor < 0.00000 THEN
                  u[2].direction_ratios[1] := -u[2].direction_ratios[1];
                  u[2].direction_ratios[2] := -u[2].direction_ratios[2];
               END_IF;
            END_IF;
         ELSE
            IF EXISTS(axis2) THEN
               d1 := normalise(axis2);
               u := [ orthogonal_complement(d1), d1 ];
               u[1].direction_ratios[1] := -u[1].direction_ratios[1];
               u[1].direction_ratios[2] := -u[1].direction_ratios[2];
            ELSE
               u := [ dummy_gri || direction([ 1.00000, 0.00000 ]), dummy_gri || direction([ 0.00000, 1.00000 ]) ];
            END_IF;
         END_IF;
      END_IF;
      RETURN (u);
   END_FUNCTION;



   FUNCTION boolean_choose
      (b : BOOLEAN;
       choice1 : GENERIC : item;
       choice2 : GENERIC : item ) : GENERIC : item;
      IF b THEN
         RETURN (choice1);
      ELSE
         RETURN (choice2);
      END_IF;
   END_FUNCTION;



   FUNCTION build_2axes
      (ref_direction : direction ) : LIST [2:2] OF direction;
   LOCAL
      d : direction := NVL(normalise(ref_direction), dummy_gri || direction([ 1.00000, 0.00000 ]));
   END_LOCAL;
      RETURN ([ d, orthogonal_complement(d) ]);
   END_FUNCTION;



   FUNCTION build_axes
      (axis : direction;
       ref_direction : direction ) : LIST [3:3] OF direction;
   LOCAL
      d1 : direction;
      d2 : direction;
   END_LOCAL;
      d1 := NVL(normalise(axis), dummy_gri || direction([ 0.00000, 0.00000, 1.00000 ]));
      d2 := first_proj_axis(d1, ref_direction);
      RETURN ([ d2, normalise(cross_product(d1, d2)).orientation, d1 ]);
   END_FUNCTION;



   FUNCTION closed_shell_reversed
      (a_shell : closed_shell ) : oriented_closed_shell;
   LOCAL
      the_reverse : oriented_closed_shell;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell) THEN
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() || oriented_closed_shell(a_shell\oriented_closed_shell.closed_shell_element, NOT a_shell\oriented_closed_shell.orientation);
      ELSE
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() || oriented_closed_shell(a_shell, FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION conditional_reverse
      (p : BOOLEAN;
       an_item : reversible_topology ) : reversible_topology;
      IF p THEN
         RETURN (an_item);
      ELSE
         RETURN (topology_reversed(an_item));
      END_IF;
   END_FUNCTION;



   FUNCTION constraints_composite_curve_on_surface
      (c : composite_curve_on_surface ) : BOOLEAN;
   LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
      REPEAT k := 1 TO n_segments;
         IF (NOT ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve)) AND NOT ('SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve))) AND NOT ('SHIP_ARRANGEMENT_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\composite_curve.segments[k].parent_curve)) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION constraints_param_b_spline
      (degree : INTEGER;
       up_knots : INTEGER;
       up_cp : INTEGER;
       knot_mult : LIST OF INTEGER;
       knots : LIST OF parameter_value ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
      k : INTEGER;
      sum : INTEGER;
   END_LOCAL;
      sum := knot_mult[1];
      REPEAT i := 2 TO up_knots;
         sum := sum + knot_mult[i];
      END_REPEAT;
      IF (((degree < 1) OR (up_knots < 2)) OR (up_cp < degree)) OR (sum <> degree + up_cp + 2) THEN
         result := FALSE;
         RETURN (result);
      END_IF;
      k := knot_mult[1];
      IF (k < 1) OR (k > degree + 1) THEN
         result := FALSE;
         RETURN (result);
      END_IF;
      REPEAT i := 2 TO up_knots;
         IF (knot_mult[i] < 1) OR (knots[i] <= knots[(i - 1)]) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
         k := knot_mult[i];
         IF (i < up_knots) AND (k > degree) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
         IF (i = up_knots) AND (k > degree + 1) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION cross_product
      (arg1 : direction;
       arg2 : direction ) : vector;
   LOCAL
      mag : REAL;
      res : direction;
      v1 : LIST [3:3] OF REAL;
      v2 : LIST [3:3] OF REAL;
      result : vector;
   END_LOCAL;
      IF (NOT EXISTS(arg1) OR (arg1.dim = 2)) OR (NOT EXISTS(arg2) OR (arg2.dim = 2)) THEN
         RETURN (?);
      ELSE
         BEGIN
            v1 := normalise(arg1).direction_ratios;
            v2 := normalise(arg2).direction_ratios;
            res := dummy_gri || direction([ (v1[2] * v2[3] - v1[3] * v2[2]), (v1[3] * v2[1] - v1[1] * v2[3]), (v1[1] * v2[2] - v1[2] * v2[1]) ]);
            mag := 0.00000;
            REPEAT i := 1 TO 3;
               mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
            END_REPEAT;
            IF mag > 0.00000 THEN
               result := dummy_gri || vector(res, sqrt(mag));
            ELSE
               result := dummy_gri || vector(arg1, 0.00000);
            END_IF;
            RETURN (result);
         END;
      END_IF;
   END_FUNCTION;



   FUNCTION curve_weights_positive
      (b : rational_b_spline_curve ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 0 TO b.upper_index_on_control_points;
         IF b.weights[i] <= 0.00000 THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION derive_dimensional_exponents
      (x : unit ) : dimensional_exponents;
   LOCAL
      result : dimensional_exponents := dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000);
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
         REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
            result.length_exponent := result.length_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent;
            result.mass_exponent := result.mass_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent;
            result.time_exponent := result.time_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent;
            result.electric_current_exponent := result.electric_current_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent;
            result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent;
            result.amount_of_substance_exponent := result.amount_of_substance_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent;
            result.luminous_intensity_exponent := result.luminous_intensity_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent;
         END_REPEAT;
      ELSE
         result := x.dimensions;
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION dimension_of
      (item : geometric_representation_item ) : dimension_count;
   LOCAL
      x : SET OF representation;
      y : representation_context;
      dim : dimension_count;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
         dim := SIZEOF(item\cartesian_point.coordinates);
         RETURN (dim);
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
         dim := SIZEOF(item\direction.direction_ratios);
         RETURN (dim);
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(item) THEN
         dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
         RETURN (dim);
      END_IF;
      x := using_representations(item);
      y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
      RETURN (dim);
   END_FUNCTION;



   FUNCTION dimensions_for_si_unit
      (n : si_unit_name ) : dimensional_exponents;
      CASE n OF
         metre :
               RETURN (dimensional_exponents(1.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         gram :
               RETURN (dimensional_exponents(0.00000, 1.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         second :
               RETURN (dimensional_exponents(0.00000, 0.00000, 1.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         ampere :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 1.00000, 0.00000, 0.00000, 0.00000));
         kelvin :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 1.00000, 0.00000, 0.00000));
         mole :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 1.00000, 0.00000));
         candela :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 1.00000));
         radian :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         steradian :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         hertz :
               RETURN (dimensional_exponents(0.00000, 0.00000, -1.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         newton :
               RETURN (dimensional_exponents(1.00000, 1.00000, -2.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         pascal :
               RETURN (dimensional_exponents(-1.00000, 1.00000, -2.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         joule :
               RETURN (dimensional_exponents(2.00000, 1.00000, -2.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         watt :
               RETURN (dimensional_exponents(2.00000, 1.00000, -3.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         coulomb :
               RETURN (dimensional_exponents(0.00000, 0.00000, 1.00000, 1.00000, 0.00000, 0.00000, 0.00000));
         volt :
               RETURN (dimensional_exponents(2.00000, 1.00000, -3.00000, -1.00000, 0.00000, 0.00000, 0.00000));
         farad :
               RETURN (dimensional_exponents(-2.00000, -1.00000, 4.00000, 1.00000, 0.00000, 0.00000, 0.00000));
         ohm :
               RETURN (dimensional_exponents(2.00000, 1.00000, -3.00000, -2.00000, 0.00000, 0.00000, 0.00000));
         siemens :
               RETURN (dimensional_exponents(-2.00000, -1.00000, 3.00000, 2.00000, 0.00000, 0.00000, 0.00000));
         weber :
               RETURN (dimensional_exponents(2.00000, 1.00000, -2.00000, -1.00000, 0.00000, 0.00000, 0.00000));
         tesla :
               RETURN (dimensional_exponents(0.00000, 1.00000, -2.00000, -1.00000, 0.00000, 0.00000, 0.00000));
         henry :
               RETURN (dimensional_exponents(2.00000, 1.00000, -2.00000, -2.00000, 0.00000, 0.00000, 0.00000));
         degree_Celsius :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 1.00000, 0.00000, 0.00000));
         lumen :
               RETURN (dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 1.00000));
         lux :
               RETURN (dimensional_exponents(-2.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 1.00000));
         becquerel :
               RETURN (dimensional_exponents(0.00000, 0.00000, -1.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         gray :
               RETURN (dimensional_exponents(2.00000, 0.00000, -2.00000, 0.00000, 0.00000, 0.00000, 0.00000));
         sievert :
               RETURN (dimensional_exponents(2.00000, 0.00000, -2.00000, 0.00000, 0.00000, 0.00000, 0.00000));
      OTHERWISE :
            RETURN (?);
      END_CASE;
   END_FUNCTION;



   FUNCTION dot_product
      (arg1 : direction;
       arg2 : direction ) : REAL;
   LOCAL
      scalar : REAL;
      vec1 : direction;
      vec2 : direction;
      ndim : INTEGER;
   END_LOCAL;
      IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) THEN
         scalar := ?;
      ELSE
         IF arg1.dim <> arg2.dim THEN
            scalar := ?;
         ELSE
            BEGIN
               vec1 := normalise(arg1);
               vec2 := normalise(arg2);
               ndim := arg1.dim;
               scalar := 0.00000;
               REPEAT i := 1 TO ndim;
                  scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
               END_REPEAT;
            END;
         END_IF;
      END_IF;
      RETURN (scalar);
   END_FUNCTION;



   FUNCTION edge_reversed
      (an_edge : edge ) : oriented_edge;
   LOCAL
      the_reverse : oriented_edge;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
         the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start) || oriented_edge(an_edge\oriented_edge.edge_element, NOT an_edge\oriented_edge.orientation);
      ELSE
         the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start) || oriented_edge(an_edge, FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION face_bound_reversed
      (a_face_bound : face_bound ) : face_bound;
   LOCAL
      the_reverse : face_bound;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound) THEN
         the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound, NOT a_face_bound\face_bound.orientation) || face_outer_bound();
      ELSE
         the_reverse := dummy_tri || face_bound(a_face_bound.bound, NOT a_face_bound.orientation);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION face_reversed
      (a_face : face ) : oriented_face;
   LOCAL
      the_reverse : oriented_face;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_FACE' IN TYPEOF(a_face) THEN
         the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face\oriented_face.face_element, NOT a_face\oriented_face.orientation);
      ELSE
         the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face, FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION first_proj_axis
      (z_axis : direction;
       arg : direction ) : direction;
   LOCAL
      x_axis : direction;
      v : direction;
      z : direction;
      x_vec : vector;
   END_LOCAL;
      IF NOT EXISTS(z_axis) THEN
         RETURN (?);
      ELSE
         z := normalise(z_axis);
         IF NOT EXISTS(arg) THEN
            IF (z.direction_ratios <> [ 1.00000, 0.00000, 0.00000 ]) AND (z.direction_ratios <> [ -1.00000, 0.00000, 0.00000 ]) THEN
               v := dummy_gri || direction([ 1.00000, 0.00000, 0.00000 ]);
            ELSE
               v := dummy_gri || direction([ 0.00000, 1.00000, 0.00000 ]);
            END_IF;
         ELSE
            IF arg.dim <> 3 THEN
               RETURN (?);
            END_IF;
            IF cross_product(arg, z).magnitude = 0.00000 THEN
               RETURN (?);
            ELSE
               v := normalise(arg);
            END_IF;
         END_IF;
         x_vec := scalar_times_vector(dot_product(v, z), z);
         x_axis := vector_difference(v, x_vec).orientation;
         x_axis := normalise(x_axis);
      END_IF;
      RETURN (x_axis);
   END_FUNCTION;



   FUNCTION get_basis_surface
      (c : curve_on_surface ) : SET [0:2] OF surface;
   LOCAL
      surfs : SET [0:2] OF surface;
      n : INTEGER;
   END_LOCAL;
      surfs := [];
      IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(c) THEN
         surfs := [ c\pcurve.basis_surface ];
      ELSE
         IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN TYPEOF(c) THEN
            n := SIZEOF(c\surface_curve.associated_geometry);
            REPEAT i := 1 TO n;
               surfs := surfs + associated_surface(c\surface_curve.associated_geometry[i]);
            END_REPEAT;
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) THEN
         n := SIZEOF(c\composite_curve.segments);
         surfs := get_basis_surface(c\composite_curve.segments[1].parent_curve);
         IF n > 1 THEN
            REPEAT i := 2 TO n;
               surfs := surfs * get_basis_surface(c\composite_curve.segments[i].parent_curve);
            END_REPEAT;
         END_IF;
      END_IF;
      RETURN (surfs);
   END_FUNCTION;



   FUNCTION get_description_value
      (obj : description_attribute_select ) : text;
   LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj, 'SHIP_ARRANGEMENT_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
   END_LOCAL;
      IF SIZEOF(description_bag) = 1 THEN
         RETURN (description_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_id_value
      (obj : id_attribute_select ) : identifier;
   LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
   END_LOCAL;
      IF SIZEOF(id_bag) = 1 THEN
         RETURN (id_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_name_value
      (obj : name_attribute_select ) : label;
   LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj, 'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM');
   END_LOCAL;
      IF SIZEOF(name_bag) = 1 THEN
         RETURN (name_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_role
      (obj : role_select ) : object_role;
   LOCAL
      role_bag : BAG OF role_association := USEDIN(obj, 'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE');
   END_LOCAL;
      IF SIZEOF(role_bag) = 1 THEN
         RETURN (role_bag[1].role);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION item_in_context
      (item : representation_item;
       cntxt : representation_context ) : BOOLEAN;
   LOCAL
      y : BAG OF representation_item;
   END_LOCAL;
      IF SIZEOF(USEDIN(item, 'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION.ITEMS') * cntxt.representations_in_context) > 0 THEN
         RETURN (TRUE);
      ELSE
         y := QUERY (z <* USEDIN(item, '')| 'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
         IF SIZEOF(y) > 0 THEN
            REPEAT i := 1 TO HIINDEX(y);
               IF item_in_context(y[i], cntxt) THEN
                  RETURN (TRUE);
               END_IF;
            END_REPEAT;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION leap_year
      (year : year_number ) : BOOLEAN;
      IF (year MOD 4 = 0) AND (year MOD 100 <> 0) OR (year MOD 400 = 0) THEN
         RETURN (TRUE);
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION list_face_loops
      (f : face ) : LIST [0:?] OF loop;
   LOCAL
      loops : LIST [0:?] OF loop := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(f.bounds);
         loops := loops + f.bounds[i].bound;
      END_REPEAT;
      RETURN (loops);
   END_FUNCTION;



   FUNCTION list_of_topology_reversed
      (a_list : list_of_reversible_topology_item ) : list_of_reversible_topology_item;
   LOCAL
      the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
      the_reverse := [];
      REPEAT i := 1 TO SIZEOF(a_list);
         the_reverse := topology_reversed(a_list[i]) + the_reverse;
      END_REPEAT;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION list_to_array
      (lis : LIST [0:?] OF GENERIC : T;
       low : INTEGER;
       u : INTEGER ) : ARRAY [low:u] OF GENERIC : T;
   LOCAL
      n : INTEGER;
      res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      n := SIZEOF(lis);
      IF n <> u - low + 1 THEN
         RETURN (?);
      ELSE
         res := [ lis[1] ];
         REPEAT i := 2 TO n;
            res[(low + i - 1)] := lis[i];
         END_REPEAT;
         RETURN (res);
      END_IF;
   END_FUNCTION;



   FUNCTION list_to_set
      (l : LIST [0:?] OF GENERIC : T ) : SET OF GENERIC : T;
   LOCAL
      s : SET OF GENERIC : T := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(l);
         s := s + l[i];
      END_REPEAT;
      RETURN (s);
   END_FUNCTION;



   FUNCTION make_array_of_array
      (lis : LIST [1:?] OF LIST [1:?] OF GENERIC : T;
       low1 : INTEGER;
       u1 : INTEGER;
       low2 : INTEGER;
       u2 : INTEGER ) : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;
      IF u1 - low1 + 1 <> SIZEOF(lis) THEN
         RETURN (?);
      END_IF;
      IF u2 - low2 + 1 <> SIZEOF(lis[1]) THEN
         RETURN (?);
      END_IF;
      res := [ list_to_array(lis[1], low2, u2) ];
      REPEAT i := 2 TO HIINDEX(lis);
         IF u2 - low2 + 1 <> SIZEOF(lis[i]) THEN
            RETURN (?);
         END_IF;
         res[(low1 + i - 1)] := list_to_array(lis[i], low2, u2);
      END_REPEAT;
      RETURN (res);
   END_FUNCTION;



   FUNCTION mixed_loop_type_set
      (l : SET [0:?] OF loop ) : LOGICAL;
   LOCAL
      poly_loop_type : LOGICAL;
   END_LOCAL;
      IF SIZEOF(l) <= 1 THEN
         RETURN (FALSE);
      END_IF;
      poly_loop_type := 'SHIP_ARRANGEMENT_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]);
      REPEAT i := 2 TO SIZEOF(l);
         IF ('SHIP_ARRANGEMENT_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type THEN
            RETURN (TRUE);
         END_IF;
      END_REPEAT;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION nmsf_curve_check
      (cv : representation_item ) : BOOLEAN;
      IF SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE', 'SHIP_ARRANGEMENT_SCHEMA.CONIC', 'SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA', 'SHIP_ARRANGEMENT_SCHEMA.LINE', 'SHIP_ARRANGEMENT_SCHEMA.OFFSET_CURVE_3D' ] * TYPEOF(cv)) > 1 THEN
         RETURN (FALSE);
      ELSE
         IF ('SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN) THEN
            RETURN (TRUE);
         ELSE
            IF SIZEOF([ 'SHIP_ARRANGEMENT_SCHEMA.CONIC', 'SHIP_ARRANGEMENT_SCHEMA.LINE' ] * TYPEOF(cv)) = 1 THEN
               RETURN (TRUE);
            ELSE
               IF 'SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
                  RETURN (nmsf_curve_check(cv\curve_replica.parent_curve));
               ELSE
                  IF (('SHIP_ARRANGEMENT_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN))) AND NOT ('SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)) THEN
                     RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve));
                  ELSE
                     IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(cv) THEN
                        RETURN (nmsf_curve_check(cv\pcurve.reference_to_curve\representation.items[1]) AND nmsf_surface_check(cv\pcurve.basis_surface));
                     ELSE
                        IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv) THEN
                           IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                              REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                                 IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                    IF NOT nmsf_surface_check(cv\surface_curve.associated_geometry[i]) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                 ELSE
                                    IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                       IF NOT nmsf_curve_check(cv\surface_curve.associated_geometry[i]) THEN
                                          RETURN (FALSE);
                                       END_IF;
                                    END_IF;
                                 END_IF;
                              END_REPEAT;
                              RETURN (TRUE);
                           END_IF;
                        ELSE
                           IF 'SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN
                              IF SIZEOF(cv\polyline.points) >= 3 THEN
                                 RETURN (TRUE);
                              END_IF;
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION nmsf_surface_check
      (surf : surface ) : BOOLEAN;
      IF 'SHIP_ARRANGEMENT_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
         RETURN (TRUE);
      ELSE
         IF 'SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE' IN TYPEOF(surf) THEN
            RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));
         ELSE
            IF ('SHIP_ARRANGEMENT_SCHEMA.OFFSET_SURFACE' IN TYPEOF(surf)) AND (surf\offset_surface.self_intersect = FALSE) OR (surf\offset_surface.self_intersect = UNKNOWN) THEN
               RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
            ELSE
               IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf) THEN
                  RETURN (nmsf_surface_check(surf\surface_replica.parent_surface));
               ELSE
                  IF ('SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND (surf\b_spline_surface.self_intersect = FALSE) OR (surf\b_spline_surface.self_intersect = UNKNOWN) THEN
                     RETURN (TRUE);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION normalise
      (arg : vector_or_direction ) : vector_or_direction;
   LOCAL
      ndim : INTEGER;
      v : direction;
      result : vector_or_direction;
      vec : vector;
      mag : REAL;
   END_LOCAL;
      IF NOT EXISTS(arg) THEN
         result := ?;
      ELSE
         ndim := arg.dim;
         IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
            BEGIN
               v := dummy_gri || direction(arg.orientation.direction_ratios);
               IF arg.magnitude = 0.00000 THEN
                  RETURN (?);
               ELSE
                  vec := dummy_gri || vector(v, 1.00000);
               END_IF;
            END;
         ELSE
            v := dummy_gri || direction(arg.direction_ratios);
         END_IF;
         mag := 0.00000;
         REPEAT i := 1 TO ndim;
            mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
         END_REPEAT;
         IF mag > 0.00000 THEN
            mag := sqrt(mag);
            REPEAT i := 1 TO ndim;
               v.direction_ratios[i] := v.direction_ratios[i] / mag;
            END_REPEAT;
            IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
               vec.orientation := v;
               result := vec;
            ELSE
               result := v;
            END_IF;
         ELSE
            RETURN (?);
         END_IF;
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION open_shell_reversed
      (a_shell : open_shell ) : oriented_open_shell;
   LOCAL
      the_reverse : oriented_open_shell;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) THEN
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() || oriented_open_shell(a_shell\oriented_open_shell.open_shell_element, NOT a_shell\oriented_open_shell.orientation);
      ELSE
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() || oriented_open_shell(a_shell, FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION orthogonal_complement
      (vec : direction ) : direction;
   LOCAL
      result : direction;
   END_LOCAL;
      IF (vec.dim <> 2) OR NOT EXISTS(vec) THEN
         RETURN (?);
      ELSE
         result := dummy_gri || direction([ -vec.direction_ratios[2], vec.direction_ratios[1] ]);
         RETURN (result);
      END_IF;
   END_FUNCTION;



   FUNCTION path_head_to_tail
      (a_path : path ) : LOGICAL;
   LOCAL
      n : INTEGER;
      p : LOGICAL := TRUE;
   END_LOCAL;
      n := SIZEOF(a_path.edge_list);
      REPEAT i := 2 TO n;
         p := p AND (a_path.edge_list[(i - 1)].edge_end :=: a_path.edge_list[i].edge_start);
      END_REPEAT;
      RETURN (p);
   END_FUNCTION;



   FUNCTION path_reversed
      (a_path : path ) : oriented_path;
   LOCAL
      the_reverse : oriented_path;
   END_LOCAL;
      IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_PATH' IN TYPEOF(a_path) THEN
         the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path\oriented_path.path_element, NOT a_path\oriented_path.orientation);
      ELSE
         the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path, FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION scalar_times_vector
      (scalar : REAL;
       vec : vector_or_direction ) : vector;
   LOCAL
      v : direction;
      mag : REAL;
      result : vector;
   END_LOCAL;
      IF NOT EXISTS(scalar) OR NOT EXISTS(vec) THEN
         RETURN (?);
      ELSE
         IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(vec) THEN
            v := dummy_gri || direction(vec.orientation.direction_ratios);
            mag := scalar * vec.magnitude;
         ELSE
            v := dummy_gri || direction(vec.direction_ratios);
            mag := scalar;
         END_IF;
         IF mag < 0.00000 THEN
            REPEAT i := 1 TO SIZEOF(v.direction_ratios);
               v.direction_ratios[i] := -v.direction_ratios[i];
            END_REPEAT;
            mag := -mag;
         END_IF;
         result := dummy_gri || vector(normalise(v), mag);
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION second_proj_axis
      (z_axis : direction;
       x_axis : direction;
       arg : direction ) : direction;
   LOCAL
      y_axis : vector;
      v : direction;
      temp : vector;
   END_LOCAL;
      IF NOT EXISTS(arg) THEN
         v := dummy_gri || direction([ 0.00000, 1.00000, 0.00000 ]);
      ELSE
         v := arg;
      END_IF;
      temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
      y_axis := vector_difference(v, temp);
      temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
      y_axis := vector_difference(y_axis, temp);
      y_axis := normalise(y_axis);
      RETURN (y_axis.orientation);
   END_FUNCTION;



   FUNCTION set_of_topology_reversed
      (a_set : set_of_reversible_topology_item ) : set_of_reversible_topology_item;
   LOCAL
      the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
      the_reverse := [];
      REPEAT i := 1 TO SIZEOF(a_set);
         the_reverse := the_reverse + topology_reversed(a_set[i]);
      END_REPEAT;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION shell_reversed
      (a_shell : shell ) : shell;
      IF 'SHIP_ARRANGEMENT_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell) THEN
         RETURN (open_shell_reversed(a_shell));
      ELSE
         IF 'SHIP_ARRANGEMENT_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
            RETURN (closed_shell_reversed(a_shell));
         ELSE
            RETURN (?);
         END_IF;
      END_IF;
   END_FUNCTION;



   FUNCTION surface_weights_positive
      (b : rational_b_spline_surface ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 0 TO b.u_upper;
         REPEAT j := 0 TO b.v_upper;
            IF b.weights[i][j] <= 0.00000 THEN
               result := FALSE;
               RETURN (result);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION topology_reversed
      (an_item : reversible_topology ) : reversible_topology;
      IF 'SHIP_ARRANGEMENT_SCHEMA.EDGE' IN TYPEOF(an_item) THEN
         RETURN (edge_reversed(an_item));
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.PATH' IN TYPEOF(an_item) THEN
         RETURN (path_reversed(an_item));
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.FACE_BOUND' IN TYPEOF(an_item) THEN
         RETURN (face_bound_reversed(an_item));
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.FACE' IN TYPEOF(an_item) THEN
         RETURN (face_reversed(an_item));
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.SHELL' IN TYPEOF(an_item) THEN
         RETURN (shell_reversed(an_item));
      END_IF;
      IF 'SET' IN TYPEOF(an_item) THEN
         RETURN (set_of_topology_reversed(an_item));
      END_IF;
      IF 'LIST' IN TYPEOF(an_item) THEN
         RETURN (list_of_topology_reversed(an_item));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION using_items
      (item : founded_item_select;
       checked_items : SET OF founded_item_select ) : SET OF founded_item_select;
   LOCAL
      new_check_items : SET OF founded_item_select;
      result_items : SET OF founded_item_select;
      next_items : SET OF founded_item_select;
   END_LOCAL;
      result_items := [];
      new_check_items := checked_items + item;
      next_items := QUERY (z <* bag_to_set(USEDIN(item, ''))| ('SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR ('SHIP_ARRANGEMENT_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z)));
      IF SIZEOF(next_items) > 0 THEN
         REPEAT i := 1 TO HIINDEX(next_items);
            IF NOT (next_items[i] IN new_check_items) THEN
               result_items := result_items + next_items[i] + using_items(next_items[i], new_check_items);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (result_items);
   END_FUNCTION;



   FUNCTION using_representations
      (item : founded_item_select ) : SET OF representation;
   LOCAL
      results : SET OF representation;
      result_bag : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
   END_LOCAL;
      results := [];
      result_bag := USEDIN(item, 'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
         REPEAT i := 1 TO HIINDEX(result_bag);
            results := results + result_bag[i];
         END_REPEAT;
      END_IF;
      intermediate_items := using_items(item, []);
      IF SIZEOF(intermediate_items) > 0 THEN
         REPEAT i := 1 TO HIINDEX(intermediate_items);
            result_bag := USEDIN(intermediate_items[i], 'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION.ITEMS');
            IF SIZEOF(result_bag) > 0 THEN
               REPEAT j := 1 TO HIINDEX(result_bag);
                  results := results + result_bag[j];
               END_REPEAT;
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (results);
   END_FUNCTION;



   FUNCTION valid_calendar_date
      (date : calendar_date ) : LOGICAL;
      CASE date.month_component OF
         1 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         2 :
               BEGIN
                  IF leap_year(date.year_component) THEN
                     RETURN ((1 <= date.day_component) AND (date.day_component <= 29));
                  ELSE
                     RETURN ((1 <= date.day_component) AND (date.day_component <= 28));
                  END_IF;
               END;
         3 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         4 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         5 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         6 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         7 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         8 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         9 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         10 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         11 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         12 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
      END_CASE;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_measure_value
      (m : measure_value ) : BOOLEAN;
      IF 'REAL' IN TYPEOF(m) THEN
         RETURN (m > 0.00000);
      ELSE
         IF 'INTEGER' IN TYPEOF(m) THEN
            RETURN (m > 0);
         ELSE
            RETURN (TRUE);
         END_IF;
      END_IF;
   END_FUNCTION;



   FUNCTION valid_time
      (time : local_time ) : BOOLEAN;
      IF EXISTS(time.second_component) THEN
         RETURN (EXISTS(time.minute_component));
      ELSE
         RETURN (TRUE);
      END_IF;
   END_FUNCTION;



   FUNCTION valid_units
      (m : measure_with_unit ) : BOOLEAN;
      IF 'SHIP_ARRANGEMENT_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 1.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 1.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 1.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 1.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 1.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 1.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(3.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'SHIP_ARRANGEMENT_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION vector_difference
      (arg1 : vector_or_direction;
       arg2 : vector_or_direction ) : vector;
   LOCAL
      result : vector;
      res : direction;
      vec1 : direction;
      vec2 : direction;
      mag : REAL;
      mag1 : REAL;
      mag2 : REAL;
      ndim : INTEGER;
   END_LOCAL;
      IF (NOT EXISTS(arg1) OR NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim) THEN
         RETURN (?);
      ELSE
         BEGIN
            IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
               mag1 := arg1.magnitude;
               vec1 := arg1.orientation;
            ELSE
               mag1 := 1.00000;
               vec1 := arg1;
            END_IF;
            IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
               mag2 := arg2.magnitude;
               vec2 := arg2.orientation;
            ELSE
               mag2 := 1.00000;
               vec2 := arg2;
            END_IF;
            vec1 := normalise(vec1);
            vec2 := normalise(vec2);
            ndim := SIZEOF(vec1.direction_ratios);
            mag := 0.00000;
            res := dummy_gri || direction(vec1.direction_ratios);
            REPEAT i := 1 TO ndim;
               res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] + mag2 * vec2.direction_ratios[i];
               mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
            END_REPEAT;
            IF mag > 0.00000 THEN
               result := dummy_gri || vector(res, sqrt(mag));
            ELSE
               result := dummy_gri || vector(vec1, 0.00000);
            END_IF;
         END;
      END_IF;
      RETURN (result);
   END_FUNCTION;


(* ***********************************
Rules in the schema Ship_arrangement_schema
*********************************** *)


   RULE action_request_solution_connected_to_action FOR (action_request_solution, action );
   LOCAL
      t1_set : SET OF action_request_solution := [];
      t2_set : SET OF action := [];
      set_3 : SET OF action_method := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action_request_solution| VALUE_IN(WHICH_CLASS(a), 'change plan'));
      t2_set := QUERY (b <* action| VALUE_IN(WHICH_CLASS(b), 'change'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         set_3 := [];
         REPEAT j := 1 TO HIINDEX(t2_set);
            set_3 := set_3 + [ t2_set[j].chosen_method ];
         END_REPEAT;
         violate := VALUE_IN(set_3, t1_set[i].method);
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE action_request_solution_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF action_request_solution := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'change plan' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE action_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF action := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'change', 'versionable object change event', 'check' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE alternative_version_relationship_has_mandatory_description FOR (identification_assignment_relationship );
   LOCAL
      t1_set : SET OF identification_assignment_relationship := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* identification_assignment_relationship| VALUE_IN(WHICH_CLASS(i), 'alternative version relationship'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE alternative_version_relationship_has_unique_versions FOR (identification_assignment_relationship );
   LOCAL
      t1_set : SET OF identification_assignment_relationship := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* identification_assignment_relationship| VALUE_IN(WHICH_CLASS(a), 'alternative version relationship'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         violate := t1_set[i].relating_identification_assignment.assigned_id = t1_set[i].related_identification_assignment.assigned_id;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE alternative_version_relationship_versionable_object FOR (applied_identification_assignment, identification_assignment_relationship );
   LOCAL
      violate : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;
         IF (SIZEOF(USEDIN(applied_identification_assignment[i], 'SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATING_IDENTIFICATION_ASSIGNMENT')) > 0) OR (SIZEOF(USEDIN(applied_identification_assignment[i], 'SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) > 0) THEN
            REPEAT j := 1 TO HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
               violate := NOT VALUE_IN(WHICH_CLASS(applied_identification_assignment[i].items[j]), 'versionable object');
            END_REPEAT;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE applied_approval_assignment_has_exactly_one_elements FOR (object_role, applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ass_inst <* applied_approval_assignment| NOT ((ass_inst.role.NAME = 'subject') AND (SIZEOF(ass_inst.items) = 1)))) = 0;
   END_RULE;



   RULE applied_group_assignment_has_at_least_one_elements FOR (object_role, applied_group_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ass_inst <* applied_group_assignment| NOT (((ass_inst.role.NAME = 'approvals') AND (SIZEOF(ass_inst.items) >= 1)) AND (SIZEOF(QUERY (item <* ass_inst.items| NOT ('SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(item)))) = 0)))) = 0;
   END_RULE;



   RULE approval_event_with_approval_date_time FOR (approval );
   LOCAL
      t1_set : SET OF approval := [];
      t2_set : SET OF approval_date_time := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* approval| VALUE_IN(WHICH_CLASS(i), 'approval event'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPROVAL_DATE_TIME.' + 'DATED_APPROVAL'));
         violate := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE approval_event_with_approval_person_organization FOR (approval );
   LOCAL
      t1_set : SET OF approval := [];
      t2_set : SET OF approval_person_organization := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* approval| VALUE_IN(WHICH_CLASS(i), 'approval event'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPROVAL_PERSON_ORGANIZATION.' + 'AUTHORIZED_APPROVAL'));
         violate := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE approval_history_approves_same_definition FOR (applied_group_assignment, applied_approval_assignment );
   LOCAL
      t2_set : SET OF applied_group_assignment := [];
      t3_set : SET OF approval := [];
      t4_set : SET OF group_item := [];
      t5_set : SET OF applied_approval_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t2_set := QUERY (a <* applied_group_assignment| VALUE_IN(WHICH_CLASS(a.ASSIGNED_GROUP), 'approval history'));
      t3_set := QUERY (b <* t2_set[1].items| 'SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(b));
      t4_set := QUERY (b <* t2_set[1].items| VALUE_IN(WHICH_CLASS(b), 'definition'));
      violate := NOT (SIZEOF(t4_set) = 1);
      REPEAT i := 1 TO HIINDEX(t3_set) WHILE NOT violate;
         t5_set := QUERY (a <* applied_approval_assignment| (a.ASSIGNED_APPROVAL = t3_set[i]) AND NOT VALUE_IN(a.items, t4_set[1]));
         violate := SIZEOF(t5_set) > 0;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
      wr2:
         SIZEOF(t4_set) = 1;
   END_RULE;



   RULE approval_history_has_at_least_one_member FOR (group, applied_group_assignment );
   LOCAL
      t1_set : SET OF group := [];
      t2_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* group| VALUE_IN(WHICH_CLASS(i), 'approval history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         t2_set := QUERY (a <* applied_group_assignment| a.ASSIGNED_GROUP = t1_set[i]);
         violate := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE approvals_references_approval_history FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'approval history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| NOT ((b.ASSIGNED_GROUP = t1_set[i]) AND (b.role.NAME = 'approvals')));
         violate := SIZEOF(a_set) > 0;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE author_for_change_plan FOR (applied_person_and_organization_assignment, action_request_solution );
   LOCAL
      t1_set : SET OF action_request_solution := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action_request_solution| VALUE_IN(WHICH_CLASS(a), 'change plan'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'author'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE author_for_change_realization FOR (applied_person_and_organization_assignment, executed_action );
   LOCAL
      t1_set : SET OF executed_action := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* executed_action| VALUE_IN(WHICH_CLASS(a), 'change realization'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'author'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE author_for_change_request FOR (applied_person_and_organization_assignment, versioned_action_request );
   LOCAL
      t1_set : SET OF versioned_action_request := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* versioned_action_request| VALUE_IN(WHICH_CLASS(a), 'change request'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'author'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_by_for_check FOR (applied_person_and_organization_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'check'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused by'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_by_for_envisaged_version_creation FOR (applied_person_and_organization_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'envisaged version creation'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused by'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_by_for_version_creation FOR (applied_person_and_organization_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'version creation'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused by'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_by_for_version_deletion FOR (applied_person_and_organization_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'version deletion'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused by'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_by_for_version_modification FOR (applied_person_and_organization_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'version modification'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused by'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_when_for_check FOR (applied_date_and_time_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'check'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused when'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_when_for_envisaged_version_creation FOR (applied_date_and_time_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'envisaged version creation'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused when'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_when_for_version_creation FOR (applied_date_and_time_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'version creation'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused when'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_when_for_version_deletion FOR (applied_date_and_time_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'version deletion'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused when'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE caused_when_for_version_modification FOR (applied_date_and_time_assignment, action );
   LOCAL
      t1_set : SET OF action := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action| VALUE_IN(WHICH_CLASS(a), 'version modification'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'caused when'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE centre_location_compound_representation_has_specified_name FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF compound_representation_item := [];
      t2_set : SET OF representation_item := [];
      arg_list : LIST OF STRING := [ 'longitudinal location', 'transversal location', 'vertical location' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'centre location');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            t2_set := t1_set[i].item_element;
            violation := SIZEOF(QUERY (items <* t2_set| (items.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE change_impact_with_versionable_object_change_event FOR (applied_action_request_assignment );
   LOCAL
      t1_set : SET OF applied_action_request_assignment := [];
      a_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (b <* applied_action_request_assignment| b.role.NAME = 'change impact');
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* t1_set[i].items| ('SHIP_ARRANGEMENT_SCHEMA.ACTION' IN TYPEOF(b)) AND VALUE_IN(WHICH_CLASS(b), 'versionable object change event'));
         violate := SIZEOF(a_set) = 0;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE change_plan_has_mandatory_attribute_description FOR (action_request_solution );
   LOCAL
      t1_set : SET OF action_request_solution := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action_request_solution| VALUE_IN(WHICH_CLASS(i), 'change plan'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE class_and_statutory_designation_has_properties FOR (property_definition_representation, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_list : LIST OF product_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_list : LIST OF property_definition := [];
      t4_list : LIST OF product_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class and statutory designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_list := t1_list + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      t2_set := QUERY (i <* property_definition_representation| i.NAME = 'class and statutory designation');
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_list := t3_list + t2_set[i].definition;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_list);
         t4_list := t4_list + t3_list[i].definition;
      END_REPEAT;
      violation := t1_list <> t4_list;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE class_notation_with_named_representation_items FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'class notations hull', 'class notations machinery' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class notation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) < 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE class_parameters_has_properties FOR (property_definition_representation, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : LIST OF product_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_set : LIST OF property_definition := [];
      t4_set : LIST OF product_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class parameters');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      t2_set := QUERY (i <* property_definition_representation| i.NAME = 'class parameters');
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + t2_set[i].definition;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE compatible_dimension FOR (cartesian_point, direction, representation_context, geometric_representation_context );
   WHERE
      WR1:
         SIZEOF(QUERY (x <* cartesian_point| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x, y) AND (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0))) = 0;
      WR2:
         SIZEOF(QUERY (x <* direction| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x, y) AND (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension))) > 0))) = 0;
   END_RULE;



   RULE date_time_for_change_plan FOR (applied_date_and_time_assignment, action_request_solution );
   LOCAL
      t1_set : SET OF action_request_solution := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action_request_solution| VALUE_IN(WHICH_CLASS(a), 'change plan'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'date time'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE date_time_for_change_realization FOR (applied_date_and_time_assignment, executed_action );
   LOCAL
      t1_set : SET OF executed_action := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* executed_action| VALUE_IN(WHICH_CLASS(a), 'change realization'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'date time'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE date_time_for_change_request FOR (applied_date_and_time_assignment, versioned_action_request );
   LOCAL
      t1_set : SET OF versioned_action_request := [];
      a_set : SET OF applied_date_and_time_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* versioned_action_request| VALUE_IN(WHICH_CLASS(a), 'change request'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_date_and_time_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'date time'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE document_has_at_least_one_references FOR (document );
   LOCAL
      t1_set : SET OF document := [];
      t2_set : SET OF document_representation_type := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* document| VALUE_IN(WHICH_CLASS(i), 'document'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.DOCUMENT_REPRESENTATION_TYPE.' + 'REPRESENTED_DOCUMENT'));
         violate := SIZEOF(t2_set) < 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE document_has_exactly_one_author FOR (document );
   LOCAL
      bag_1 : BAG OF applied_person_assignment := [];
      bag_2 : BAG OF applied_person_and_organization_assignment := [];
      bag_3 : BAG OF applied_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(document) WHILE NOT violate;
         bag_1 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_PERSON_ASSIGNMENT.ITEMS');
         bag_1 := QUERY (assign <* bag_1| assign.role.name = 'author');
         bag_2 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS');
         bag_2 := QUERY (assign <* bag_2| assign.role.name = 'author');
         bag_3 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS');
         bag_3 := QUERY (assign <* bag_3| assign.role.name = 'author');
         violate := NOT (SIZEOF(bag_1) + SIZEOF(bag_2) + SIZEOF(bag_3) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE document_reference_with_address_has_at_least_one_references FOR (document );
   LOCAL
      t1_set : SET OF document := [];
      t2_set : SET OF applied_external_identification_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* document| VALUE_IN(WHICH_CLASS(i), 'document reference with address'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         violate := SIZEOF(t2_set) < 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE envisaged_version_creation_has_mandatory_attribute_description FOR (action );
   LOCAL
      t1_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action| VALUE_IN(WHICH_CLASS(i), 'envisaged version creation'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE executed_action_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF executed_action := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'change realization' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE external_instance_reference_has_same_identifier FOR (applied_external_identification_assignment );
   LOCAL
      violation : LOGICAL := FALSE;
      extref_set : SET OF applied_external_identification_assignment := [];
      aia_set : SET OF applied_identification_assignment := [];
   END_LOCAL;
      extref_set := QUERY (i <* applied_external_identification_assignment| i.role.NAME = 'external instance reference');
      REPEAT i := 1 TO HIINDEX(extref_set) BY 1 WHILE NOT violation;
         aia_set := bag_to_set(USEDIN(extref_set[i].items[1], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         violation := NOT (aia_set[1].assigned_id = extref_set[i].assigned_id);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE floating_position_compound_representation_with_name FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF compound_representation_item := [];
      t2_set : SET OF representation_item := [];
      arg_list : LIST OF STRING := [ 'moulded form displacement', 'draught at amidships', 'length of waterline', 'breadth of waterline', 'angle of trim', 'angle of heel' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'floating position');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            t2_set := t1_set[i].item_element;
            violation := SIZEOF(QUERY (items <* t2_set| (items.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE freeboard_characteristics_has_properties FOR (property_definition_representation, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : LIST OF product_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_set : LIST OF property_definition := [];
      t4_set : LIST OF product_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'freeboard characteristics');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      t2_set := QUERY (i <* property_definition_representation| i.NAME = 'freeboard characteristics');
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + t2_set[i].definition;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE global_axis_placement_has_properties FOR (property_definition_representation, group, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : LIST OF product_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_set : LIST OF property_definition := [];
      t4_set : LIST OF product_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'global axis placement');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      t2_set := QUERY (i <* property_definition_representation| i.NAME = 'global axis placement');
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + t2_set[i].definition;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE global_id_is_unique FOR (applied_identification_assignment );
   LOCAL
      set_1 : SET OF applied_identification_assignment := [];
      bag_2 : BAG OF STRING := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      set_1 := QUERY (i <* applied_identification_assignment| i.role.NAME = 'globally unambiguous identifier');
      REPEAT i := 1 TO HIINDEX(set_1);
         bag_2 := bag_2 + [ set_1[i].assigned_id ];
      END_REPEAT;
      violation := SIZEOF(QUERY (i <* set_1| (SIZEOF(i.items) = 1))) <> SIZEOF(set_1);
   WHERE
      WR1:
         VALUE_UNIQUE(bag_2);
      wr2:
         NOT violation;
   END_RULE;



   RULE identification_role_optional_attribute_description_required FOR (identification_role );
   WHERE
      WR1:
         SIZEOF(QUERY (i <* identification_role| (i.NAME = 'external reference') AND NOT EXISTS(i.description))) = 0;
   END_RULE;



   RULE initiator_for_change_request FOR (applied_person_and_organization_assignment, versioned_action_request );
   LOCAL
      t1_set : SET OF versioned_action_request := [];
      a_set : SET OF applied_person_and_organization_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* versioned_action_request| VALUE_IN(WHICH_CLASS(a), 'change request'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_person_and_organization_assignment| VALUE_IN(b.items, t1_set[i]) AND (b.role.NAME = 'initiator'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE lightship_definition_has_properties FOR (property_definition_representation, group, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : LIST OF product_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_set : LIST OF property_definition := [];
      t4_set : LIST OF product_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'lightship definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      t2_set := QUERY (i <* property_definition_representation| i.NAME = 'lightship definition parameters');
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + t2_set[i].definition;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE mandatory_entity_type_for_external_instance_reference FOR (external_source, external_source_relationship );
   LOCAL
      bag_1 : BAG OF external_source := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      bag_1 := QUERY (a <* external_source| a.description = 'schema name');
      REPEAT i := 1 TO SIZEOF(bag_1) WHILE NOT violate;
         violate := SIZEOF(QUERY (a <* external_source_relationship| (a.relating_source :=: bag_1[i]) AND (a.related_source.description = 'entity type'))) = 0;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE members_is_referenced_by_at_least_one_revision FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'revision'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP :=: t1_set[i]) AND (b.role.NAME = 'members'));
         violate := SIZEOF(a_set) < 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE no_approvals_except_in_approval_history FOR (approval );
   LOCAL
      t1_set : SET OF approval := [];
      t2_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* approval| VALUE_IN(WHICH_CLASS(a), 'approval event'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
         violate := SIZEOF(t2_set) = 0;
         REPEAT k := 1 TO HIINDEX(t2_set) WHILE NOT violate;
            violate := NOT VALUE_IN(WHICH_CLASS(t2_set[k].assigned_group), 'approval history');
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE principal_characteristics_has_properties FOR (property_definition_representation, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : LIST OF product_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_set : LIST OF property_definition := [];
      t4_set : LIST OF product_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'principal characteristics');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      t2_set := QUERY (i <* property_definition_representation| i.NAME = 'principal characteristics');
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + t2_set[i].definition;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_call_sign FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_identification_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'ship designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'call sign'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_certifying_organization FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'coating certification');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'certifying organization'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_class_notation FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class and statutory designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| ('class notation' IN WHICH_CLASS(t2_inst)))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_expiry_date FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_date_and_time_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'coating certification');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'expiry date'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_flag_state FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_identification_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'ship designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'flag state'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_loadline FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'freeboard characteristics');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| ('loadline' IN WHICH_CLASS(t2_inst)))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_managing_company FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'owner designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'managing company'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_ordering_company FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'owner designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'ordering company'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_owning_company FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'owner designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'owning company'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_port_of_registration FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_identification_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'ship designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'port of registration'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_regulation FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class and statutory designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| ('regulation' IN WHICH_CLASS(t2_inst)))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_for_shipyard FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'shipyard designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'shipyard'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_relationship_references_are_distinct FOR (product_definition_relationship );
   LOCAL
      cyclic_relationship : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(product_definition_relationship) WHILE NOT cyclic_relationship;
         cyclic_relationship := product_definition_relationship[i].related_product_definition :=: product_definition_relationship[i].relating_product_definition;
      END_REPEAT;
   WHERE
      WR1:
         NOT cyclic_relationship;
   END_RULE;



   RULE product_definition_relationship_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition_relationship := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'space arrangement relationship' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_shape_for_deck_zone_design FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition_shape := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'deck zone design definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'deck zone design parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_shape_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition_shape := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'design definition' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_with_date_freeboard_assigned FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_date_and_time_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'freeboard characteristics');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'date freeboard assigned'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_with_freeboard_assigned_by FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'freeboard characteristics');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'freeboard assigned by'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_definition_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'definition', 'definable object' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_related_product_category_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_related_product_category := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'shiptype' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE product_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'ship' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_class_bulk_load_requirement_definition FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class bulk load requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'class bulk load requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_class_compartment_requirement_definition FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class compartment requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'class compartment requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_class_deck_load_requirement_definition FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class deck load requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'class deck load requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_class_notation FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class notation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'class notation'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_class_society FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class notation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'class society'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_class_tank_requirement_definition FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class tank requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'class tank requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_compartment_design_requirement FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'compartment design requirement');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'compartment design requirement parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_compartment_function FOR (property_definition, property_definition_representation, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'compartment functional definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'compartment function parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_compensated_gross_tonnage FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'tonnage definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| ('compensated gross tonnage' IN WHICH_CLASS(t2_inst)))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_damage_stability_definition_requires_reference FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      c2_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF representation := [];
      t3_set : SET OF property_definition_representation := [];
      t4_set : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'damage stability definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      c2_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability table');
      REPEAT i := 1 TO HIINDEX(c2_a_set);
         REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
            t2_set := t2_set + c2_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_date_of_loading FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF applied_date_and_time_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'loading condition operating definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'date of loading'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_deck_zone_function FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'deck zone functional definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'deck zone function parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_gross_tonnage FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'tonnage definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| ('gross tonnage' IN WHICH_CLASS(t2_inst)))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_local_coordinate_system FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'local co ordinate system');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'local coordinate system'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_local_coordinate_system_with_position FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'local co ordinate system with position reference');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'local coordinate system with position reference'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_net_tonnage FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'tonnage definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| ('net tonnage' IN WHICH_CLASS(t2_inst)))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_stability_definition_requires_reference FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      c2_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF representation := [];
      t3_set : SET OF property_definition_representation := [];
      t4_set : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      c2_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability table');
      REPEAT i := 1 TO HIINDEX(c2_a_set);
         REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
            t2_set := t2_set + c2_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_tonnage_definition FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'tonnage definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'tonnage definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_for_zone_function FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'zone functional definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'zone function parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_has_references_with_name_loadline FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'loadline');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'loadline'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_representation_for_date_of_measurement FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition_representation := [];
      t2_set : SET OF applied_date_and_time_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'tonnage measurement');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'date of 	measurement'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_representation_for_gross_tonnage FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition_representation := [];
      t2_set : SET OF applied_date_and_time_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'gross tonnage');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'date of measurement'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_representation_for_net_tonnage FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition_representation := [];
      t2_set : SET OF applied_date_and_time_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'net tonnage');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'date of measurement'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'cargo bay definition', 'compartment functional definition', 'deck zone functional definition', 'design requirement', 'loading condition definition', 'local co ordinate system', 'spacing table', 'stability definition', 'tonnage definition', 'zone functional definition' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_with_lightship_weight_item FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'lightship weight item');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'lightship weight item'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE property_definition_with_weight_and_centre_of_gravity FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'weight and centre of gravity');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.name = 'weight and centre of gravity'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_absolute_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'position', 'orientation' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'absolute cargo position parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_adjacent_space_surface_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'surface area' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'adjacent space surface area parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_bulk_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'natural angle of repose', 'pollution code', 'required carriage temperature', 'type of', 'un type code' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'bulk cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_bulk_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'actual angle of repose', 'assignment context', 'cargo height', 'cargo identifier', 'trimmed' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'bulk cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_capacity_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'capacity level origin', 'capacity centre', 'capacity level', 'capacity trim angle', 'capacity heel angle', 'capacity volume', 'capacity context' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'capacity properties'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_cargo_compartment_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'design stowage density' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'cargo compartment property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_cargo_footprint FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'contact material', 'shape', 'transferred mass' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'cargo footprint'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_class_and_statutory_designation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'class number' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class and statutory designation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_class_bulk_load_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'ambient temperature', 'angle of repose', 'bulk cargo mass', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature', 'permeability', 'top of hatch' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class bulk load requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_class_compartment_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'ambient temperature', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class compartment requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_class_notation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'service area', 'approval required for oil cargo', 'approval required for loading unloading aground', 'approval required for unloading grabs' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class notation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_class_parameters FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'length class', 'length solas', 'scantlings draught', 'block coefficient class', 'design speed ahead', 'design speed astern' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_class_tank_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'ambient temperature', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature', 'overflow height', 'partial filling', 'pressure relief setting' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class tank requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'dry film thickness', 'number of coats', 'surface preparation' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_coating_level FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'lower extent', 'upper extent' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'coating level'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_abbreviated_name FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'name' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment abbreviated name'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_acceleration FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'acceleration g force' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment acceleration'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_access_authorization FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'authorization classification' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment access authorization'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_air_circulation_rate FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'air circulation rate' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment air circulation rate'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'assignment context', 'cargo identifier' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment coating'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_design_requirement FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'description', 'requirement type' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment design requirement parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'used for' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_group FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'tonnage volume' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment group parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_horizontal_cross_sectional_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'horizontal cross sectional area' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment horizontal cross sectional area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_illumination FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'illumination value' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment illumination'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_insulation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'insulation category' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment insulation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_noise_category FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'noise category' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment noise category'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_nuclear_classification FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'nuclear classification' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment nuclear classification'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_occupancy FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'occupancy' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment occupancy'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_safety_class FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'safety category' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment safety class'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_security_classification FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'security classification' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment security classification'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_stiffened_surface_area_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'stiffened surface area' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment stiffened surface area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_tightness FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'required bulkhead tightness' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment tightness'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_unstiffened_surface_area_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'unstiffened surface area' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment unstiffened surface area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_vertical_longitudinal_sectional_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'vertical 	longitudinal cross 	sectional area' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment vertical longitudinal sectional area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_vertical_transverse_sectional_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'vertical transverse cross 	sectional area' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment vertical transverse sectional area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_volume_permeability_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'permeability' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment volume permeability property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_volume_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'centre of volume', 'context', 'volume' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment volume property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compartment_ziplist_number FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'department ziplist number', 'division ziplist number' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment ziplist number'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_compensated_gross_tonnage FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'compensation factor', 'tonnage value' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compensated gross tonnage'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_corrosion_control_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'applicability', 'dry film thickness', 'number of coats', 'surface preparation', 'type of' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'corrosion control coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_corrosion_protection FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'cathodic protection' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'corrosion protection'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_damage_case FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'damage cause', 'relative damage position' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'damage case parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_damage_position FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'centre of damage', 'position accuracy' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'damage position parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_dangerous_goods_code FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'class', 'subsidiary risks' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'dangerous goods code parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_deck_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'assignment context', 'cargo identifier' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'deck cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_deck_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'used for' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'deck zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_dry_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'pollution code', 'un type code' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'dry cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_fire_safe_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'dry film thickness', 'low flame spread', 'nitro cellulose based', 'number of coats', 'surface preparation' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'fire safe coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_freeboard_characteristics FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'assigned code', 'freeboard' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'freeboard characteristics'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_gaseous_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'cargo type', 'carried in liquid state', 'pollution code', 'un type code' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'gaseous cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_gaseous_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'assignment context', 'cargo identifier' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'gaseous cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_global_axis_placement FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'global axes and origin', 'after perpendicular offset', 'orientation' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'global axis placement'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_gross_tonnage FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'overdeck tonnage', 'tonnage value', 'underdeck tonnage' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'gross tonnage'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_lightship_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'lightship weight', 'lightship centre of gravity' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'lightship definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_lightship_weight_item FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'aft weight extent', 'fwd weight extent' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'lightship weight item'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_liquid_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'cargo type', 'pollution code', 'un type code' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'liquid cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_liquid_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'assignment context', 'cargo height', 'cargo identifier' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'liquid cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_loading_condition_design_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'type of' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'loading condition design definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_loading_condition_operating_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'type of' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'loading condition operating definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_loadline FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'load line length', 'load line depth', 'load line displacement', 'load line block coefficient', 'load line regulation' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'loadline'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_local_coordinate_system FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'local axes and origin' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'local coordinate system'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_moment_3d_restricts_representation_item FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'longitudinal moment', 'transverse moment', 'vertical moment', 'origin' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (i <* representation| i.NAME = 'moment 3d');
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_moments_of_inertia FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'long moment of inertia', 'trans moment of inertia' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'moments of inertia'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_net_tonnage FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'tonnage value' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'net tonnage'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_person_group FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'number of people', 'person type', 'volume' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'person group parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_primer_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'dry film thickness', 'number of coats', 'surface preparation' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'primer coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_principal_characteristics FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'length between perpendiculars', 'moulded breadth', 'moulded depth' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'principal characteristics'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_space_adjacency_relationship FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'adjacency access', 'adjacency type' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'space adjacency relationship parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_space_positional_relationship FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'relationship type' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'space positional relationship parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_stability_table_restricted FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      c2_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF representation := [];
      t2_set : SET OF representation_item := [];
      t3_set : SET OF representation_item := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability table');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      c2_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability properties for one floating position');
      REPEAT i := 1 TO HIINDEX(c2_a_set);
         REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
            t2_set := t2_set + c2_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(t1_set[i].items);
            t3_set := t3_set + t1_set[i].items[j];
         END_REPEAT;
         violation := SIZEOF(t3_set * t2_set) < 1;
         t3_set := [];
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_stability_table_restricted_by_class_id FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF representation := [];
      arg_list : LIST OF STRING := [ 'mean shell thickness' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability table');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* t1_set[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_tank_compartment_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'context', 'design stowage density' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'tank compartment property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_tonnage_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'tonnage regulation' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'tonnage definition'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_tonnage_measurement FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'tonnage value' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'tonnage measurement'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_unit_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'cargo type', 'pollution code', 'un type code' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'unit cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_unit_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'assignment context', 'cargo identifier' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'unit cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_unit_cargo_bounding_box FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'point max', 'point min' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'unit cargo bounding box'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_unit_cargo_group FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'volume' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'unit cargo group parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_vehicle_load_description FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'load handling', 'load per wheel', 'number of wheels', 'type of vehicle' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'vehicle load description'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_for_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'used for' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_has_global_uncertainty_assigned_context FOR (shape_representation );
   LOCAL
      has_gunac : LOGICAL := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(shape_representation) WHILE has_gunac;
         has_gunac := 'SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN TYPEOF(shape_representation[i].CONTEXT_OF_ITEMS);
      END_REPEAT;
   WHERE
      WR1:
         has_gunac;
   END_RULE;



   RULE representation_has_global_unit_assigned_context FOR (representation );
   LOCAL
      has_guac : LOGICAL := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE has_guac;
         REPEAT j := 1 TO SIZEOF(representation[i].items) WHILE has_guac;
            IF ('SHIP_ARRANGEMENT_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF(representation[i].items[j])) OR ('SHIP_ARRANGEMENT_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(representation[i].items[j])) THEN
               has_guac := 'SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(representation[i].CONTEXT_OF_ITEMS);
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         has_guac;
   END_RULE;



   RULE representation_item_for_transformation_to_parent FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_set : SET OF representation := [];
      t4_set : SET OF representation_map := [];
      t5_set : SET OF mapped_item := [];
      arg_list : LIST OF STRING := [ 'local coordinate system position in global coordinate system', 'local coordinate system position in parent local coordinate system', 'local coordinate system position in parent local coordinate system with position reference' ];
      violation1 : LOGICAL := FALSE;
      violation2 : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'local co ordinate system');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation1 := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.used_representation.name = 'local axis representation'))) = 1);
         t3_set := t3_set + t2_set[i].used_representation;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
         t4_set := bag_to_set(USEDIN(t3_set[i], 'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
         t5_set := bag_to_set(USEDIN(t4_set[i], 'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
         REPEAT j := 1 TO 3 WHILE NOT violation2;
            violation2 := NOT (SIZEOF(QUERY (t2_inst <* t5_set| (t2_inst.name = arg_list[j]))) = 1);
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation1;
      wr2:
         NOT violation2;
   END_RULE;



   RULE representation_items_optional_for_bulk_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'flash point', 'required carriage temperature', 'permeability', 'stowage factor', 'user def cargo' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'bulk cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_capacity_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined capacity context' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'capacity properties'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_class_deck_load_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'grab weight', 'stowage height', 'stowage rate', 'vehicle load' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class deck load requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_class_notation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'ice class notation', 'service factor', 'approval required for heavy cargo' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'class notation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_access_authorization FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined value' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment access authorization'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_design_requirement FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined value' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment design requirement parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user def function' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_insulation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined value' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment insulation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_noise_category FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined value' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment noise category'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_safety_class FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined value' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment safety class'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_security FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined value' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment security classification'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_compartment_tightness FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined value' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'compartment tightness'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_corrosion_control_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined type' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'corrosion control coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_damage_case FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user defined' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'damage case parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_deck_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user def function' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'deck zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_detailed_cargo_material_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'density', 'expansion coefficient', 'specific heat capacity', 'thermal conductivity', 'viscosity' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'detailed cargo material properties parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_dry_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'flash point', 'required carriage temperature', 'user def cargo', 'permeability', 'stowage factor' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'dry cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_gaseous_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'flash point', 'required carriage pressure', 'required carriage temperature', 'user def cargo' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'gaseous cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_general_cargo_material_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'density' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'general cargo material properties parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_liquid_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'flash point', 'required carriage pressure', 'required carriage temperature', 'user def cargo' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'liquid cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_loading_condition_operating_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'place of loading' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'loading condition operating definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_owner_designation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'owner approval' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'owner designation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_principal_characteristics FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'block coefficient', 'design draught', 'design deadweight', 'min draught at fp', 'max draught at fp', 'min draught at ap', 'max draught at ap' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'principal characteristics'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_space_connection_relationship FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'connecting system' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'space connection relationship parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_tank_geometric_parameters FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'breadth wash', 'length wash' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'tank geometric parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_tank_piping_design_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'airpipe height', 'filling height', 'relief valve pressure setting', 'sounding pipe height' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'tank piping design properties'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_unit_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'flash point', 'permeability', 'stowage factor', 'required carriage temperature', 'stack limit', 'user def cargo', 'volume' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'unit cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_vehicle_load_description FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'max tyre pressure', 'print area' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'vehicle load description'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_items_optional_for_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'user def function' ];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
   END_RULE;



   RULE representation_local_coordinate_system_with_position_reference FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'local axes and origin' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'local coordinate system with position reference'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE representation_restricted_weight_and_centre_of_gravity FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := [ 'mass ', 'centre of gravity' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.NAME = 'weight and centre of gravity'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items| (rep_item.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE revision_has_mandatory_attribute_description FOR (group );
   LOCAL
      t1_set : SET OF group := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* group| VALUE_IN(WHICH_CLASS(i), 'revision'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE revision_with_context_referenced_for_context_of_revision FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'revision with context'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP = t1_set[i]) AND (b.role.NAME = 'context of revision'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE shape_representation_subtype_exclusiveness FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (SIZEOF(TYPEOF(sr) * [ 'SHIP_ARRANGEMENT_SCHEMA.NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION' ]) <= 2))) = 0;
   END_RULE;



   RULE ship_designation_has_one_specified_names FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition := [];
      t2_set : SET OF applied_identification_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'ship designation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set| (t2_inst.role.name = 'imo number') OR (t2_inst.role.name = 'pennant hull number'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE spacing_position_compound_representation_has_name FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF compound_representation_item := [];
      t2_set : SET OF representation_item := [];
      arg_list : LIST OF STRING := [ 'position number', 'position' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'spacing position');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            t2_set := t1_set[i].item_element;
            violation := SIZEOF(QUERY (items <* t2_set| (items.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE spacing_position_with_offset_compound_representation_has_class FOR (applied_classification_assignment );
   LOCAL
      t3_set : SET OF representation_item := [];
      violation : LOGICAL := FALSE;
      t1_set : SET OF compound_representation_item := [];
      c_a_set : SET OF applied_classification_assignment := [];
      c_a_set2 : SET OF applied_classification_assignment := [];
      l_rep_item : list_representation_item;
      t2_set : SET OF compound_representation_item := [];
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'spacing position with offset');
      REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      c_a_set2 := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'spacing position');
      REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
         REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
            t2_set := t2_set + c_a_set2[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
            l_rep_item := t1_set[i].item_element;
            t3_set := t3_set + l_rep_item[j];
         END_REPEAT;
         violation := SIZEOF(t3_set * t2_set) <> 1;
         t3_set := [];
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE spacing_position_with_offset_compound_representation_has_name FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF compound_representation_item := [];
      t2_set : SET OF representation_item := [];
      arg_list : LIST OF STRING := [ 'offset' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'spacing position with offset');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            t2_set := t1_set[i].item_element;
            violation := SIZEOF(QUERY (items <* t2_set| (items.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE stability_properties_for_floating_position_has_class FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      c_a_set2 : SET OF applied_classification_assignment := [];
      t1_set : SET OF compound_representation_item := [];
      t2_set : SET OF compound_representation_item := [];
      t3_set : SET OF representation_item := [];
      l_rep_item : list_representation_item;
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability properties for one floating position');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      c_a_set2 := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability property');
      REPEAT i := 1 TO HIINDEX(c_a_set2);
         REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
            t2_set := t2_set + c_a_set2[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
            l_rep_item := t1_set[i].item_element;
            t3_set := t3_set + l_rep_item[j];
         END_REPEAT;
         violation := SIZEOF(t3_set * t2_set) < 1;
         t3_set := [];
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE stability_properties_for_floating_position_has_name FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF compound_representation_item := [];
      t2_set : SET OF representation_item := [];
      arg_list : LIST OF STRING := [ 'centre of gravity above keel', 'definition of starting floating position' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability properties for one floating position');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            t2_set := t1_set[i].item_element;
            violation := SIZEOF(QUERY (items <* t2_set| (items.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE stability_property_has_name FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF compound_representation_item := [];
      t2_set : SET OF representation_item := [];
      arg_list : LIST OF STRING := [ 'angle of heel', 'righting arm', 'centre of buoyancy' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'stability property');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            t2_set := t1_set[i].item_element;
            violation := SIZEOF(QUERY (items <* t2_set| (items.name = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE surface_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF surface := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'surface with identifier' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE tonnage_definition_has_properties FOR (property_definition_representation, applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : LIST OF product_definition := [];
      t2_set : SET OF property_definition_representation := [];
      t3_set : LIST OF property_definition := [];
      t4_set : LIST OF product_definition := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'tonnage definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      t2_set := QUERY (i <* property_definition_representation| i.NAME = 'tonnage definition');
      REPEAT i := 1 TO HIINDEX(t2_set);
         t3_set := t3_set + t2_set[i].definition;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t3_set);
         t4_set := t4_set + t3_set[i].definition;
      END_REPEAT;
      violation := t1_set <> t4_set;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE unique_approvals_in_approval_history FOR (group, applied_group_assignment );
   LOCAL
      t1_set : SET OF group := [];
      t2_set : SET OF applied_group_assignment := [];
      t3_set : SET OF approval := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* group| VALUE_IN(WHICH_CLASS(i), 'approval history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         t2_set := QUERY (a <* applied_group_assignment| a.ASSIGNED_GROUP = t1_set[i]);
         t3_set := QUERY (b <* t2_set[1].items| 'SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(b));
         violate := NOT VALUE_UNIQUE(t3_set);
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE user_def_cargo_description_required_for_cargo_type FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'cargo type')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user def cargo'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_def_cargo_description_required_for_type_of FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'type of')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user def cargo'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_def_function_description_required FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'used for')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user def function'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_capacity_context_description_required_for_capacity_context FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'capacity context')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined capacity context'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_description_required_for_damage_cause FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'damage cause')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_type_description_required_for_type_of FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'type of')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined type'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_value_description_required_for_authorization_classification FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'authorization classification')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_value_description_required_for_compartment_insulation FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment insulation')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_value_description_required_for_compartment_noise_category FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment noise category')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_value_description_required_for_compartment_safety_class FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment safety class')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_value_description_required_for_compartment_security FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment security classification')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_value_description_required_for_compartment_tightness FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment tightness')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE user_defined_value_description_required_for_requirement_type FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items| (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'requirement type')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items| (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE version_creation_has_mandatory_attribute_description FOR (action );
   LOCAL
      t1_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action| VALUE_IN(WHICH_CLASS(i), 'version creation'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_deletion_has_mandatory_attribute_description FOR (action );
   LOCAL
      t1_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action| VALUE_IN(WHICH_CLASS(i), 'version deletion'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_history_has_exactly_one_assigned_group FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      set_1 : SET OF applied_group_assignment := [];
      set_2 : SET OF applied_group_assignment := [];
      set_3 : SET OF group_item := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'version history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         set_1 := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP = t1_set[i]) AND (b.role.NAME = 'current version'));
         set_2 := QUERY (c <* applied_group_assignment| (c.ASSIGNED_GROUP = t1_set[i]) AND (c.role.NAME = 'members'));
         violate := (SIZEOF(set_1) <> 1) OR (SIZEOF(set_2) <> 1);
         IF NOT violate THEN
            set_3 := set_1[1].items * set_2[1].items;
            violate := (SIZEOF(set_3) <> 1) OR NOT VALUE_IN(WHICH_CLASS(set_3[1]), 'versionable object');
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_history_is_referenced_by_at_least_one_versions FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'version history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP = t1_set[i]) AND (b.role.NAME = 'versions'));
         violate := SIZEOF(a_set) < 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_history_referenced_by_exactly_one_current_version FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'version history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP = t1_set[i]) AND (b.role.NAME = 'current version'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_history_referenced_by_multiple_roles FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'version history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP = t1_set[i]) AND NOT (b.role.NAME IN [ 'versions', 'current version', 'relationships' ]));
         violate := SIZEOF(a_set) < 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_modification_has_mandatory_attribute_description FOR (action );
   LOCAL
      t1_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action| VALUE_IN(WHICH_CLASS(i), 'version modification'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_relationship_associates_with_versionable_object FOR (applied_identification_assignment );
   LOCAL
      violate : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;
         IF (SIZEOF(USEDIN(applied_identification_assignment[i], 'SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATING_IDENTIFICATION_ASSIGNMENT')) > 0) OR (SIZEOF(USEDIN(applied_identification_assignment[i], 'SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) > 0) THEN
            REPEAT j := 1 TO HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
               violate := NOT VALUE_IN(WHICH_CLASS(applied_identification_assignment[i].items[j]), 'versionable object');
            END_REPEAT;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_relationship_has_mandatory_attribute_description FOR (identification_assignment_relationship );
   LOCAL
      t1_set : SET OF identification_assignment_relationship := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* identification_assignment_relationship| VALUE_IN(WHICH_CLASS(i), 'version relationship'));
      violate := SIZEOF(QUERY (k <* t1_set| NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE version_relationship_has_unique_versions FOR (identification_assignment_relationship );
   LOCAL
      t1_set : SET OF identification_assignment_relationship := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* identification_assignment_relationship| VALUE_IN(WHICH_CLASS(a), 'version relationship'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         violate := t1_set[i].relating_identification_assignment.assigned_id = t1_set[i].related_identification_assignment.assigned_id;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;



   RULE versionable_object_has_one_version_id FOR (applied_identification_assignment );
   LOCAL
      version_ids : SET OF applied_identification_assignment := [];
      versionable_objects : BAG OF identification_item := [];
      duplicate : LOGICAL := FALSE;
   END_LOCAL;
      version_ids := QUERY (i <* applied_identification_assignment| i.role.NAME = 'version identifier');
      REPEAT i := 1 TO HIINDEX(version_ids);
         versionable_objects := versionable_objects + version_ids[i].items;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
         REPEAT j := i + 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
            duplicate := versionable_objects[i] :=: versionable_objects[j];
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT duplicate;
   END_RULE;



   RULE versioned_action_request_with_identification_assignment FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF versioned_action_request := [];
      t2_set : SET OF applied_identification_assignment := [];
      arg_list : LIST OF STRING := [ 'change request' ];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
         c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = arg_list[j]);
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
         t2_set := QUERY (j <* t2_set| j.role.name = 'globally unambiguous identifier');
         violation := NOT (SIZEOF(t2_set) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
   END_RULE;



   RULE versions_is_referenced_by_at_least_one_version_history FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'versions'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP = t1_set[i]) AND (b.role.NAME = 'version history'));
         violate := SIZEOF(a_set) < 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
   END_RULE;


(* *********************************** *)


END_SCHEMA;


(* ************************************************************************** *)
