	   What's New in the STEP Class Library Release 3.1
			     October 1997

The following is a list of enhancements which are found in the version
3.1 release of the SCL and Data Probe.  It assumes you are familiar
with EXPRESS (ISO 10303-11).  Familiarity with version 2.1 or higher
is a big plus.

-------------------
Easier Installation
-------------------

We created a script called configure using gnu's autoconf software. 
The configure script is used to install the SCL release. Configure
automates the editing of multiple SCL files based on site-specific
information needed for installation. It performs checks against the
software and operating system environment to create a header file used
by SCL to handle commonly known software porting problem areas.
Finally, it builds all the SCL executables, scripts, and libraries.

Configure requires one command line argument specifying a name which
is used to create a directory. Configure installs the architecture and
environment specific SCL executables, scripts, libraries, and object
code is under this directory.

Configure accepts optional command line arguments to install the SCL
for use with optional software packages (like Orbix and/or
ObjectStore) and for use with different compilers on different
operating systems and/or machine architectures. Configure may be
executed several times to create several SCL builds under separate
architecture/environment specific directories. Each of these
directories is based on the same source code directory to minimize
space requirements. This is possible because the SCL source code was
created with preprocessor switches which allows the same source code
to be built for different purposes. Separate builds are also necessary
to use SCL with different C++ compilers since C++ object code is not
compatible between C++ compilers.

-----------------------------------------------------
Alignment with the C++ Binding (ISO 10303-23) to the Standard Data
Access Interface (SDAI, ISO 10303-22)
-----------------------------------------------------

SCL has been better aligned with the C++ binding (ISO 10303-23,
a.k.a. STEP Part 23) to SDAI. This has involved several name changes
for classes implementing base EXPRESS types and application-schema
defined EXPRESS types. The name changes were possible since these
types and classes have been moved to be encapsulated by a namespace
implemented via a struct definition. The namespace has been defined in
a way that offers great flexibility in avoiding name conflict with
other software packages (like X Windows, CORBA implementations, etc)
and your application code. The namespace name is easily changed if
necessary. As a result of adding a namespace a noticeable difference
in SCL use has occurred.

Use of underlying SCL classes and types are now wrapped in macros that
are defined in the file sclprefixes.h. This file is installed under
the arch directory which allows it to be adjusted as necessary for
each SCL software installation. For example, if a compiler or software
package has a problem handling the namespace mechanism via a struct
definition alternate macros can be used from the sclprefixes.h file
bypassing the namespace altogether. If a name conflict occurs when the
namespace is turned off macros can be used that add a name prefix to
SCL types and classes. Use of the macros when using SCL types and
classes is what allows for the flexibility in dealing with problem
areas when using SCL with other software.

An example of a name change and macro use: sdaiString has now become
SCLP23(String) which could translate to SDAI::String or SDAI_String
(depending on whether you use the SDAI namespace or not) or any other
namespace or prefix as is necessary. To change the SDAI namespace name
or prefix name the macro definition for SCLP23() could be changed in
the sclprefixes.h file.

The early bound access functions that are generated by fedex_plus from
EXPRESS defined entities have been updated to the latest version of
Part 23's C++ binding to SDAI. A previous early bound function defined
as "const SdaiLabel Name()" would now be defined according to Part 23 as
"const SdaiLabel name_()". *notice* that application schema defined
types are not yet defined in a namespace. Compatibility with previous
versions of SCL early bound functions has been maintained via the -a
fedex_plus option.

-----------------------------------------------------
SDAI Session Schema objects implemented (model_contents, extents, etc)
-----------------------------------------------------

Several classes and types defined as part of SDAI Part 23's Session
Schema have been implemented (where before they mostly had stub
functions). These have been implemented for use with or without the
ObjectStore object oriented database. Model_contents_<schema_name> is
now being generated by fedex_plus allowing Entity_extents to be
maintained for entities as desired. 

-----------------------------------------------------
Object Oriented Database Capability Using ObjectStore
-----------------------------------------------------

SCL has been enhanced to optionally use the object oriented database
ObjectStore from ODI. The INSTALL file describes how to build the SCL
libraries for use with ObjectStore. The SCL libraries built for use
with ObjectStore may then be used to create persistent or transient
SCL objects. The transient objects use the ObjectStore transient
database. 

The SCL application, fedex_os, uses an application schema written in
EXPRESS to generate additional code needed for use with ObjectStore. 
Fedex_os is used in conjunction with fedex_plus for generating the C++
necessary to implement your application schema.

Although building SCL libraries for use with ObjectStore is
documented, instructions for building your application with SCL
libraries and ObjectStore is as of yet undocumented. The undocumented
steps for building an SCL/ObjectStore application are the steps
required to build any ObjectStore application. A person familiar with
building ObjectStore applications should be able to create a Makefile
able to perform these necessary steps.

A good starting point for creating a Makefile suitable for building an
SCL/ObjectStore application would be the Makefile generated using the
mkProbe script. The configure script (executed with the ObjectStore
options) generates a make_rules file which contains the necessary
Makefile macros for using ObjectStore.  The mkProbe generated Makefile
already includes this make_rules file. The Makefile is set up to build
a simple application which uses the appropriate SCL and ObjectStore
libraries. The Makefile rules for building this application could be
used as a starting point for creating Makefile rules to build your own
SCL/ObjectStore application. (The example application code is not set
up to use ObjectStore.) Additional steps would need to be added to run
the ObjectStore schema generator (ossg), link with the additional
application-specific ObjectStore object files, run os_postlink, etc.

-------------------------------------------------------
Use of Orbix with SCL for Developing CORBA Applications
-------------------------------------------------------

SCL has been enhanced to be able to use Orbix for developing SCL
applications for use within the Common Object Request Broker
Architecture (CORBA). CORBA is used to provide an architecture for use
of objects within a distributed environment. Distributed communication
occurs by client applications communicating with servers through
Object Request Brokers (ORBs). Clients may be written to use any
number of programming languages provided the CORBA software vendor
(Orbix in this case) supports the language. We have only tested
clients written using C++. We may soon test JAVA clients.

The SCL application, fedex_idl, is used to create an Interface
Definition Language (IDL) schema from your application's EXPRESS
schema. The generation of IDL schemas by fedex_idl is according to
STEP's Part 26 Interface Definition Language binding to the SDAI. The
Orbix IDL compiler is then used to generate the client and server code
necessary for communication through an Orbix ORB. The SCL application,
fedex_plus, would then be run with the -c option on your application's
EXPRESS schema to generate the server implementation objects required
to build an Orbix server (it uses the TIE approach). You would be
required to write the C++ main() function for the server code.

Although building SCL libraries for use with Orbix is documented,
instructions for building your application with SCL libraries and
Orbix is as of yet undocumented. The undocumented steps for building
an SCL/Orbix application are the steps required to build any Orbix
application. A person familiar with building Orbix applications should
be able to create a Makefile able to perform these necessary steps.

A good starting point for creating a Makefile suitable for building an
SCL/Orbix application would be the Makefile generated using the
mkProbe script. The configure script (executed with the Orbix options)
generates a make_rules file which contains the necessary Makefile
macros for using Orbix.  The mkProbe generated Makefile already
includes this make_rules file. The Makefile is set up to build a
simple application which uses the appropriate SCL and Orbix
libraries. The Makefile rules for building this application could be
used as a starting point for creating Makefile rules to build your own
SCL/Orbix application. (The example application code is not set up to
use Orbix.) Additional steps would need to be added to build the
additional server code you would need to write, register the server
with Orbix, build and link with the IDL compiler generated code, etc.

-----------------------------------------------------
Use of Orbix and ObjectStore with SCL
-----------------------------------------------------

SCL has been enhanced to be able to be used with Orbix and ObjectStore
providing a persistent server for use within a distributed CORBA
environment. We have used SCL in this way for two NIST projects: the
National Industrial Information Infrastructure Protocols project and
the National Advanced Manufacturing Testbed Framework project.

Once again, although building the SCL libraries for use with Orbix and
ObjectStore is documented (via installation using the configure
script), instructions for building your application to use Orbix and
ObjectStore is as of yet undocumented. See the previous two sections.

-----------------------
MULTIPLE SCHEMA SUPPORT
-----------------------

A library and Data Probe can now be generated for an EXPRESS file
containing multiple schemas.  This is done primarily by dividing the
source code generated by fedex_plus into separate files.  Separate
files are generated for each schema contained in the EXPRESS file.  In
addition, often schemas are dependent on one another.  This will be
the case if the schemas use and reference entities and types from each
other.  If, for example, entity X in schema A is a subtype of entity Y
in schema B, X will not be processed until B in schema Y is processed.
Other such cases of interdependence occur if an entity in schema A
contains as an attribute an enumeration or select type defined in
another schema.  To address such cases, fedex_plus may process a
schema in multiple passes.  At each pass, only the objects in the
schema which are not dependent on not-yet-processed objects in other
schemas are processed.  At each successive pass through the schemas as
more and more objects are processed, more and more dependent entities
will become processable.  Certain schemas may require three passes or
more in cases of chains of dependence (such as A being a supertype of
B which is a supertype of C, etc.).

For an EXPRESS file with multiple dependent schemas, it is advisable
to organize the file with bottom-up design.  Schemas containing the
simpler, building block types and entities should appear first.  By
doing so, when fedex_plus begins processing the more complex schemas,
there will be fewer cases in which the parser will encounter not-yet-
defined objects from other schemas.  (The objects which are referenced
the most will have already been defined.)  This will minimize the
number of times fedex_plus is required to divide output files.

One known case of interdependence which fedex_plus is not able to
support occurs if say select A has select B as an item, and select B
has select A as an item.  (This is unsupported even if A and B are in
the same schema.)  fedex_plus has no way in which it can generate
compilable source code for the selects because each is dependent on
the other.  In addition, this would cause the parser to fall into an
endless loop, so we strongly discourage it.  ;-)

------------------------------
USE / REFERENCE CLAUSE SUPPORT
------------------------------

The SCL also partially supports the EXPRESS concepts of USE and
REFERENCE.  According to the rules of EXPRESS, schema A may reference
objects from schema B by way of a USE or REFERENCE clause (U/R).  Any
object which is not U/R'ed from schema A to B, directly or indirectly,
is not visible to B.  The SCL does not support the hiding of objects
between schemas.  Basically, an object defined anywhere in the SCL is
visible everywhere else. What is supported is renamings of objects
between schemas.  Say schema B uses entity X from schema A and renames
it to Y (i.e., "USE from A (X as Y);").  If a Part 21 file is read in
or written out using the SCL or the Data Probe, if the "current"
schema is defined to be B, the renamings defined by B's U/R statements
will be used.  The "current" schema is set according to the first
schema listed in the FILE_SCHEMA section of the Part 21 file's header
section.  (It is assumed that I/O is being done with the SCL's
STEPfile object.)  If no current schema is defined, all possible
entity and type names are recognized in file reading, and the original
names only are used in writing.

As mentioned above, the SCL does not support the hiding of objects of
say, schema A, which are not U/R'ed by schema B.  Thus, it's possible
to use the SCL or Data Probe to read or write a Part 21 file in which
A is the current schema and which contains instances of entities which
are not U/R'ed by A.  This will not be flagged as an error.

The U/R clause is more poorly supported by the Data Probe.  When the
Probe displays instances of entities, only their original names are
displayed.  (This also applies when an entity has a select attribute
and the current choice of the select is being displayed by name.  For
example, if a select is set to HEIGHT(35), the original name of
`HEIGHT' is displayed even if we're in schema B which renames HEIGHT
to LENGTH.)  When a user is using a <<step entity editor window>> to
create an instance of an entity, all possible names for a type are
recognized.  This includes the original object name plus all names
given to it by other U/R'ing schemas, regardless of the current
schema.

Another shortcoming with the U/R support is related to the fact that
the SCL does not allow objects of the same name in different schemas.
For this reason, U/R support is also limited to cases where the new
name is unique within the entire EXPRESS file.

Lastly, the U/R support is unable to deal with aggregate types of
two or more dimensions.  Say we were attempting to instantiate a 2D
aggregate of selects.  Type names will appear in the inner select
instantiations, and they should be set according to the current
schema.  However, since the SCL currently does not fully support
higher-dimension aggregates (it uses the SCLundefined class and
considers the entire instantiation a string), it's impossible to
verify the values within the aggregate instance.

----------------------
COMPLEX ENTITY SUPPORT
----------------------

By complex entity, I mean ones which require external mapping (see Part 21,
section 11.2.5).

New Features
------------
(I really think the structures and functions I used to support this
are a recursive work of art.  Too bad it's all invisible to the user.)

1. The primary enhancement now included is the checking of the
legality of complex entities.  If a user attempts to initialize a
complex entity (class STEPcomplex), the SCL will determine, based on
the supertype and subtype information of the EXPRESS, if the entity
represents a legal combination of entities.  If not, an error message
will be issued, and a complex entity will not be created.  Formerly,
the SCL would only check if the entity names themselves were valid and
not worry about the combination.

2. Non-independent entities cannot be instantiated.  These are
entities which cannot be created without external mapping.  Say we
have,

ENTITY A SUPERTYPE OF (B AND C);

The SCL would not accept an instantiation statement such as,

#11=C(xx,yy,...);

C requires external mapping since it can only exist together with B,
in a statement such as,

#11=(A(...)B(...)C(...));

If a user attempts to create a C with internal mapping using the
STEPfile object (the class which handles all reading and writing of
Part 21 files within the SCL), an entity will not be created and an
error message will be issued.  The SCL behaves similarly if a user
attempts to create an instance of an abstract supertype.

The above behavior is also reflected in the Data Probe.  All entities
which are abstract supertypes are marked with an `*' (as in SCL vn.
2.1).  Entities which cannot be instatiated without external mapping
are marked with a `%'.  Neither can be created using the Data Probe.
(The Probe does not have the capability of creating complex entities,
see below, next section.)

(Note: A user can instantiate an entity such as C from the STEPentity
level, bypassing STEPfile.  STEPentity will allow the initialization
but will place a warning in its errorDesc field.)

3. fedex_plus may be compiled with the flag COMPLEX_INFO.  If this
flag is turned on, fedex_plus prints out (to `cout') a large amount of
detail on the complex entities it finds and their overall structure.
This is useful to see how fedex interpreted the complex information of
an EXPRESS file, and to get a simple graphical view of the supertype-
subtype hierarchy of the file.

fedex_plus's makefile contains the commented-out line,

#USER_DEFS = -DCOMPLEX_INFO

If this line is uncommented, a fedex_plus executable will be built
which prints such information.

Limitations
-----------

1. As in multi-schema support (above), complex entity (CE) support is
not completely reflected in the Data Probe.  This may be seen in a
number of instances (you can skip this if you don't intend to use the
Probe):

(a) It's impossible to create an instance of a CE using the Data
Probe.  (See point #2 under "Complex Entity Support"). 

(b) The Data Probe is able to correctly read a CE from a Part 21 file,
and place a copy of it in the Entity Instance List Window.  It also
allows the user to edit the values of the entity's attributes by
selecting the entity (from the Ent Instance List Win) and creating a
STEP Entity Editor Window.  The Data Probe, however, does not accu-
rately display the type information of the CE (in the Type Information
Window).  What it does do is takes the name of the 1st entity in the
list (CE entity names are displayed alphabetically) and shows the type
info for that entity.

2. The SCL does not read partial complex instances.  Generally, if a
single entity-member of a complex entity has an error, the entire rest
of the complex entity will be skipped.

3. If entity members of a complex entity have been renamed (through
the EXPRESS USE/REF clause - see previous section), they are read and
written properly.  However, the SCL may not write the members of the
CE in alphabetical order (as required by Part 21, sect 11.2.5.3).  The
individual entities are sorted according to their original names.  If
the renaming of an individual entity places it out of order, the nodes
will be printed out of order.

4. "Diamond inheritance" is not handled automatically and must be
fixed by hand in the code generated by fedex_plus.  (See
whatsnew.2-1.txt, section "Multiple Inheritance".)

5. Selects between aggregates: A select containing two aggregate
choices of the same type (e.g., ARRAY and ARRAY, as opposed to ARRAY
and SET) will cause fedex_plus to generate code which cannot be
compiled.

6. Problem with sparcworks compiler version 4.0(?) - operator int() =
op enum().  This happens in the following case... Both functions,
however, are required by Part 23.  We fixed this by removing enough
functions for it to build.  We were not sure if this error is the fault
of the sparcworks compiler or is a problem with the standard.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!DISCLAIMERS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Names of companies and products are provided in order to adequately
specify procedures and equipment used.  In no case does such
identification imply recommendation or endorsement by the National
Institute of Standards and Technology, nor does it imply that the
products are necessarily the best available for the purpose.

NO WARRANTY
===========

NIST PROVIDES ABSOLUTELY NO WARRANTY.  THE NIST STEP TOOLKIT
IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS
WITH YOU.  SHOULD ANY PORTION OF THE NIST STEP TOOLKIT PROVE DEFECTIVE,
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT WILL NIST BE LIABLE FOR DAMAGES, INCLUDING ANY LOST
PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE (INCLUDING BUT NOT
LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE, OR LOSSES
SUSTAINED BY THIRD PARTIES, OR A FAILURE OF THE PROGRAM TO OPERATE
WITH PROGRAMS NOT DISTRIBUTED BY NIST) THE PROGRAMS, EVEN IF YOU HAVE
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY
ANY OTHER PARTY.
