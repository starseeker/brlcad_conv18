Index: opennurbs_light.h
===================================================================
--- opennurbs_light.h	(revision 32970)
+++ opennurbs_light.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -113,11 +112,11 @@
   void SetStyle(ON::light_style);
   ON::light_style Style() const;
 
-  BOOL IsPointLight() const;
-  BOOL IsDirectionalLight() const;
-  BOOL IsSpotLight() const;
-  BOOL IsLinearLight() const;
-  BOOL IsRectangularLight() const;
+  const BOOL IsPointLight() const;
+  const BOOL IsDirectionalLight() const;
+  const BOOL IsSpotLight() const;
+  const BOOL IsLinearLight() const;
+  const BOOL IsRectangularLight() const;
 
   ON::coordinate_system CoordinateSystem() const; // determined by style
 
Index: opennurbs_point.h
===================================================================
--- opennurbs_point.h	(revision 32970)
+++ opennurbs_point.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -238,9 +237,6 @@
 	 const ON_Interval&, 
 	 const ON_Interval&
 	 );
-
-  void Bound(double& val) const;
-
 };
 
Index: opennurbs_system.h
===================================================================
--- opennurbs_system.h	(revision 32970)
+++ opennurbs_system.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -67,14 +66,7 @@
 #endif
 #endif
 
-#if defined(sgi) || defined(__sgi)
-#define ON_COMPILER_IRIX
-#endif
 
-#if defined(sun) || defined(__sun)
-#define ON_COMPILER_SUN
-#endif
-
 #if defined(_GNU_SOURCE) && defined(__APPLE__)
 /* using Apple's OSX XCode compiler */
 #if !defined(ON_COMPILER_XCODE)
@@ -138,16 +130,12 @@
 
 #endif
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 #include <stdlib.h>
 #include <memory.h>
 #if defined(ON_COMPILER_XCODE)
 #include <malloc/malloc.h>
 #else
-//#include <malloc.h>
+#include <malloc.h>
 #endif
 #include <string.h>
 #include <math.h>
@@ -158,7 +146,7 @@
 #include <limits.h>
 #include <ctype.h>
 
-#if defined(ON_COMPILER_IRIX) || defined(ON_COMPILER_SUN)
+#if defined(ON_COMPILER_IRIX)
 #include <alloca.h>
 #endif
 
@@ -171,14 +159,11 @@
 #include <sys\stat.h>
 #include <tchar.h>
 
-// alloca
-#include <malloc.h>
-
 // ON_CreateUuid calls Windows's ::UuidCreate() which
 // is declared in Rpcdce.h and defined in Rpcrt4.lib.
 #include <Rpc.h>
 
-#endif /* ON_OS_WINDOWS */
+#endif
 
 #if defined(ON_COMPILER_GNU)
 #include <sys/types.h>
@@ -189,10 +174,6 @@
 #endif
 #endif
 
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-
 #if defined (cplusplus) || defined(_cplusplus) || defined(__cplusplus)
 // C++ system includes
 
@@ -236,7 +217,7 @@
 
 /* 16-bit wide character ("UNICODE") */
 
-#if !defined(ON_COMPILER_MSC) && !defined(ON_COMPILER_GNU)
+#if !defined(_WCHAR_T)
 typedef unsigned short wchar_t;
 #endif
 Index: opennurbs_brep.h
===================================================================
--- opennurbs_brep.h	(revision 32970)
+++ opennurbs_brep.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -406,7 +405,7 @@
   the ON_Curve virtual member functions.
 
   Note well that the domains and orientations of the curve
-  m_C2[trim.m_c2i] and the trim as a curve may not
+  m_C2[trim.m_c2i] and the trin as a curve may not
   agree.
 */
 class ON_CLASS ON_BrepTrim : public  ON_CurveProxy
Index: opennurbs_math.h
===================================================================
--- opennurbs_math.h	(revision 32970)
+++ opennurbs_math.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -1487,7 +1486,4 @@
 ON_DECL int ON_Min(int a, int b);
 
 ON_DECL int ON_Round(double x);
-
-ON_DECL
-bool ON_NearZero(double x, double tolerance = ON_ZERO_TOLERANCE);
 #endif
Index: opennurbs_nurbscurve.h
===================================================================
--- opennurbs_nurbscurve.h	(revision 32970)
+++ opennurbs_nurbscurve.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -1010,24 +1009,7 @@
   bool MakePiecewiseBezier( 
 	bool bSetEndWeightsToOne = false
 	);
-  bool MakePiecewiseBezier(ON_BezierCurve* cache = NULL,
-			   bool bSetEndWeightsToOne = false) const;
 
-  /// virtual ON_Curve override
-  int NumIntersectionsWith(const ON_Line& segment) const;
-
-  // so it can be done in prep!
-  void CacheBezierSpans() const;
-
-  int BezierSpanCount() const;
-  bool CopyBezierSpan(int span, ON_BezierCurve& b);
-  const ON_BezierCurve* BezierSpan(int span) const;
-
-private:
-  // XXX: ensure the cache is reset if the curve is modified!
-  mutable ON_BezierCurve* m_cached_bez;
-
-
   /////////////////////////////////////////////////////////////////
   // Implementation
 public:
Index: opennurbs_zlib.h
===================================================================
--- opennurbs_zlib.h	(revision 32970)
+++ opennurbs_zlib.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -17,6 +16,11 @@
 #if !defined(OPENNURBS_ZLIB_INC_)
 #define OPENNURBS_ZLIB_INC_
 
+// If you are using opennurbs as a statically linked library, then
+// you may make calls to the same zlib that opennurbs uses.  This
+// zlib is compiled with z_ symbol projectection.  All the necessary
+// header files are included by opennurbs.h.
+// 
 // If you are using opennurbs as a DLL or writing a Rhino plug-in
 // and you want to use the same zlib that opennurbs uses, then
 // compile opennurbs_zlib_memory.cpp into your application
@@ -24,17 +28,17 @@
 // header files are included by opennurbs.h.
 
 
-/*#if !defined(Z_PREFIX)*/
+#if !defined(Z_PREFIX)
 /* decorates zlib functions with a "z_" prefix to prevent symbol collision. */
-/*#define Z_PREFIX*/
-/*#endif*/
+#define Z_PREFIX
+#endif
 
 #if !defined(MY_ZCALLOC)
 /* have zlib use oncalloc() and onfree() for memory managment*/
 #define MY_ZCALLOC
 #endif
 
-#include <zlib.h>
+#include "./zlib/zlib.h"
 
 ON_BEGIN_EXTERNC
 voidpf zcalloc (voidpf, unsigned, unsigned);
Index: opennurbs.h
===================================================================
--- opennurbs.h	(revision 32970)
+++ opennurbs.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -24,10 +23,6 @@
 #if !defined(OPENNURBS_INC_)
 #define OPENNURBS_INC_
 
-#include <iostream>
-//#define ON_TRACE(m) std::cout << m << std::endl
-#define ON_TRACE(m)
-
 #include "opennurbs_system.h"       /* system headers used by openNURBS code */
 
 #include "opennurbs_3dm.h"          /* 3DM typecode (TCODE) definitions */
Index: opennurbs_bezier.h
===================================================================
--- opennurbs_bezier.h	(revision 32970)
+++ opennurbs_bezier.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -544,10 +543,6 @@
 	 double* v
 	 ) const;
 
-  // virtual ON_Curve override
-  int NumIntersectionsWith(const ON_Line& segment) const;
-
-
   // Description:
   //   Get ON_NurbsCurve form of a bezier.
   // Parameters:
Index: opennurbs_brep.cpp
===================================================================
--- opennurbs_brep.cpp	(revision 32970)
+++ opennurbs_brep.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -3314,10 +3313,8 @@
       //    Added relative tol check so cases with huge
       //    coordinate values that agreed to 10 places
       //    didn't get flagged as bad.
-//      double xtol = (fabs(P0.x) + fabs(P1.x))*1.0e-10;  XXX - not using our tolerance? WTF?
-//      double ytol = (fabs(P0.y) + fabs(P1.y))*1.0e-10;
-      double xtol = (fabs(P0.x) + fabs(P1.x))*trim0.m_tolerance[0];
-      double ytol = (fabs(P0.y) + fabs(P1.y))*trim0.m_tolerance[1];
+      double xtol = (fabs(P0.x) + fabs(P1.x))*1.0e-10;
+      double ytol = (fabs(P0.y) + fabs(P1.y))*1.0e-10;
       if ( xtol < ON_ZERO_TOLERANCE )
 	xtol = ON_ZERO_TOLERANCE;
       if ( ytol < ON_ZERO_TOLERANCE )
@@ -10864,9 +10861,6 @@
   case ON_COMPONENT_INDEX::brep_loop:
     component = Loop(ci.m_index);
     break;
-  default:
-      /* unsupported component type */
-      break;
   }
   return component;
 }
Index: opennurbs_zlib.cpp
===================================================================
--- opennurbs_zlib.cpp	(revision 32970)
+++ opennurbs_zlib.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -236,11 +235,11 @@
       // no uncompressed input is left - switch to finish mode
       flush = Z_FINISH;
     }
-    zrc = deflate( &m_zlib.strm, flush ); 
+    zrc = z_deflate( &m_zlib.strm, flush ); 
     if ( zrc < 0 ) 
     {
       // Something went haywire - bail out.
-      ON_ERROR("ON_BinaryArchive::WriteDeflate - deflate failure");
+      ON_ERROR("ON_BinaryArchive::WriteDeflate - z_deflate failure");
       rc = false;
       break;
     }
@@ -434,11 +433,11 @@
       // no compressed input is left - switch to finish mode
       flush = Z_FINISH;
     }
-    zrc = inflate( &m_zlib.strm, flush );
+    zrc = z_inflate( &m_zlib.strm, flush );
     if ( zrc < 0 ) 
     {
       // Something went haywire - bail out.
-      ON_ERROR("ON_BinaryArchive::ReadInflate - inflate failure");
+      ON_ERROR("ON_BinaryArchive::ReadInflate - z_inflate failure");
       rc = false;
       break;
     }
@@ -1094,11 +1093,11 @@
       // no uncompressed input is left - switch to finish mode
       flush = Z_FINISH;
     }
-    zrc = deflate( &m_zlib.strm, flush ); 
+    zrc = z_deflate( &m_zlib.strm, flush ); 
     if ( zrc < 0 ) 
     {
       // Something went haywire - bail out.
-      ON_ERROR("ON_CompressedBuffer::DeflateHelper - deflate failure");
+      ON_ERROR("ON_CompressedBuffer::DeflateHelper - z_deflate failure");
       rc = false;
       break;
     }
@@ -1227,11 +1226,11 @@
       // no compressed input is left - switch to finish mode
       flush = Z_FINISH;
     }
-    zrc = inflate( &m_zlib.strm, flush );
+    zrc = z_inflate( &m_zlib.strm, flush );
     if ( zrc < 0 ) 
     {
       // Something went haywire - bail out.
-      ON_ERROR("ON_CompressedBuffer::InflateHelper - inflate failure");
+      ON_ERROR("ON_CompressedBuffer::InflateHelper - z_inflate failure");
       rc = false;
       break;
     }
Index: opennurbs_bezier.cpp
===================================================================
--- opennurbs_bezier.cpp	(revision 32970)
+++ opennurbs_bezier.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -15,9 +14,6 @@
 */
 
 #include "opennurbs.h"
-#include <limits>
-#include <assert.h>
-#include <list>
 
 ON_PolynomialCurve::ON_PolynomialCurve()
 		   : m_dim(0), m_is_rat(0), m_order(0), m_domain(0.0,1.0)
@@ -1109,147 +1105,6 @@
 			    der_count, t, v_stride, v )?true:false;
 }
 
-#define QUAD1 0
-#define QUAD2 1
-#define QUAD3 2
-#define QUAD4 3
-
-#define CASE_A 		0
-#define CASE_B 		2
-#define CASE_C 		3
-
-int case_table[16]  = {		/* A = 0, B = 2, C = 3 */
-  0,0,0,0,0,3,0,3,0,2,3,3,0,3,3,3
-};
-
-inline
-int quadrant(const ON_3dPoint& axis, double* pt, double weight = 1.0) {
-  double u = axis.x;
-  double v = axis.y;
-  if (pt[0] / weight > u)
-    return (pt[1] / weight >= v) ? QUAD1 : QUAD4;
-  else
-    return (pt[1] / weight >= v) ? QUAD2 : QUAD3;
-}
-
-inline
-int sign(double num) {
-  return (num >= 0) ? 1 : -1;
-}
-
-static std::numeric_limits<double> real;
-
-int ON_BezierCurve::NumIntersectionsWith(const ON_Line& segment) const
-{
-  ON_TRACE("ON_BezierCurve::NumIntersectionsWith");
-  // XXX - assumes the segment is horizontal and to the "right"
-  std::list<ON_BezierCurve> stack;
-
-  int num_isect = 0;
-  stack.push_back(*this);
-  while (stack.size() > 0) {
-    ON_BezierCurve crv = stack.back();
-
-// The assertion below does not allow rhino converted structures to raytrace.  
-// Need to figure out why, and what it means for CVCount to be 0. djg 4/15/08
-if (crv.CVCount() < 1 ) {
-  return 0;
-}
-    stack.pop_back();
-
-    int qstats = 0;
-    ON_Interval dom = crv.Domain();
-    assert(crv.CVCount() > 0);
-    // determine the case (a la Nishita bezier intersection algorithm)
-    for (int i1 = 0; i1 < crv.CVCount(); i1++) {
-      qstats |= (1 << quadrant(segment[0], crv.CV(i1), crv.IsRational() ? crv.Weight(i1) : 1.0));
-    }
-    assert(qstats >= 0);
-    int curve_case = case_table[qstats];
-
-    // handle the specific cases
-    switch (curve_case) {
-    case CASE_A: // there is no possibility of intersection
-      ON_TRACE("\tCASE A");
-      break;
-    case CASE_B: // there is either an even or odd number of intersections
-      {
-	ON_TRACE("\tCASE B");
-	// check the endpoints of the curve to determine if they are in
-	// the same or different quadrants
-	int quad1 = quadrant(segment[0], crv.PointAt(dom.Min()));
-	int quad2 = quadrant(segment[0], crv.PointAt(dom.Max()));
-	// if they are in the same quadrant, then the num intersections is even
-	// otherwise the number of intersections is odd
-	num_isect += (quad1 == quad2) ? 0 : 1;
-	break;
-      }
-    case CASE_C:
-      {
-	ON_TRACE("\tCASE C");
-	// use Bezier clipping to eliminate segments of the curve that
-	// cannot intersect the segment
-	ON_2dPoint* d = static_cast<ON_2dPoint*>(alloca(crv.m_order * sizeof(ON_2dPoint))); // control points for the explicit Bezier curve
-	for (int i = 0; i < crv.m_order; i++) {
-	  d[i].x = ((double)i)/(double)(crv.m_order-1);
-	  d[i].y = crv.CV(i)[1] - segment[0].y; // dist from the segment
-	  ON_TRACE("d[" << i << "]: " << d[i].x << "," << d[i].y);
-	}
-
-	// calculate the trimming points
-	// XXX - ack - make sure this handles all cases
-	double tmin = real.infinity();
-	double tmax = -real.infinity();
-	for (int i2 = 0; i2 < (crv.m_order-1); i2++) {
-	  for (int j = i2+1; j < crv.m_order; j++) {
-	    int a = i2;
-	    int b = j;
-	    if (sign(d[a].y) != sign(d[b].y)) {
-	      double t = d[a].x - d[a].y * (d[b].x - d[a].x) / (d[b].y - d[a].y);
-	      if (t < tmin) tmin = t; // XXX why offsets?
-	      if (t > tmax) tmax = t;
-	    }
-	  }
-	}
-
-	double tleft = tmin;
-	double tright = tmax;
-	ON_TRACE("tleft : " << tleft);
-	ON_TRACE("tright: " << tright);
-	//assert( tleft <= tright );
-	if (fabs(tleft-tright) < 0.2) {
-	  // XXX the tleft/tright calc doesn't seem to be working, otherwise
-	  // why would we need this case?
-	  tleft = .33;
-	  tright = .66;
-	  ON_BezierCurve left(crv), middle(crv), right(crv);
-	  //Split(tleft, left, middle);
-	  //middle.Split((tright-tleft)/(1.0-tleft), middle, right);
-	  left.Trim(ON_Interval(0.0,tleft));
-	  middle.Trim(ON_Interval(tleft, tright));
-	  right.Trim(ON_Interval(tright,1.0));
-	  stack.push_back(left);
-	  stack.push_back(middle);
-	  stack.push_back(right);
-	} else {
-	  ON_BezierCurve middle(crv);
-	  middle.Trim(ON_Interval(tleft,tright));
-	  ON_TRACE("After trim:");
-	  ON_TRACE("middle domain: " << middle.Domain().Min() << " --> " << middle.Domain().Max());
-
-	  // since we are limited to horizontal segments for now
-	  // we know that left and right are CASE_A...
-	  stack.push_back(middle);
-	}
-	break;
-      }
-    default:
-      assert(false);
-    }
-  }
-  return num_isect;
-}
-
 bool ON_BezierCurve::GetNurbForm( ON_NurbsCurve& n ) const
 {
   bool rc = false;
Index: opennurbs_point.cpp
===================================================================
--- opennurbs_point.cpp	(revision 32970)
+++ opennurbs_point.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -16,17 +15,6 @@
 
 #include "opennurbs.h"
 
-/* for finite() in ON_IsFinite() */
-
-/* ugh, included just to get HAVE_IEEEFP_H */
-#include "common.h"
-
-#ifdef HAVE_IEEEFP_H
-# include <ieeefp.h>
-#else
-# include <math.h>
-#endif
-
 bool ON_IsFinite(double x)
 {
   // Returns true if x is a finite double.  Specifically,
@@ -40,7 +28,7 @@
   // you can't find anything, then just set this
   // function to return true.
 
-#if defined(ON_COMPILER_GNU)
+#if defined(_GNU_SOURCE)
   return (finite(x)?true:false);
 #else
   return (_finite(x)?true:false);
@@ -414,13 +402,6 @@
   return rc;
 }
 
-// Bounds the given value to within the interval
-void
-ON_Interval::Bound(double& val) const
-{
-  if (val < m_t[0]) { val = m_t[0]; return; }
-  if (val > m_t[1]) val = m_t[1];
-}
 
 bool ON_3dVector::Decompose( // Computes a, b, c such that this vector = a*X + b*Y + c*Z
        //
Index: opennurbs_annotation2.cpp
===================================================================
--- opennurbs_annotation2.cpp	(revision 32970)
+++ opennurbs_annotation2.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -99,9 +98,6 @@
       }
     }
     break;
-    default:
-      /* unsupported */
-      break;
   }
   if (!rc)
   {
Index: opennurbs_linecurve.h
===================================================================
--- opennurbs_linecurve.h	(revision 32970)
+++ opennurbs_linecurve.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -307,9 +306,6 @@
 	  const ON_Interval* curve_domain = 0
 	  ) const;
 
-  // virtual ON_Curve override
-  int NumIntersectionsWith(const ON_Line& segment) const;
-  
   // Description:
   //   virtual ON_Curve::GetLength override.
   //   Get the length of the line.
Index: opennurbs_zlib_memory.cpp
===================================================================
--- opennurbs_zlib_memory.cpp	(revision 32970)
+++ opennurbs_zlib_memory.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -16,6 +15,11 @@
 
 #include "opennurbs.h"
 
+// If you are using opennurbs as a statically linked library, then
+// you may make calls to the same zlib that opennurbs uses.  This
+// zlib is compiled with z_ symbol projectection.  All the necessary
+// header files are included by opennurbs.h.
+// 
 // If you are using opennurbs as a DLL or writing a Rhino plug-in
 // and you want to use the same zlib that opennurbs uses, then
 // compile opennurbs_zlib_memory.cpp (this file) into your application
Index: opennurbs_math.cpp
===================================================================
--- opennurbs_math.cpp	(revision 32970)
+++ opennurbs_math.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -4353,8 +4352,3 @@
 int ON_Round(double x){
   return (x>=0.0) ? ((int)(x+0.5)) : -((int)(0.5-x));
 }
-
-bool
-ON_NearZero(double x, double tolerance) {
-  return (x > -tolerance) && (x < tolerance);
-}
Index: opennurbs_linecurve.cpp
===================================================================
--- opennurbs_linecurve.cpp	(revision 32970)
+++ opennurbs_linecurve.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -512,27 +511,6 @@
   return rc;
 }
 
-int ON_LineCurve::NumIntersectionsWith( const ON_Line& segment ) const
-{
-  // segment is assumed to be horizontal at this point
-  // and first point is the "left" point
-  if (((m_line[0].y < segment[0].y) && (m_line[1].y < segment[0].y)) ||
-      ((m_line[0].y > segment[0].y) && (m_line[1].y > segment[0].y)) ||
-      (m_line[0].x < segment[0].x && m_line[1].x < segment[0].x)) {
-    return 0;
-  } else if (m_line[0].x > segment[0].x && m_line[1].x > segment[0].x) {
-    return 1;
-  } else {
-    // use the two point form of a line to solve for x at the y of the segment
-    double x =
-      (segment[0].y-m_line[0].y)*(m_line[1].x-m_line[0].x) /
-      (m_line[1].y-m_line[0].y) +
-      m_line[0].x;
-    if (x < segment[0].x) return 0;
-    else return 1;
-  }
-}
-
 BOOL ON_LineCurve::GetLength(
 	double* length,               // length returned here
 	double fractional_tolerance,  // default = 1.0e-8
Index: opennurbs_string.cpp
===================================================================
--- opennurbs_string.cpp	(revision 32970)
+++ opennurbs_string.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -14,7 +13,6 @@
 ////////////////////////////////////////////////////////////////
 */
 
-// ASCII (single byte "char*" style) string
 #include "opennurbs.h"
 
 /////////////////////////////////////////////////////////////////////////////
Index: opennurbs_curve.h
===================================================================
--- opennurbs_curve.h	(revision 32970)
+++ opennurbs_curve.h	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -14,8 +13,6 @@
 ////////////////////////////////////////////////////////////////
 */
 
-#include <assert.h>
-
 ////////////////////////////////////////////////////////////////
 //
 //   Definition of virtual parametric curve
@@ -34,38 +31,8 @@
 
 ////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////
-class ON_Ray {
-public:
-  ON_3dPoint m_origin;
-  ON_3dVector m_dir;
 
-  ON_Ray(ON_3dPoint& origin, ON_3dVector& dir) : m_origin(origin), m_dir(dir) {}
-  ON_Ray(const ON_Ray& r) : m_origin(r.m_origin), m_dir(r.m_dir)  {}
-  ON_Ray& operator=(const ON_Ray& r) {
-    m_origin = r.m_origin;
-    m_dir = r.m_dir;
-    return *this;
-  }
 
-  ON_3dPoint PointAt(double t) const {
-    return m_origin + m_dir * t;
-  }
-
-  double DistanceTo(const ON_3dPoint& pt, double* out_t = NULL) const {
-    ON_3dVector w = pt - m_origin;
-    double c1 = w * m_dir;
-    if (c1 <= 0) return pt.DistanceTo(m_origin);
-    double c2 = m_dir * m_dir;
-    double b = c1 / c2;
-    ON_3dPoint p = m_dir * b + m_origin;
-    if (out_t != NULL) *out_t = b;
-    return p.DistanceTo(pt);
-  }
-};
-
-class Sample;
-
-
 typedef int (*ON_MassPropertiesCurve)( const ON_Curve&, void*, int, ON_3dPoint, ON_3dVector, ON_MassProperties&, bool, bool, bool, bool, double, double );
 
 class ON_CLASS ON_Curve : public ON_Geometry
@@ -883,37 +850,6 @@
 	  const ON_Interval* curveB_domain = 0
 	  ) const;
 
-  /**
-     Description:
-
-       Returns the number of 2D intersections of this curve
-       with the line defined by segment. Does not calculate actual
-       intersection points, so is faster than a general intersection
-       algorithm.
-
-     Parameters:
-
-       segment - [in] the segment to intersect with
-
-     Return:
-
-       number of intersections
-   */
-  virtual int NumIntersectionsWith(const ON_Line& segment) const;
-
-
-  /**
-     Description:
-
-     Return whether the given ray is close to the curve. The "close
-     to" relation is defined in terms of the distance between the
-     closest points on the curve and the ray... if this distance is
-     less than epsilon, then the ray is close to the edge.
-
-  */
-  virtual bool CloseTo(const ON_Ray& ray, double epsilon, Sample& closest) const;
-  virtual bool CloseTo(const ON_3dPoint& pt, double epsilon, Sample& closest) const;
-
   /*
   Description:
     Intersect this curve with surfaceB.
@@ -1605,40 +1541,4 @@
 	  );
 
 
-#define CLOSETO_CHORD_TOL 1e-1
-#define CLOSETO_DER_TOL 0.75 // the min value of the product of the dot products
-
-class Sample {
-public:
-  const ON_Curve* c;
-  ON_3dPoint pt;
-  ON_3dVector tangent;
-  double t;
-  double dist;
-  double ray_t;
-
-  Sample() {}
-
-  Sample(const ON_Curve* curve, double param) : c(curve), t(param), dist(0.0) {
-    c->Ev1Der(t, pt, tangent);
-    assert(tangent.Unitize());
-  }
-  Sample(const Sample& s) :
-    c(s.c), pt(s.pt), tangent(s.tangent), t(s.t), dist(s.dist) {}
-  Sample& operator=(const Sample& s) {
-    c = s.c;
-    pt = s.pt;
-    tangent = s.tangent;
-    t = s.t;
-    dist = s.dist;
-    return *this;
-  }
-
-  bool operator<(const Sample& s) {
-    //    return (ON_NearZero(dist-s.dist,ON_ZERO_TOLERANCE)) ? t < s.t : dist < s.dist;
-    return dist < s.dist;
-  }
-};
-
-
 #endif
Index: opennurbs_material.cpp
===================================================================
--- opennurbs_material.cpp	(revision 32970)
+++ opennurbs_material.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -3465,8 +3464,6 @@
   if ( vcnt < 3 || fcnt < 1 || vcnt != mesh.m_T.Count() )
     return;
 
-  ON_Workspace ws;
-
   // see if any texture coordinate adjustment is necessary
   const ON_TextureMapping::TYPE mapping_type = mapping.m_type;
   const bool bSphereCheck = ( ON_TextureMapping::sphere_mapping == mapping_type );
@@ -3479,6 +3476,7 @@
     return;
   }
 
+  ON_Workspace ws;
   int* quad = ws.GetIntMemory(vcnt); // ~ws will free quad memory
   float* Tx = (float*)ws.GetMemory(vcnt*sizeof(Tx[0]));
   float t;
Index: opennurbs_nurbscurve.cpp
===================================================================
--- opennurbs_nurbscurve.cpp	(revision 32970)
+++ opennurbs_nurbscurve.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -15,7 +14,6 @@
 */
 
 #include "opennurbs.h"
-#include <assert.h>
 
 ON_OBJECT_IMPLEMENT(ON_NurbsCurve,ON_Curve,"4ED7D4DD-E947-11d3-BFE5-0010830122F0");
 
@@ -274,8 +272,6 @@
     onfree(cv);
   if ( knot )
     onfree(knot);
-  if ( m_cached_bez )
-    delete [] m_cached_bez; // matches new in MakePiecewiseBezier
 }
 
 void ON_NurbsCurve::EmergencyDestroy()
@@ -295,7 +291,6 @@
   m_cv_stride = 0;
   m_cv_capacity = 0;
   m_cv = 0;
-  m_cached_bez = 0;
 }
 
 static void ON_NurbsCurveCopyHelper( const ON_NurbsCurve& src, ON_NurbsCurve& dest )
@@ -2057,31 +2052,12 @@
   return rc;
 }
 
+
 bool ON_NurbsCurve::HasBezierSpans() const
 {
   return ON_KnotVectorHasBezierSpans( m_order, m_cv_count, m_knot );
 }
 
-int ON_NurbsCurve::BezierSpanCount() const
-{
-  return m_cv_count-m_order+1;
-}
-
-bool ON_NurbsCurve::CopyBezierSpan(int span, ON_BezierCurve& b) {
-  bool rc = MakePiecewiseBezier();
-  if (rc && m_cached_bez != NULL) {
-    b = m_cached_bez[span];
-    return true;
-  }
-  else return false;
-}
-
-const ON_BezierCurve* ON_NurbsCurve::BezierSpan(int span) const
-{
-  if (m_cached_bez != NULL) return &m_cached_bez[span];
-  return NULL;
-}
-
 bool ON_NurbsCurve::MakePiecewiseBezier( bool bSetEndWeightsToOne )
 {
   bool rc = HasBezierSpans();
@@ -2156,53 +2132,7 @@
   return rc;
 }
 
-// XXX - Hack...
-bool ON_NurbsCurve::MakePiecewiseBezier(ON_BezierCurve* cache, bool bSetEndWeightsToOne) const
-{
-  bool rc = HasBezierSpans();
-  if ( !rc && IsValid() )
-  {
-    if ( !IsClamped(2) )
-      return false;
-    int span_count = SpanCount();
-    int cvdim = CVSize();
-    ON_BezierCurve* bez = cache; // fill in the cache
-    int ki, spani, i;
-    for ( ki = m_order-2, spani = 0; ki < m_cv_count-1 && spani < span_count; ki++ ) {
-      if ( m_knot[ki] < m_knot[ki+1] ) {
-	bez[spani].Create(m_dim,m_is_rat,m_order);
-	for ( i = 0; i < m_order; i++ )
-	  bez[spani].SetCV(  i, ON::intrinsic_point_style, CV( i + ki - m_order + 2 ) );
-	ON_ConvertNurbSpanToBezier( cvdim, bez[spani].m_order, bez[spani].m_cv_stride, bez[spani].m_cv,
-				    m_knot+ki-m_order+2, m_knot[ki], m_knot[ki+1] );
-	spani++;
-      }
-    }
-    rc = true;
-  }
-  return rc;
-}
 
-void ON_NurbsCurve::CacheBezierSpans() const {
-  if (m_cached_bez == NULL) {
-    ON_NurbsCurve copy(*this);
-    m_cached_bez = new ON_BezierCurve[SpanCount()];
-    bool rc = copy.MakePiecewiseBezier(m_cached_bez, false);
-    assert(rc);
-  }
-}
-
-// XXX - this is not (*&^(*&^% thread-safe
-int ON_NurbsCurve::NumIntersectionsWith(const ON_Line& segment) const {
-  ON_TRACE("ON_NurbsCurve::NumIntersectionsWith");
-  int xcount = 0;
-  for (int i = 0; i < BezierSpanCount(); i++) {
-    const ON_BezierCurve* b = BezierSpan(i);
-    xcount += b->NumIntersectionsWith(segment);
-  }
-  return xcount;
-}
-
 double ON_NurbsCurve::ControlPolygonLength() const
 {
   double length = 0.0;
Index: opennurbs_extensions.cpp
===================================================================
--- opennurbs_extensions.cpp	(revision 32970)
+++ opennurbs_extensions.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -15,8 +14,8 @@
 */
 
 #include "opennurbs.h"
-#include "opennurbs_extensions.h"
 
+
 #if defined(ON_DLL_EXPORTS)
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -1715,10 +1714,6 @@
       }
     }
     break;
-
-    default:
-      /* unsupported */
-      break;
   }
 
   return change_count;
Index: opennurbs_light.cpp
===================================================================
--- opennurbs_light.cpp	(revision 32970)
+++ opennurbs_light.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -357,7 +356,7 @@
   return m_style;
 }
 
-BOOL ON_Light::IsPointLight() const
+const BOOL ON_Light::IsPointLight() const
 {
   BOOL rc;
   switch(m_style)
@@ -374,7 +373,7 @@
   return rc;
 }
 
-BOOL ON_Light::IsDirectionalLight() const
+const BOOL ON_Light::IsDirectionalLight() const
 {
   BOOL rc;
   switch(m_style)
@@ -391,7 +390,7 @@
   return rc;
 }
 
-BOOL ON_Light::IsSpotLight() const
+const BOOL ON_Light::IsSpotLight() const
 {
   BOOL rc;
   switch(m_style)
@@ -408,7 +407,7 @@
   return rc;
 }
 
-BOOL ON_Light::IsLinearLight() const
+const BOOL ON_Light::IsLinearLight() const
 {
   BOOL rc;
   switch(m_style)
@@ -425,7 +424,7 @@
   return rc;
 }
 
-BOOL ON_Light::IsRectangularLight() const
+const BOOL ON_Light::IsRectangularLight() const
 {
   BOOL rc;
   switch(m_style)
Index: opennurbs_curve.cpp
===================================================================
--- opennurbs_curve.cpp	(revision 32970)
+++ opennurbs_curve.cpp	(working copy)
@@ -1,4 +1,3 @@
-/* $Header$ */
 /* $NoKeywords: $ */
 /*
 //
@@ -15,9 +14,6 @@
 */
 
 #include "opennurbs.h"
-#include <assert.h>
-#include <list>
-#include "opennurbs_ext.h"
 
 ON_VIRTUAL_OBJECT_IMPLEMENT(ON_Curve,ON_Geometry,"4ED7D4D7-E947-11d3-BFE5-0010830122F0");
 
@@ -3164,208 +3160,6 @@
 	return rc;
 }
 
-int
-ON_Curve::NumIntersectionsWith(const ON_Line& segment) const {
-  // XXX - todo - subclass responsibility (make pure virtual?)
-  ON_TextLog tl;
-  Dump(tl);
-  assert(false);
-
-  return 0;
-}
-
-
-bool
-isFlat(const Sample& p1, const Sample& m, const Sample& p2, double chord_tol, double der_tol)
-{
-  ON_Line line = ON_Line(p1.pt, p2.pt);
-  double chord = line.DistanceTo(m.pt);
-  double der = (p1.tangent * m.tangent) * (m.tangent * p2.tangent);
-  //  TRACE("isFlat " << der << "," << chord);
-  return (der >= der_tol) && (chord <= chord_tol);
-}
-
-double
-randomMidrange(double lo, double hi)
-{
-  assert(lo < hi);
-  //  TRACE("randomMidrange( " << lo << "," << hi << ")");
-#ifdef HAVE_DRAND48
-  double random_pos = drand48() * .1 + .45;
-#else
-  double random_pos = rand() * .1 / (RAND_MAX+1.) + .45;
-#endif
-  return random_pos * (hi - lo) + lo;
-}
-
-void
-sample(const ON_Curve* c,
-       Sample& s1,
-       Sample& s2,
-       std::list<Sample>& out_samples,
-       double chord_tol, double der_tol)
-{
-  Sample m(c, randomMidrange(s1.t,s2.t));
-  if (isFlat(s1,m,s2,chord_tol,der_tol)) {
-    out_samples.push_back(s2);
-  } else {
-    sample(c, s1, m, out_samples, chord_tol, der_tol);
-    sample(c, m, s2, out_samples, chord_tol, der_tol);
-  }
-}
-
-#define MAX_CLOSENESS_SEARCH_DEPTH 10
-
-Sample sample_arg_min(Sample& x, Sample& y, Sample& z) {
-  if (x.dist < y.dist) {
-    if (x.dist < z.dist) return x;
-    else return z;
-  } else {
-    if (y.dist < z.dist) return y;
-    else return z;
-  }
-}
-
-Sample
-search(const ON_Curve* c,
-       const ON_Ray& ray,
-       Sample& left,
-       Sample& right,
-       double dist_tol = 1e-10, int depth = 0)
-{
-  Sample m(c, (right.t-left.t) * 0.5 + left.t);
-  if (depth > MAX_CLOSENESS_SEARCH_DEPTH) return sample_arg_min(left, m, right);
-
-  m.dist = ray.DistanceTo(m.pt, &m.ray_t);
-  if (m.dist < dist_tol) return m;
-
-  Sample& side = (left.dist < right.dist) ? left : right;
-  if (side.t < m.t)
-    return search(c, ray, side, m, dist_tol, ++depth);
-  else
-    return search(c, ray, m, side, dist_tol, ++depth);
-}
-
-Sample
-search(const ON_Curve* c,
-       const ON_3dPoint& pt,
-       Sample& s1,
-       Sample& s2,
-       double dist_tol = 1e-10, int depth = 0)
-{
-  Sample left, right;
-  if (s1.t < s2.t) {
-    left = s1; right = s2;
-  } else {
-    left = s2; right = s1;
-  }
-  assert(left.t < right.t);
-  Sample m(c, (right.t-left.t) * 0.5 + left.t);
-  m.dist = pt.DistanceTo(m.pt);
-  TRACE1("\tdepth: " << depth << ", " << m.dist);
-  if (m.dist < dist_tol) {
-    TRACE1("return 1");
-    return m;
-  }
-  if (depth > MAX_CLOSENESS_SEARCH_DEPTH) {
-    TRACE1("hit max depth " << left.dist << ", " << m.dist << ", " << right.dist);
-    Sample min = sample_arg_min(left, m, right);
-    return min;
-  }
-
-  Sample side = (left.dist < right.dist) ? left : right;
-  if (side.t < m.t)
-    return search(c, pt, side, m, dist_tol, ++depth);
-  else
-    return search(c, pt, m, side, dist_tol, ++depth);
-}
-
-//--------------------------------------------------------------------------------
-//Generally calculate the shortest distance (binary search) between
-//the curve and the given ray and determine if it is within a distance
-//epsilon
-bool
-ON_Curve::CloseTo(const ON_3dPoint& pt, double epsilon, Sample& closest) const
-{
-  TRACE1("CloseTo(" << PT(pt) << ")");
-  std::list<Sample> samples;
-  ON_Interval dom = Domain();
-  Sample left(this, dom.Min());
-  Sample right(this, dom.Max());
-  samples.push_back(left);
-  double l;
-  GetLength(&l);
-  double tol = (l < 1) ? CLOSETO_CHORD_TOL : CLOSETO_CHORD_TOL * l;
-  sample(this, left, right, samples, tol, CLOSETO_DER_TOL);
-
-  assert(samples.size() >= 2);
-
-  for (std::list<Sample>::iterator i1 = samples.begin(); i1 != samples.end(); ++i1) {
-    i1->dist = pt.DistanceTo(i1->pt);
-  }
-  samples.sort();
-  // after sorting, we have the closest 2 sampled points, which
-  // *should* bound the closest point.
-
-  // use these to find the closest point through a 'binary' search
-  std::list<Sample>::iterator i2 = samples.begin();
-  Sample s1 = samples.front(); samples.pop_front();
-  Sample s2 = samples.front();
-
-//   return samples.front().dist < epsilon;
-
-  closest.dist = real.infinity();
-  if (s1.dist < epsilon) {
-    closest = s1;
-    TRACE1("1:" << s1.dist << " < " << epsilon);
-    return true;
-  }
-
-  Sample blah = search(this, pt, s1, s2);
-  TRACE1("blah: " << blah.dist);
-  closest = blah;
-//   Sample m(this, (s2.t-s1.t) * 0.5 + s1.t);
-//   return pt.DistanceTo(m.pt) < epsilon;
-  TRACE1("2:" << closest.dist << " < " << epsilon);
-  return closest.dist < epsilon;
-}
-
-
-//--------------------------------------------------------------------------------
-//Generally calculate the shortest distance (binary search) between
-//the curve and the given ray and determine if it is within a distance
-//epsilon
-bool
-ON_Curve::CloseTo(const ON_Ray& ray, double epsilon, Sample& closest) const
-{
-  std::list<Sample> samples;
-  ON_Interval dom = Domain();
-  Sample left(this, dom.Min());
-  Sample right(this, dom.Max());
-  samples.push_back(left);
-  double l;
-  GetLength(&l);
-  double tol = (l < 1) ? CLOSETO_CHORD_TOL : CLOSETO_CHORD_TOL * l;
-  sample(this, left, right, samples, tol, CLOSETO_DER_TOL);
-
-  for (std::list<Sample>::iterator i1 = samples.begin(); i1 != samples.end(); ++i1) {
-    i1->dist = ray.DistanceTo(i1->pt, &i1->ray_t);
-  }
-  samples.sort();
-  // after sorting, we have the closest 2 sampled points, which
-  // *should* bound the closest point.
-
-  // use these to find the closest point through a 'binary' search
-  std::list<Sample>::iterator i2 = samples.begin();
-  Sample s1 = *i2;
-  Sample s2 = *++i2;
-  if (s1.dist < epsilon) return true;
-  closest = search(this, ray, s1, s2, epsilon);
-
-  return closest.dist < epsilon;
-}
-
-
 bool ON_SortLines( 
 	int line_count, 
 	const ON_Line* line_list, 
