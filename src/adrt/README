Info:
=====
ADRT consists of several libraries and tools including the Realistic
Image Synthesis Engine (RISE) and ISST (Interactive Shot Selection
Tool).  These tools consist of three binaries: a master, an observer,
and a slave.  To generate a framework that RISE can use, look at the
g-adrt converter.  g-adrt takes a .g file containing bots and creates an
ADRT framework.

Since RISE is used for generating images, the observer is only supplied
to check up on the images progress, which is especially useful for time
consuming renderings.

Running configure with --enable-optimized is very important as it will
affect performance by almost doubling it.

To learn more about how the structure of a project file and what
geometry files you can feed to isst or rise please check the doc
directory.

For additional help please check out the #brlcad channel on IRC (freenode).


Usage:
======
Method 1 - Manually Connecting Compute Nodes:
Step 1.
  isst_master /path/to/project.env

Step 2.
  isst_observer master.host.name

Step 3.
  isst_slave master.host.name

Step 4.
  repeat step 3 on all slave nodes.


Method 2 - Connecting to Slave Daemons:
Step 1.
  login to each compute node and run isst_slave& (background process).

Step 2.
  isst_master -l slaves.txt /path/to/project.env
  (slaves.txt contains each slave hostname per line).

Step 3.
  isst_observer master.host.name

==============================================================================

Developer notes:
================

== libtie ==

rtcmp has a practical example of using this lib

tie_init() to initialize the struct
tie_push() adds a region
tie_prep() generates the KD-tree and gets everything compiled for evl
tie_work() invokes a callback system to actually shoot rays
tie_free() is cleanup

== libtienet ==

this will probably be radically redone to use libpkg, if not completely
eliminated.

Packets contain:
	16 bit opcode
	32 bit length
	data

data may or may not be compressed (compile time defined, not runtime
negotiated). compression is standard zlib. Only result data gets
compressed. Consumer programs have to 'just know' which variant is built.

main loops seem to reside in here, with seperate modules for both slave and
master. 'fcb' gets a buffer holding both length and raw data to do the work.

master defines use endian based on masters endian (opposed to ntoh/hton)

slave nodes are stored in a double linked list. When new work is requested
of the master, it does a linear search of the linked list for the first
idle slave in a round robin fashion.

master keeps both a socket list (possibly active sockets) and a dead
socket list (to be pruned... eventually? O.o)
