'\" t
.\"     Title: libfb - FrameBuffer Library
.\"    Author: BRL-CAD Team
.\" Generator: DocBook XSL-NS Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 04/03/2012
.\"    Manual: BRL-CAD Libraries
.\"    Source: BRL-CAD
.\"  Language: English
.\"
.TH "LIBFB \- FRAMEBUFFER" "3" "04/03/2012" "BRL\-CAD" "BRL\-CAD Libraries"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
libfb \- multiple device, generic frame buffer library
.SH "GENERIC FRAME BUFFER ROUTINES"
.HP \w'FBIO\ *fb_open('u
.BI "FBIO *fb_open(*\ " "fbfile" ", int\ fb_close\ (\ fbp\ )\ FBIO\ *\ " "fbp" ", int\ fb_read\ (\ fbp\ ,\ x\ ,\ y\ ,\ addr\ ,\ count\ )\ FBIO\ *\ " "fbp" ");"
.sp
.if n \{\
.RS 4
.\}
.ft B
.nf
    RGBpixel *addr;
    long count;
    
  
.fi
.ft
.if n \{\
.RE
.\}
.HP \w'int\ fb_write('u
.BI "int fb_write(*\ " "fbp" ", RGBpixel\ *\ " "addr" ", long\ " "count" ", int\ fb_rmap\ (\ fbp\ ,\ cmap\ )\ FBIO\ *\ " "fbp" ", ColorMap\ *\ " "cmap" ");"
.HP \w'int\ fb_wmap('u
.BI "int fb_wmap(*\ " "fbp" ", ColorMap\ *\ " "cmap" ");"
.HP \w'int\ fb_clear('u
.BI "int fb_clear(*\ " "fbp" ", RGBpixel\ *\ " "colorp" ");"
.HP \w'char\ *fb_gettype('u
.BI "char *fb_gettype(*\ " "fbp" ");"
.HP \w'int\ fb_getwidth('u
.BI "int fb_getwidth(*\ " "fbp" ");"
.HP \w'int\ fb_getheight('u
.BI "int fb_getheight(*\ " "fbp" ");"
.SH "HARDWARE SPECIFIC FRAME BUFFER ROUTINES"
.HP \w'int\ fb_cursor('u
.BI "int fb_cursor(*\ " "fbp" ", int\ fb_scursor\ (\ fbp\ ,\ mode\ ,\ x\ ,\ y\ )\ FBIO\ *\ " "fbp" ", int\ fb_setcursor\ (\ fbp\ ,\ bits\ ,\ xbits\ ,\ ybits\ ,\ xorig\ ,\ yorig\ )\ FBIO\ *\ " "fbp" ", unsigned\ char\ " "bits" "[]);"
.sp
.if n \{\
.RS 4
.\}
.ft B
.nf
    int xbits, ybits;
    int xorig, yorig;
    
  
.fi
.ft
.if n \{\
.RE
.\}
.HP \w'int\ fb_window('u
.BI "int fb_window(*\ " "fbp" ", int\ fb_zoom\ (\ fbp\ ,\ x\ ,\ y\ )\ FBIO\ *\ " "fbp" ", /\ *Buffered\ frame\ buffer\ I/O:\ */\ int\ fb_ioinit\ (\ fbp\ )\ FBIO\ *\ " "fbp" ");"
.HP \w'int\ fb_seek('u
.BI "int fb_seek(*\ " "fbp" ", void\ fb_tell\ (\ fbp\ ,\ xp\ ,\ yp\ )\ FBIO\ *\ " "fbp" ", int\ *xp\ ,\ *\ " "yp" ");"
.HP \w'int\ fb_rpixel('u
.BI "int fb_rpixel(*\ " "fbp" ", RGBpixel\ *\ " "pixelp" ");"
.HP \w'int\ fb_wpixel('u
.BI "int fb_wpixel(*\ " "fbp" ", RGBpixel\ *\ " "pixelp" ");"
.HP \w'int\ fb_flush('u
.BI "int fb_flush(*\ " "fbp" ");"
.HP \w'void\ fb_log('u
.BI "void fb_log(format\ [\ " "" ", arg\ ]\ \&.\&.\&.\ " "" ");"
.SH "DESCRIPTION"
.PP
These routines are designed to provide a device\-independent method of using frame buffers or files containing frame buffer images\&. The coordinate system used is first\-quadrant (0\&.\&.width\-1, 0\&.\&.height\-1), with integer addressing\&. Translation to hardware coordinate systems is handled by the library\&.
.PP
This version of the library assumes that red, green, and blue intensities are described by unsigned 8\-bit bytes in the range (0\&.\&.255)\&. The library interface uses arrays of
\fBRGBpixel\fRs, which is a typedef for an array of three unsigned chars (this was done to avoid structure padding)\&. Note that a pointer to an
\fBRGBpixel\fR
is thus the name of the
\fBRGBpixel\fR
itself, i\&.e\&. no ampersand is needed\&.
.PP
The exact interpretation of color maps tends to be somewhat device specific\&. The three ColorMap arrays each have 256 entries of unsigned 16\-bit values\&. In order to accomodate color maps with differing amounts of output resolution, the color map entries are fixed\-point fractions in the range (0\&.0\&.\&.1\&.0)\&. In integer notation, the range is (0\&.\&.65525)\&. For devices with less than 16 bits of output from their color maps, the left\-most portion of each entry is used\&.
.PP

\fIFb_open\fR
is used to open a frame buffer file
\fIfbfile\fR\&. The file may be either the name of a supported frame buffer interface, referenced as "/dev/interface", or the name of a UNIX file\&. The routine will try to determine if the file opened was a real frame buffer by examining the name, and if so will perform whatever initialization actions are necessary\&. If the value of
\fIfbfile\fR
is

NULL
and the environment variable

\fBFB_FILE\fR
is set, then the value of
\fBFB_FILE\fR
is used; otherwise the default frame buffer device for the system is used\&. See below for more details\&. The
\fIwidth\fR
and
\fIheight\fR
parameters specify the initial size of display desired\&. If these are zero the default sizes for that device will be used\&. On a successful open, the frame buffer I/O (FBIO) structure pointer is returned\&. This structure contains size you were actually given, as well as the maximum possible size for the selected device\&. A return of FBIO_NULL indicates failure\&.
.PP

\fIFb_close\fR
simply closes the frame buffer\&.
.PP

\fIFb_read\fR
reads
\fIcount\fR
pixels from the frame buffer starting at the location specified by
\fIx\fR
and
\fIy\fR, and places them at program memory address specified by
\fIaddr\fR\&.
\fIFb_read\fR
returns the number of pixels actually read, or \-1 on error\&.
.PP

\fIFb_write\fR
writes
\fIcount\fR
pixels from program address
\fIaddr\fR
into the frame buffer starting at the location specified by
\fIx\fR
and
\fIy\fR\&.
\fIFb_write\fR
returns the number of pixels actually written, or \-1 on error\&.
.PP

\fIFb_rmap\fR
reads in the color map from the frame buffer and leaves at the location pointed to by
\fIcmap\fR\&.
.PP

\fIFb_wmap\fR
writes the color map pointed to by
\fIcmap\fR
into the frame buffer\&. If the value of
\fIcmap\fR
is

NULL
then a linear color map is used as the default\&.
.PP

\fIFb_clear\fR
erases the frame buffer by setting all pixels to the given color\&. If the color pointer is NULL, black will be used\&. On a UNIX file, this entails writing the entire file, which is an expensive operation, whereas on most frame buffer displays this can be done in less than a second by a special command\&.
.PP

\fIFb_gettype\fR
returns a pointer to a string describing the frame buffer specified by the FBIO pointer\&.
.PP

\fIFb_getwidth\fR
and
\fIFb_getheight\fR
returns the current size of the FBIO frame buffer\&.
.PP
The following routines work in conjunction with those described above to provide functions which only apply if the frame buffer file is actually a hardware frame buffer display\&.
.PP

\fIFb_cursor\fR
places the cursor at the image space coordinates given by
\fIx\fR
and
\fIy\fR\&. If the mode is non\-zero, the cursor is made visible, and if mode is zero, the cursor is turned off\&.
.PP

\fIFb_scursor\fR
is the same as
\fIfb_cursor\fR
except that it places the cursor at the
\fBscreen\fR
space coordinates given by
\fIx\fR
and
\fIy\fR\&.
.PP

\fIFb_setcursor\fR
allows the user to set the bitmap used to represent the cursor, thereby changing the cursor shape\&. This is not necessarily supported by all hardware\&. The argument
\fIbits\fR
is a pointer to an array of unsigned chars containing the bits of the cursor\&. The arguments
\fIxbits\fR
and
\fIybits\fR
specify the size of the cursor bitmap\&. The number of bytes in the
\fIbits\fR
array will be the width rounded up to a mutiple of eight (so that the cursor "scanlines" are byte aligned) times the height\&.
\fIbits\fR[0] is the lower left corner,
\fIbits\fR[1] is to the right of it, etc\&. The next line of the
\fIbits\fR
array goes above the current one\&. Within a byte the most significant bit is the leftmost\&. The values
\fIxorig\fR
and
\fIyorig\fR
specify which bit in the bitmap actually gets placed at the location specified in the cursor move routines\&. Again, a first quadrant coordinate system is used\&.
.PP

\fIFb_window\fR
sets the frame buffer window center position to the image space coordinates given by
\fIx\fR
and
\fIy\fR\&. This command is usually used in conjunction with the
\fIfb_zoom\fR
routine\&.
.PP

\fIFb_zoom\fR
sets the zoom factor for the X coordinate to
\fIx\fR
and the zoom factor for the Y coordinate to
\fIy\fR\&. Zooming is generally done by pixel replication in hardware\&.
.PP
The following routines work in conjunction with those described above to provide buffered reading and writing of frame buffer images either to a real frame buffer or a UNIX file\&. The routines use a simple paging strategy to hold \(lqbands\(rq of the image in core\&. Since horizontal bands are buffered, the ideal motion is to scan left to right, then bottom to top\&.
.PP

\fIFb_ioinit\fR
should be called before using any of the other buffered I/O routines and repeated whenever the frame buffer is reopened\&.
.PP

\fIFb_seek\fR
is used to position the current read/write pointer to the location to the next position to be read or written\&. It is not necessary to do a
\fIfb_seek\fR
after every read or write since both
\fIfb_rpixel\fR
and
\fIfb_wpixel\fR
imply an automatic move to the next pixel\&. If you read or write the last pixel on a scan line, the pointer will automatically move to the beginning of the following scan line\&.
.PP

\fIFb_tell\fR
returns the current location of the read write pointer in terms of (X,Y) coordinates on the frame buffer\&. The X and Y values are returned into the integers pointed to by
\fIxp\fR
and
\fIyp\fR\&.
.PP

\fIFb_rpixel\fR
reads the pixel at the current frame buffer location and returns it into the location specifed by
\fIpixelp\fR\&.
.PP

\fIFb_wpixel\fR
writes the pixel pointed to by
\fIpixelp\fR
at the current frame buffer location\&.
.PP

\fIFb_flush\fR
caused any current buffered frame buffer pages to be written out\&. Unnecessary writes are avoided by the use of page reference bits\&.
.PP
The following is a printing routine which this library uses to indicate errors\&.
.PP

\fIFb_log\fR
will convert, format and print its
\fIargs\fR
under control of
\fIformat\fR
to the standard error output\&. For more detailed information on the specification of the control string, see
\fBprintf\fR(3S)\&. This function may be supplied by the application if different behavior is desired\&.
.SH "FB_FILE DEVICES"
.PP
The following devices are supported by the library; not all may be available on any given system\&. New device support can be incorporated by the addition of a single module to the library\&.
.PP
/dev/debug\fI[num]\fR
.RS 4
The "/dev/debug" interface prints one line to logs each call to the frame buffer library\&.

\fInum\fR
is a bitvector indicating the levels of verbosity of the output\&. See
\fBfb\&.h\fR
for the bit definitions\&.
.RE
.PP
\fIfilename\fR
.RS 4
Disk file interface
.RE
.PP
\fBhostname:\fR\fI[devicename]\fR
.RS 4
TCP\-based network links to a remote framebuffer, where
\fIdevicename\fR
is any from this list, for example, fictitious\&.brlcad\&.org:/dev/ik0 or fictitious\&.brlcad\&.org:/dev/sgi\&. A
\fBhostname\fR
with a null\fIdevicename\fR
will select the default display device on that host\&. If explicitly specifying a remote device, be careful not to omit the colon between the host and device name, or you will be specifying a local disk file as the result\&. Note that for security reasons, it is not permitted to access a disk file via the remote interface\&.
.RE
.SH "EXAMPLES"
.PP

\fILibfb\fR
can be loaded with any C program:
.sp
.if n \{\
.RS 4
.\}
.nf
.sp
.if n \{\
.RS 4
.\}
.nf
$  /bin/cc  program\&.c  \-lfb \-l\e<system\-library\&.\&.\&.\e>
.fi
.if n \{\
.RE
.\}
.sp

  
.fi
.if n \{\
.RE
.\}
.PP
where
\fI<system\-library>\fR
denotes specific libraries necesary on a particular machine\&. All machines with networking will require the "\-lpkg" option\&. Machines which support the X Windows(tm) system will require the "\-lX11" option\&.
.SH "RETURN VALUES"
.PP

\fIfb_close\fR,
\fIfb_write\fR,
\fIfb_read\fR,
\fIfb_wmap\fR,
\fIfb_rmap\fR,
\fIfb_clear\fR,
\fIfb_cursor\fR,
\fIfb_scursor\fR,
\fIfb_setcursor\fR,
\fIfb_window\fR,
\fIfb_zoom\fR,
\fIfb_ioinit\fR,
\fIfb_seek\fR,
\fIfb_wpixel\fR,
\fIfb_rpixel\fR
and
\fIfb_flush\fR
return \-1 to indicate failure\&.
\fIFb_open\fR
returns FBIO_NULL to indicate failure, and a non\-null FBIO structure pointer upon success\&.
\fIfb_read\fR, and
\fIfb_write\fR
return the number of pixels actually read or written\&.
\fIfb_gettype\fR
returns a pointer to a NULL terminated description string\&.
.SH "SEE ALSO"
.PP
\fBfbhelp\fR(1),
\fBbrlcad\fR(1)\&.
.SH "BUG REPORTS"
.PP
Reports of bugs or problems should be submitted via electronic mail to <devs@brlcad\&.org>, or via the "cadbug\&.sh" script\&.
.SH "AUTHOR"
.PP
\fBBRL\-CAD Team\fR
