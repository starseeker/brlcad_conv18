<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../resources/standard/dtd/docbookx.dtd">

<book xmlns:xi="http://www.w3.org/2001/XInclude">
  <bookinfo>
    <title><application>BRL-CAD</application> Tutorial Series: Volume II - Introduction to MGED</title>
    <authorgroup>
      <author>
	<firstname>Lee</firstname>
	<surname>Butler</surname>
	<othername role='mi'>A</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Eric</firstname>
	<surname>Edwards</surname>
	<othername role='mi'>W</othername>
	<affiliation>
	  <shortaffil>SURVICE</shortaffil>
	  <orgname>SURVICE Engineering Company</orgname>
	  <address>
	    <street>4695 Millennium Drive</street>
	    <city>Belcamp</city>
	    <state>MD</state> 
	    <postcode>21017-1505</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Betty</firstname>
	<surname>Schueler</surname>
	<othername role='mi'>J</othername>
	<affiliation>
	  <shortaffil>QRI</shortaffil>
	  <orgname>Quantum Research International, Inc.</orgname>
	  <address>
	    <street>2014 Tollgate Rd, Suite 203</street>
	    <city>Bel Air</city>
	    <state>MD</state> 
	    <postcode>21014</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Robert</firstname>
	<surname>Parker</surname>
	<othername role='mi'>G</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Anderson</surname>
	<othername role='mi'>R</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
    
    <publishername>Army Research Laboratory</publishername>
    <pubsnumber>ARL-SR-102</pubsnumber>
    <pubdate>April 2001</pubdate>
    
    <legalnotice>
      <para>Approved for public release; distribution is unlimited</para>
      
      <para>The findings in this report are not to be construed as an
      official Department of the Army position unless so designated 
      by other authorized documents.</para>
      
      <para>Citation of manufacturer's or trade names does not constitute
      an official endorsement or approval of the use thereof.</para>
      
      <para>Destroy this report when it is no longer needed. Do not return
      it to the originator.</para>
    </legalnotice>      
    
    <abstract>
      <para>
	Since 1979, the U.S. Army Research Laboratory has been developing and
	distributing the <application>BRL-CAD</application> constructive solid geometry (CSG) modeling
	package for a wide range of military and industrial applications. The
	package includes a large collection of tools and utilities including an
	interactive geometry editor, ray-tracing and generic framebuffer
	libraries, a network-distributed image-processing and signal-processing
	capability, and an embedded scripting language.
      </para>
      
      <para>
	As part of this effort, a multivolume tutorial series is being developed
	to assist users in the many features of the <application>BRL-CAD</application> package. The
	"Introduction to <application>MGED</application>," which is the second volume in the series, is
	intended to provide new users with a basic understanding of the
	<application>Multi-Device Geometry Editor</application> (<application>MGED</application>), 
	which is the heart of <application>BRL-CAD</application>. Other
	volumes focus on installation procedures, advanced features, and
	programming.
      </para>
    </abstract>
  </bookinfo>

  <preface>
    <title>Preface</title>
    <para>
      Since 1979, the U.S. Army Research Laboratory (formerly the Ballistic
      Research Laboratory) has been developing the <application>BRL-CAD</application> constructive solid
      geometry (CSG) modeling package for a wide range of military and
      industrial applications. The strength of the package lies in its ability
      to build realistic models of complex objects from a relatively small set
      of "primitive shapes" by employing the basic Boolean operations of union,
      subtraction, and intersection and by assigning real-world material
      attributes.
    </para>
    
    <para>
      The package comprises a large collection of tools, utilities, and
      libraries including an interactive geometry editor, ray-tracing and
      generic framebuffer libraries, a network-distributed image-processing and
      signal-processing capability, and an embedded scripting language.
    </para>
    
    <para>
      Although <application>BRL-CAD</application> has continued to mature in performance and utility,
      developers have strived to keep the package approachable and easy to use,
      as evidenced by the package's dual command formats, its newly renovated
      graphical user interface (GUI), and its customization potential through
      user scripting.
    </para>
    
    <para>
      In addition, a multivolume tutorial series is being developed to assist
      users in a variety of <application>BRL-CAD</application> areas and applications. The "Introduction to
      <application>MGED</application>," which is the second volume in the series, is intended to provide
      new users with a basic understanding of the <application>Multi-Device Geometry Editor</application>
      (<application>MGED</application>), which is the heart of the <application>BRL-CAD</application> package. Other volumes focus on
      installation procedures, advanced features, and programming.
    </para>
  </preface>
  
  <preface>
    <title>Acknowledgements</title>
    <para>
      The authors would like to thank Paul Tanenbaum, TraNese Christy, Sean
      Morrison, and the other members of the Advanced Computer Systems Team who
      reviewed this document in a timely manner and made many helpful
      suggestions to improve its accuracy and presentation.
    </para>
    
    <para>
      In addition, the authors would like to acknowledge team member Mike Muuss,
      who passed away while this volume was in preparation. Mike was the
      original architect of the <application>BRL-CAD</application> package and guided its development for
      20 years until his death on 20 November 2000. He embodied a unique blend
      of unparalleled intellect, unquenchable curiosity, and unending energy to
      advance the capabilities of everything and everyone he touched. A
      natural-born troubleshooter, Mike approached every job, big or small, with
      a passion for excellence and a child-like enthusiasm, which helped drive
      <application>BRL-CAD</application> far beyond expectations.
    </para>
    
    <para>
      Although he never got a chance to review this document, much of this work
      is a result of his vision and attention to detail. Therefore, the <application>BRL-CAD</application>
      Tutorial Series is dedicated to his memory. His sharp mind, his warm
      spirit, and his loyal friendship will be greatly missed.
    </para>
  </preface>

  <chapter id="Lesson-1">
    <title>Creating Primitive Shapes</title>
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="creating_primitive_shapes_overviewlist"/>
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="launching_mged"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="entering_commands"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="using_gui"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="open_new_database"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="create_new_database"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="assign_title"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="set_units"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="select_primitive"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="create_sphere_cmd_line"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="clear_window"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="draw_object"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="erase_from_window"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="create_sphere_gui"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="view_params"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="list_db_contents"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="kill_object"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="editing_commands"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="quitting"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="creating_primitive_shapes_review"/> 
  </chapter> 

  <chapter id="Lesson-2">
    <title>Learning the Viewing Options</title>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_overviewlist"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_intropara1"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_intropara2"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="creating_radio"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="locating_viewing_info_cmd_window"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="viewing_system_elements"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="coord_sys_summary"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="view_radio_angles"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="shift_grips"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_review"/>
  </chapter>
  
  <chapter id="Lesson-3">
    <title>Using the Insert Command to Size and Place Shapes</title>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_overviewlist"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_intropara1"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="new_db_myShapes"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="sphere_make"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_in"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="args_on_one_line"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="command_combined_in"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="mged_naming_conventions"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="view_shapes"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_quit"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_review"/>
  </chapter>

  <chapter id="Lesson-4">
    <title>Assigning Material Properties and Raytracing</title>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assigning_material_properties_and_raytracing_overviewlist"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assigning_material_properties_and_raytracing_opendb"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="create_region"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assign_material_prop"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="clear_window_new_region"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="raytrace_model"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="layers_graphics_window"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="clear_graphics_window"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assigning_material_properties_and_raytracing_review"/>
  </chapter>

  <chapter id="Lesson-5">
    <title>Lesson 5: Learning About Boolean Expressions</title>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="learning_boolean_expressions_overviewlist"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="boolean_tools"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="boolean_operations"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="making_regions_bool_ops"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="operator_precedence"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="learning_boolean_operations_review"/>
  </chapter>

  <chapter id="Lesson-6">
    <title>Creating a Goblet</title>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="creating_a_goblet_overviewlist"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="creating_a_goblet_intro"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="goblet_new_database"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="create_edit_copy_goblet"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="making_goblet_regions"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="making_goblet_region_comb"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="goblet_view_data_tree"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="raytracing_goblet"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="creating_goblet_review"/>
  </chapter>
  
  <chapter id="Lesson-7">
    <title>Assigning Material Properties to Your Goblet</title>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_material_properties_overviewlist"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_material_properties_intro1"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_review_opening_db"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_assign_colors"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_transparency_mirror"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_newforms_raytrace"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_material_properties_review"/>
  </chapter>

  <chapter id="Lesson-8">
    <title>Assigning More Material Properties to Your Goblet</title>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_overviewlist"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro1"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro2"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro3"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro4"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_specular_diffuse"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_refractive_index"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_shininess"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_extinction"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_emission"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_shader_attributes"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_review"/>
 </chapter>

  <chapter id="Lesson-9">
    <title>Creating a Globe in a Display Box</title>
    <para>
      In previous lessons, you combined various shapes into new objects. These
      new objects have been created using solid building blocks, much like those
      used in a wooden toy truck. However, in real life, most of the objects
      that you will design will consist of an outside shell and various inside
      parts.
    </para>
    
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_in_display_overviewlist"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_in_display_newdb"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_create_display_box"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="create_globe_in_box"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_assign_mater_prop"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_move_rotate"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_use_color_tool"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_in_display_box_review"/>
  </chapter>
  
  <chapter id="Lesson-10">
    <title>Creating a Mug</title>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="creating_mug_overviewlist"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="creating_mug_intro1"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_new_db"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_outside_cyl"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_inside_cyl"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_handle"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_comb1"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_comb2"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_region"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_review"/>
  </chapter>

  <chapter id="Lesson-11">
    <title>Refining the Mug</title>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="refining_mug_overviewlist"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="refining_mug_intro1"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_mater_prop_mater_cmd"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_raytrace1"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_refining"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_torus_cup_combine"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="refining_mug_review"/>
  </chapter>

  <chapter id="Lesson-12">
    <title>Creating the Mug Through the GUI</title>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_overviewlist"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_intro1"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_intro2"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_body"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_handle"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_rim"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_combinations"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_make_region"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_check_tree"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_comb_edit_props"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_raytracing"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_review"/>
  </chapter>
 
  <chapter id="lesson-13">
    <title>Placing Shapes in 3-D Space</title>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_overviewlist"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_intro1"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_intro2"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_intro3"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_tabletop"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_base"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_candle"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_flame"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_combination"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_check_data_tree"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_assign_mater_prop"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_raytrace"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_review"/>
  </chapter>

  <chapter id="lesson-14">
    <title>Gaining More Practice Placing Shapes in Space</title>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_overviewlist"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_intro1"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_intro2"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="candle_base_1st_sphere"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="draw_grid_feature"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="multipane_feature"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="copies_of_shapes"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="practice_make_regions_spheres"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="candle_base_spheres_combine"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_review"/>
  </chapter>

  <chapter id="lesson-15">
    <title>Creating a Toy Truck</title>
    <para>
      In this lesson, you will:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Create a toy truck from three shapes.</para>
	</listitem>
	<listitem>
	  <para>Make copies of shapes using the Primitive Editor.</para>
	</listitem>
	<listitem>
	  <para>Make combinations and regions of a more complex object.</para>
	</listitem>
	<listitem>
	  <para>Check the data tree for accuracy.</para>
	</listitem>
	<listitem>
	  <para>List contents of the database.</para>
	</listitem>
	<listitem>
	  <para>Assign material properties using the Combination Editor.</para>
	</listitem>
	<listitem>
	  <para>Identify the difference between OK, Accept, Apply, Reset, Cancel, and Dismiss.</para>
	</listitem>
	<listitem>
	  <para>Identify the on-screen help option.</para>
	</listitem>
	<listitem>
	  <para>Identify the stacker option.</para>
	</listitem>
	<listitem>
	  <para>Experiment with the attributes of the camo shader.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      In previous lessons, you created and edited shapes to produce simple
      objects. This lesson focuses on creating a slightly more complex object, a
      toy truck, from the Command Window. Your completed truck should look
      similar to the following truck:
      
      <figure>
	<title>Raytraced Toy Truck Design</title>
	<screenshot>
	  <graphic fileref=".png"/>
	</screenshot>
      </figure>

    </para>
    <para>
      Begin by creating a new database called truck.g.
    </para>
    <sect1>
      <title>Creating an rpp for the Cab of the Truck Using the In Command</title>
      <para>
	To make the cab of the truck, you will create a right parallel piped using
	the in (insert) command. At the Command Window prompt, type:
	
	<command>in cab1.s rpp[Enter]</command>
	
	<application>MGED</application> will ask you to enter values for XMIN, XMAX, YMIN, YMAX, ZMIN, and
	ZMAX. Type at the prompt:
	
	<command>0 1 0 1 0 1[Enter]</command>
	
	This will tell <application>MGED</application> to:
	<informaltable>
	  <tgroup cols='6'>
	    <tbody>
	      <row>
		<entry>0</entry>
		<entry>1</entry>
		<entry>0</entry>
		<entry>1</entry>
		<entry>0</entry>
		<entry>1</entry>
	      </row>
	      <row>
		<entry>Make the value of the rpp's XMIN 0</entry>
		<entry>Make the value of the rpp's XMAX 1</entry>
		<entry>Make the value of the rpp's YMIN 0</entry>
		<entry>Make the value of the rpp's YMAX 1</entry>
		<entry>Make the value of the rpp's ZMIN 0</entry>
		<entry>Make the value of the rpp's ZMAX 1</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	You could also have used the streamlined version of:
	
	<command>in cab1.s rpp 0 1 0 1 0 1[Enter]</command>
	
	A cube shape should appear in the Graphics Window, as follows:
	
	<figure>
	  <title>Wireframe Representation of Shape cab1.s</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

      </para>
    </sect1>
    <sect1>
      <title>Using the Inside Command to Create an rpp for the Hood of the Cab</title>
      <para>
	To make the hood of the cab, you will need to make another rpp shape, this
	time using the inside command. This special command was originally created
	to hollow out objects such as gas tanks and boxes; however, it can be used
	to create any new shape that has some relationship to a pre-existing
	shape. In this lesson, it is used to cut away material above the hood and
	in front of the cab.
      </para>
      <para>
	If you are using <application>BRL-CAD</application> version 6.0 or later, at the Command Window
	prompt, type:
	
	<command>inside cab1.s caboff1.s .5 -.1 .7 -.1 -.1 -.1[Enter]</command>
	
	The inside command tells <application>MGED</application> to:
	<informaltable>
	  <tgroup cols='9'>
	    <tbody>
	      <row>
		<entry>inside</entry>
		<entry>cab1.s</entry>
		<entry>caboff1.s</entry>
		<entry>.5</entry>
		<entry>-.1</entry>
		<entry>7</entry>
		<entry>-.1</entry>
		<entry>-.1</entry>
		<entry>-.1</entry>
	      </row>
	      <row>
		<entry>Inside the shape</entry>
		<entry>named cab1.s,</entry>
		<entry>create rpp called caboff1.s</entry>
		<entry>Make face 1234 (bottom) .5 units thick</entry>
		<entry>Make face 5678 (top) -.1 units thick</entry>
		<entry>Make face 1485 (rear) .7 units thick</entry>
		<entry>Make face 2376 (front) -.1 units thick</entry>
		<entry>Make face 1265 (right) -.1 units thick</entry>
		<entry>Make face 3478 (left) -.1 units thick</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
      </para>
      <note>
	<para>
	  In this example, each negative thickness number indicates that
	  caboff1.s will protrude through the corresponding face of cab1.s.
	</para>
      </note>
      <note>
	<para>
	  Note that in <application>BRL-CAD</application> versions 6.0 and later, the faces of an rpp are  
	  numbered in a different order than in previous versions. So, if you   
	  are using a pre-6.0 release of the package, the following parameter   
	  order must be used for the aforementioned inside command:             
	  
	  <command>inside cab1.s caboff1.s -.1 .7 -.1 -.1 .5 -.1[Enter]</command>
	  
	  (The order of faces in this case is front, rear, right, left, bottom, 
	  top instead of that specified for versions 6.0 and later.)            
	</para>
      </note>
     
      <para>
	When in Multipane mode, the design should resemble the following
	illustration.
	
	<figure>
	  <title>Truck Cab with Cutoff</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Using an rcc to Create a Wheel Well in the Cab</title>
      <para>
	Make a cylinder (rcc) to use for cutting away a space for the first wheel
	of the cab. At the Command Window prompt, type:
	
	<command>make well1.s rcc[Enter]</command>
	
	Go to the Edit menu and click on Primitive Selection, then well1.s. After
	selecting a Left view, go back to Edit and select Scale. Reduce the size
	of the rcc until its diameter is about the right size for a wheel well. Go
	back to Edit and select Rotate. As discussed previously, one way to easily
	rotate the rcc is by using the CTRL key and the left mouse button to drag
	the top lip of the rcc down (in a straight line) until the A and C edit
	labels overlap. However, because we know we want to flip the object
	exactly 90'0 along the x axis, a better choice is to use the Command Line
	and type:
	
	<command>p 90 0 0[Enter]</command>
	
	After doing so, you may still have to use the Set H and Scale editing
	options to resize and the SHIFT key and left mouse button to position your
	wheel well. When satisfied, select Accept. Your design should look similar
	to the following in Multipane mode:
	
	<figure>
	  <title>Multipane View of Truck with First Wheel in Place</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>The Difference Between OK, Accept, Apply, Reset, Cancel, and Dismiss</title>
      <para>
	The GUI environment of <application>MGED</application> offers users several options for applying,
	accepting, or rejecting changes made through buttons at the bottom of
	dialog pop-up windows. To use any of these options, just place the mouse
	cursor over the desired button and click the left mouse button.
      </para>
      <para>
	Selecting the Accept or OK button will tell <application>MGED</application> to record the changes you
	have made to a shape, region, or combination. <application>MGED</application> uses the Accept and OK
	buttons interchangeably. When you click on Accept or OK, the window you
	are using will automatically close.
      </para>
      <para>
	The Apply button tells <application>MGED</application> to apply a change you have made and wait for
	further instructions. The window does not automatically close. This
	enables you to make changes to several things without having to reopen the
	window for each change.
      </para>
      <para>
	The Reset button tells <application>MGED</application> to reset values you have changed in a dialog
	box to the last values you applied or accepted. The Reset button does not
	close the dialog box. The Cancel or Dismiss buttons discard any changes
	made in the dialog box and leave values unchanged from their last stored
	settings. These two buttons close the dialog box.
      </para>
    </sect1>
    <sect1>
      <title>Using the Primitive Editor to Make a Copy of the Wheel Well</title>
      <para>
	To make a copy of your wheel well, go to the Edit menu and select
	Primitive Editor, which will contain information about the last shape
	edited through the dialog box (or myPrimitive if nothing has been edited).
	Erase the old shape's name in the Name entry box. Type in well1.s and
	press Reset (or press Enter while the cursor is still in the Name entry
	box). The parameter values of the old shape will be replaced by those of
	the new shape. The Primitive Editor will change and look something like
	the following example:
	
	<figure>
	  <title>The Primitive Editor</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

      </para>
      <para>
	Go back to the Name text box and change the 1 to a 2 and click on OK.
	Change to Front under the View menu. Go to Edit/Primitive Selection and
	click on well2.s. Use the SHIFT and left mouse button to drag the new
	wheel well into position, as shown in the following illustration. Check
	your alignment in Multipane mode and then click on Accept when you are
	finished.
	
	<figure>
	  <title>Placement of the Second Wheel</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Making a Combination of the Cab Shapes</title>
      <para>
	It is now time to make a combination of the various cab shapes.
	
	<command>comb cab1.c u cab1.s - caboff1.s - well1.s - well2.s[Enter]</command>
	
	This command tells <application>MGED</application> to:
	
	<informaltable>
	  <tgroup cols='10'>
	    <tbody>
	      <row>
		<entry>comb</entry>
		<entry>cab1.c</entry>
		<entry>u</entry>
		<entry>cab1.s</entry>
		<entry>-</entry>
		<entry>caboff1.s</entry>
		<entry>-</entry>
		<entry>well1.s</entry>
		<entry>-</entry>
		<entry>well2.s</entry>
	      </row>
	      <row>
		<entry>Make a combination</entry>
		<entry>Name it cab1.c</entry>
		<entry>Make a union</entry>
		<entry>of the shape cab1.s</entry>
		<entry>minus</entry>
		<entry>the shape caboff1.s</entry>
		<entry>minus</entry>
		<entry>the shape well1.s</entry>
		<entry>minus</entry>
		<entry>the shape well2.s</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Before you go any further, you should check your data tree by typing tree
	cab1.c. The data tree should say:

	<literallayout>
   cab1.c/

   u cab1.s

   - caboff1.s

   - well1.s

   - well2.s
	</literallayout>
	
      </para>
      <para>
	If you type ls (list) at the Command Window prompt, you should find that
	your database is composed of the combination cab1.c and the shapes cab1.s,
	caboff1.s, well1.s, and well2.s. You will find as you make more complex
	objects that you will periodically refer to the list of the database to
	ensure it is composed of the elements you want.
      </para>
    </sect1>
    <sect1>
      <title>Creating an rpp for the Body of the Truck Using the In Command</title>
      <para>
	To make the body of the truck, type at the Command Window prompt:
	
	<command>in body1.s rpp 0 2 0 1 0 1.5[Enter]</command>
	
	By now, you should know what this command tells <application>MGED</application> to do. If you have
	forgotten, refer back to making the cab of the truck.
      </para>
      <para>
	Edit the body of the truck so that its front face slightly overlaps the
	cab's back face. Check different views to make sure the body lines up
	correctly with the cab. Accept your changes when you are done, and then
	Blast your design. Your truck should now look like the following:
   
	<figure>
	  <title>Truck Cab and Body</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Using the Primitive Editor to Make Two More Wheel Wells</title>
      <para>
	To make two wheel wells for the body of the truck, repeat the steps used
	in making the second wheel well. Name your new shapes well3.s and well4.s.
	Using multiple views, move the new shapes into position so that your truck
	now looks similar to the following:
   
	<figure>
	  <title>Wireframe Representation of Truck with Wheel Wells</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

               Wireframe Representation of Truck with Wheel Wells
      </para>
    </sect1>
    <sect1>
      <title>Making a Combination of the Truck Body and Wheel Wells</title>
      <para>
	Make a combination of the truck body and the two new wheel wells. Name it
	body1.c.
	
	The tree for body1.c should say:
	
	<literallayout>
   body1.c/

   u body1.s

   - well3.s

   - well4.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Making a Region of the Cab and Body</title>
      <para>
	Before adding wheels to the truck, you need to make a region of the cab
	and body. At the Command Window prompt, type:
	
	<command>r truck1.r u cab1.c u body1.c[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Making Wheels for the Truck</title>
      <para>
	Perhaps the best shape for making wheels is the torus. You can create a
	shape through the Command Window that has the correct size and placement
	for your design without further editing. However, this lesson is designed
	to give you practice rotating and translating shapes.
      </para>
      <para>
	To make the first wheel, type at the Command Window prompt:
	
	<command>in wheel1.s tor 0 0 0 .5774 .5774 .5774 .18 .08[Enter]</command>
	
	This command tells <application>MGED</application> to:
	<informaltable>
	  <tgroup cols='7'>
	    <tbody>
	      <row>
		<entry>in</entry>
		<entry>wheel1.s</entry>
		<entry>tor</entry>
		<entry>0 0 0</entry>
		<entry>.5774 .5774 .5774</entry>
		<entry>.18</entry>
		<entry>.08</entry>
	      </row>
	      <row>
		<entry>Create a shape</entry>
		<entry>Name it wheel1.s</entry>
		<entry>Make the shape a torus</entry>
		<entry>Make the values of the vertex 0 0 0</entry>
		<entry>Make the values for x, y, and z of the normal vector .5774 .5774 .5774</entry>
		<entry>Make the value of the outer radius .18</entry>
		<entry>Make the value of radius 2 (the tire thickness) .08</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Change View to Left and then Edit the position of the wheel. To correctly
	align the wheel with the truck, you will have to Rotate the tire using the
	CTRL key and any mouse button. Scale and Translate the wheel into position
	as appropriate and check your alignment from several different views.
	Accept your changes when finished.
      </para>
      <para>
	Using the Primitive Editor, make the second, third, and fourth wheels.
	Move each of these wheels into position until your truck looks like the
	following:
	
	<figure>
	  <title>Wireframe Truck and Wheels</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Making a Region of the Wheels</title>
      <para>
	Make a region of the four wheels. When you are finished, your data tree
	for wheel1.r should say:

	<literallayout>
   wheel1.r/R

   u wheel1.s

   u wheel2.s

   u wheel3.s

   u wheel4.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Assigning Material Properties to the Truck Regions</title>
      <para>
	Your truck is composed of two regions: truck1.r and wheel1.r. Use the
	Combination Editor and select truck1.r.
      </para>
      <para>
	In the Combination Editor, the camouflage (camo) shader creates a
	pseudo-random tricolor camouflage pattern on the object using a fractal
	noise pattern. The shader offers lots of attributes from which to choose.
	For now, select a Background Color of black (0 0 0) and make Color #1
	green (0 134 0), and Color #2 rust brown (164 96 38). To make the pattern
	design proportional to the truck, select a Noise Size of .25 and then
	Apply the selections. The Combination Editor window for the camo shader
	should look like this:
	
	<figure>
	  <title>Camo Shader</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Apply a black color and plastic shader to the wheels (wheel1.r) and click
	on OK. Then raytrace your design.
      </para>
    </sect1>
    <sect1>
      <title>Using the On-Screen Help Option</title>
      <para>
	You have probably noticed that many of the <application>MGED</application> menus offer a wide variety
	of options from which to choose. With so many choices available, it is
	easy to forget what a particular selection does. To help users quickly
	access basic information about the various <application>MGED</application> options, the program
	offers a context-sensitive, on-screen help feature.
      </para>
      <para>
	The on-screen help can be accessed from any menu or pop-up window by
	placing the mouse cursor over the name of any option in the menu or window
	and clicking the right mouse button. The only place this feature doesn't
	work is in the geometry portion of the Graphics Window, where the design
	is drawn.
      </para>
    </sect1>
    <sect1>
      <title>The Stacker Option</title>
      <para>
	In previous lessons, you applied color and a shader to an object to make
	it appear realistic. Sometimes, however, you will need to apply two or
	three shaders to an object to get the design you want.
      </para>
      <para>
	<application>MGED</application> offers three categories of shaders: paint, plastic, and light. Any
	combination of these three types of shaders can be applied to the same
	object using the stacker option of the shader menu.
      </para>
      <para>
	There are three plastic shaders: glass, mirror, and plastic. A plastic
	shader is used to give the perception of space. It does this by making the
	object's surface shiny so that it reflects light. A plastic shader is
	normally applied last in the stacker process.
      </para>
      <para>
	The paint shaders are used to apply pigment and texture to the surface of
	an object. Color is pigment, and texture is the three-dimensional quality
	of the surface material (such as stucco paint).
      </para>
      <para>
	Pigment shaders include camo, texture (color), texture (black/white), fake
	star, cloud, checker, test map, and projection. Texture shaders include
	bump map, fbm bump, and tur bump. Paint shaders are normally applied first
	in the stacking process and are used in combination with the plastic
	shader.
      </para>
      <para>
	The light shader is used to produce illumination in the scene. This helps
	produce realism in the final image. The light shader is technically
	complex and is not discussed in this tutorial.
      </para>
      <para>
	The camo shader involves applying pigments, in a random pattern, to the
	surface of an object. The camo shader doesn't indicate the
	three-dimensional nature of an object. If you want your design to show
	depth, you will need to stack the camo shader and the plastic shader.
      </para>
    </sect1>
    <sect1>
      <title>Using the Stacker Option</title>
      <para>
	To use the stacker option, open the Combination Editor and select
	truck1.r. Click on the button to the right of the Shader entry box and
	then select stack from the drop-down menu. A button with the words Add
	Shader will appear under the text box. Click on the button and then select
	camouflage. Set the Background Color to black (0 0 0), Color #1 to green
	(0 134 0), and Color #2 to rust brown (164 96 38). Make the Noise Size
	.25. Click on Add Shader once again and select plastic.
      </para>
      <para>
	At this point, your Combination Editor window may have gone off the bottom
	of the screen. If this happens, reduce the size of the window as much as
	you can and then drag it up to the top of the screen. The buttons at the
	bottom of the box should now appear, and you can Apply your selections.
      </para>

      <caution>
	<para>
	  When using the stacker option, you need to keep track of the 
	  number of characters and spaces in the shader text box. <application>MGED</application> versions 
	  prior to release 6.0 will only recognize 64 characters/spaces, so be  
	  careful stacking shaders with complex attributes.                     
	</para>
      </caution>
    </sect1>
    <sect1>
      <title>Making a Combination of the Truck Regions</title>
      <para>
	To make a combination of the two truck regions, type at the Command Window
	prompt:
	
	<command>comb truck1.c u truck1.r u wheel1.r[Enter]</command>
	
	<command>B truck1.c[Enter]</command>
	
	Your data tree for truck1.c should read:
	<literallayout>
   truck1.c/

   u truck1.r/R

   u cab1.c/

   u cab1.s

   - caboff1.s

   - well1.s

   - well2.s

   u body1.c

   u body1.s

   - well3.s

   - well4.s

   u wheel1.r/R

   u wheel1.s

   u wheel2.s

   u wheel3.s

   u wheel4.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Raytracing the Truck</title>
      <para>
	The last step in creating your truck is to raytrace your design. When the
	raytracer has finished, notice that the top and one side of the truck are
	very dark. This is because there is very little light falling on them.
	Because we have not specified any light sources for our scene, <application>MGED</application>
	provides us with a set of default lights. These defaults consist of a dim
	light at the location of the viewer and a brighter one located to the left
	and below the viewer. Since the primary light is not really shining on one
	side of the truck, it is dark.
      </para>
      <para>
	There is a special adjustment we can make to improve the overall
	brightness of the scene. We can adjust the amount of ambient light, which
	is light that does not come from a particular light source but is a
	measure of the light generally present in the scene. To adjust the amount
	of ambient light, click on the Advanced Settings  button in the Raytrace
	Control Panel. Next to Other Options, type -A .9 and click Dismiss. Now
	when you raytrace, you will get a much lighter image.
      </para>
      <para>
      <informaltable>
	  <tgroup cols='2'>
	    <tbody>
	      <row>
		<entry>
		  <para>
		    <figure>
		      <title>Wireframe Representation of Tabletop, First eto and First rcc</title>
		      <screenshot>
			<graphic fileref=".png"/>
		      </screenshot>
		    </figure>
		  </para>
		</entry>
		<entry>
		  <para>
		    <figure>
		      <title>Wireframe Representation of Tabletop, First eto and First rcc</title>
		      <screenshot>
			<graphic fileref=".png"/>
		      </screenshot>
		    </figure>
		  </para>
		</entry>
	      </row>
	      <row>
		<entry>
		  Truck with Default Lighting
		</entry>
		<entry>
		  Truck with Added Ambient Light
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect1>
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Created a toy truck from three shapes.</para>
	  </listitem>
	  <listitem>
	    <para>Made copies of shapes using the Primitive Editor.</para>
	  </listitem>
	  <listitem>
	    <para>Made combinations and regions of a more complex object.</para>
	  </listitem>
	  <listitem>
	    <para>Checked the data tree for accuracy.</para>
	  </listitem>
	  <listitem>
	    <para>Listed contents of the database.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties using the Combination Editor.</para>
	  </listitem>
	  <listitem>
	    <para>Identified the difference between OK, Accept, Apply, Reset, Cancel, and Dismiss.</para>
	  </listitem>
	  <listitem>
	    <para>Identified the on-screen help option.</para>
	  </listitem>
	  <listitem>
	    <para>Identified the stacker option.</para>
	  </listitem>
	  <listitem>
	    <para>Experimented with the attributes of the camo shader.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>
  <chapter id="lesson-16">
    <title>Learning Modeling Techniques and Structures</title>
    <para>
      In this lesson, you will be:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Making the shapes of the walkie-talkie radio into regions.</para>
	</listitem>
	<listitem>
	  <para>Gathering the regions into an assembly combination.</para>
	</listitem>
	<listitem>
	  <para>Assigning material properties to the regions.</para>
	</listitem>
	<listitem>
	  <para>Adding internal components to the radio.</para>
	</listitem>
	<listitem>
	  <para>Creating specialty models of the radio.</para>
	</listitem>
	<listitem>
	  <para>Redefining the structure of the radio.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      In Lesson 2, we made the basic shapes of a walkie-talkie radio to gain
      experience in viewing objects. Now that we have successfully modeled a few
      simple objects, let's return to the radio to make it more realistic and,
      in so doing, discuss logical techniques and structures in modeling. When
      finished, our radio should look as follows:

      <figure>
	<title>Walkie-Talkie Radio</title>
	<screenshot>
	  <graphic fileref=".png"/>
	</screenshot>
      </figure>
    </para>
    <sect1>
      <title>Making the Shapes into Regions</title>
      <para>
	Open the database radio.g that you created in Lesson 2. In the Command
	Window, use the ls command to list all the contents of your radio. It
	should read as follows:
	
	<literallayout>
   ant.s btn.s knob.s

   body.s btn2.s spkr.s
	</literallayout>
	
	Now what does this list really contain? Parts to a model radio? Not
	really. What the list actually comprises is just a collection of shapes
	(which we have hinted at by using a .s suffix) that (1) do not have
	material properties, and therefore (2) do not occupy space.
      </para>
      <note>
	<para>
	  Remember, in <application>MGED</application> no shape truly becomes an object until it is        
	  included in a region, which, by definition, is an object or           
	  collection of objects that has a common material type.                
	</para>
      </note>
      <para>
	So our first order of business is to identify the major parts of the radio
	so we can properly define the regions. So far, our choices are fairly
	simple. The radio basically consists of (1) a body, which houses the
	speaker and all of the internal parts; (2) an antenna; (3) a volume
	control knob, and (4) a talk button. These should be our four regions.
      </para>
      <para>
	Most of these shapes were fairly straightforward to create, with each item
	consisting of just one or two primitive shapes. However, if we think of
	the radio as a real-world object, the body of the radio is actually more
	complex than just a solid box with a few shapes glued to its surface.
	(Remember that all objects are solid unless constructed to be otherwise.)
	Therefore, let's start with the main component of the radio-the body.
 
	<figure>
	  <title>The Body of the Radio</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	If we think about it, the body of a radio is actually a hollow case. So,
	the first thing we need to do is hollow out the case's interior to make
	room for internal components. To do this, we can use the inside command to
	create a shape, which we'll call cavity.s:
	
	<command>inside body.s cavity.s 1 1 1 1 1 1[Enter]</command>
	
	Now, we'll make a region called case.r and define it as what's left of
	body.s after cavity.s has been subtracted out. The command should look
	like this:
	
	<command>r case.r u body.s - cavity.s[Enter]</command>
      </para>
      <note>
	<para>
	  Remember that the inside command was originally created to hollow out 
	  objects such as gas tanks and boxes; however, it can also be used to  
	  create any new cutaway shape that has some relationship to a          
	  pre-existing shape.                                                   
	</para>
      </note>
      <para>
	With our case now made, we can proceed to cut several holes through this
	structure to accommodate the antenna, the volume control knob, and the
	talk button. To do this, we must subtract the three shapes from the case
	as follows:
	
	<command>r case.r - ant.s - knob.s - btn.s[Enter]</command>
	
	Finally, we need to "glue" the lip around the speaker to the case's front
	face by typing
	
	<command>r case.r u spkr.s[Enter]</command>
      </para>
      <para>
	Our body is now finished. Note that an experienced modeler would probably
	have combined the preceding three Boolean functions into a single command
	as follows:
	
	<command>r case.r u body.s - cavity.s - ant.s - knob.s - btn.s u spkr.s[Enter]</command>
	
	If we were to raytrace case.r at this point, we would see the following:
	<figure>
	  <title>Radio with Component Cutouts and Default Material Properties</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Note the hole for the antenna in the top of the case and the hole for the
	talk button on the side of the case. We will now fill these holes with
	their respective components.
      </para>
      <note>
	<para>
	  Precedence Review
	</para>
	<para>
	  The order in which these primitives were unioned and subtracted is    
	  important. We unioned in spkr. s last so that all the subtractions    
	  would apply to body.s. The rules of precedence for Boolean operators  
	  indicate that subtraction and intersection have a higher priority     
	  than union (meaning that they are performed first).                   
	</para>
	<para>
	  Although the following operation is not in proper <application>MGED</application> syntax, it     
	  does illustrate the implied parentheses that precede and follow the   
	  union operators in our last command:                                  
	
	  <command>r case.r u (body.s - cavity.s - ant.s - knob.s - btn.s) u (spkr.s)[Enter] </command>
	  
	  Optionally, we could've unioned in spkr.s before body.s as follows:   
	  
	  <command>r case.r u spkr.s u body.s - cavity.s - ant.s - knob.s - btn.s[Enter]</command> 
	</para>
	<para>
	  Let's consider, however, what would have happened if we had done the  
	  following:                                                            
	  
	  <command>r case.r u body.s u spkr.s - cavity.s - ant.s - knob.s - btn.s[Enter]</command> 
                                                                          
	  In this last case, operator precedence would have caused the program  
	  to subtract cavity.s, ant.s, knob.s, and btn.s from spkr.s. Nothing   
	  would have been subtracted from body.s. Therefore, the holes in the   
	  case would not have been created.                                     
	</para>
	<para>
	  Subtracting cavity.s, ant.s, knobs, and btn.s from spkr.s would have  
	  produced no apparent effect because they do not overlap the volume of 
	  spkr.s.                                                               
	</para>
      </note>
    </sect1>
    <sect1>
      <title>The Other Regions</title>
      <para>
	Making the talk button is simpler than making the case. The button
	consists of the union of two primitive shapes. To make them into a region,
	type
	
	<command>r button.r u btn.s u btn2.s[Enter]</command>
      </para>
      <para>
	The volume knob and antenna are even simpler. They are single primitive
	shapes that can be made into regions by typing
	
	<command>r knob.r u knob.s[Enter]</command>
	
	<command>r ant.r u ant.s[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Gathering the Regions into an Assembly Combination</title>
      <para>
	Now let's take all of the regions we have made so far and gather them into
	an assembly (or group) combination called radio.c so that we can keep all
	of these parts together. There are several ways to do this. One way would
	be to use a similar method to the one we used to make the regions:
	
	<command>comb radio.c u case.r u button.r u knob.r u ant.r[Enter]</command>
      </para>
      <para>
	A shortcut, however, would be to use the g (group) command as follows:
	
	<command>g radio.c case.r button.r knob.r ant.r[Enter]</command>
	
	Unlike the comb command, the g command assumes that all of the items
	specified will be unioned together, and so no Boolean operators need to be
	specified.
      </para>
      <para>
	A final improvement would include using the database name wildcard *.r to
	quickly and easily specify all of the regions in the database:
	
	<command>g radio.c *.r[Enter]</command>
	
	If we now tree radio.c, we should get the following output in the Command
	Window.
	<literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Assigning Material Properties to the Regions</title>
      <para>
	Thus far, the objects we have created have no material properties other
	than the gray plastic that <application>MGED</application> assigns by default to any object without
	assigned material values. Now let's improve our design by assigning other
	material properties to the components.
      </para>
      <para>
	We'll give the antenna a realistic look by opening the Combination Editor,
	choosing ant.r from the drop-down Name menu, selecting mirror  from the
	drop-down  Shader menu, and clicking on Apply.
      </para>
      <para>
	We'll let the other components remain with the default plastic, but we'll
	assign them different colors. With the Combination Editor still open,
	select case.r from the drop-down Name menu, select the magenta option from
	the drop-down Color  menu, and then click Apply. Use the same method to
	assign the  volume control knob (knob.r) a blue color. For the talk button
	(button.r), let's keep it gray by leaving the default values in place. The
	design should appear similar to the following when raytraced in Underlay
	mode:
	
	<figure>
	  <title>Radio with Material Properties Assigned</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para> 
	As we look at our radio now, we can see that the antenna looks a little
	bit like a straw. In reality, it should have a small cap on the end so
	that we can raise and lower the antenna. We can approximate this shape by
	creating an ellipsoid (which we'll call ant2.s) and unioning it in with
	the rest of the antenna as follows:
	
	<command>in ant2.s ell1 2 2 94 0 0 1 3[Enter]</command>
	
	<command>r ant.r u ant2.s[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Adding Internal Components</title>
      <para>
	Our radio is looking more and more realistic; however, it is still just a
	hollow shell. Let's further improve it by making a circuit board to go
	inside the case. To do this, type:
	
	<command>in board.s rpp 3 4 1 31 1 47[Enter]</command>
	
	<command>r board.r u board.s[Enter]</command>
      </para>
      <para>
	Let's give the board a green semi-shiny color. The easiest way to do this
	is via the Combination Editor, but this time let's use the Command Line
	approach. Type:

	<command>mater board.r "plastic sh=4" 0 198 0 1[Enter]</command>
	
	Diagrammed, this command says to:
	<informaltable>
	  <tgroup cols='5'>
	    <tbody>
	      <row>
		<entry>mater</entry>
		<entry>board.r</entry>
		<entry>"plastic sh=4"</entry>
		<entry>0 198 0</entry>
		<entry>1</entry>
	      </row>
	      <row>
		<entry>Assign material properties to</entry>
		<entry>the region called board.r.</entry>
		<entry>Apply the plastic shader with a shininess of 4</entry>
		<entry>Give it a green color</entry>
		<entry>Inherit color material type</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Finally, we'll include the board with the rest of the components in
	radio.c as follows:
	
	<command>g radio.c board.r[Enter]</command>
	
	Our radio should now look like the following:
	
	<figure>
	  <title>Wireframe Radio with Circuit Board Added</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

	In addition, the tree for radio.c should now look as follows:
	<literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s

   u ant2.s

   u board.r/R

   u board.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Making Specialty Models of the Radio</title>
      <para>
	Now, what would happen to the circuit board if we were to raytrace the
	radio at this point? It would disappear because it lies within the case.
	So how can we make the circuit board visible outside of the case?
      </para>
      <para>
	There are two common ways to do this: a transparent view and a cutaway
	view. Each method has its advantages and disadvantages. With the
	transparent view, the Boolean operations remain unchanged, but some of the
	material properties of the "outside shell" are altered to better view
	interior parts of the model. With the cutaway view, the material
	properties remain unchanged, but some of the Boolean operations are
	altered to remove parts of the model that are obstructing our view of
	other parts. We will try both ways to view the inside of our radio.
      </para>
      <para>
	Different Approaches to Creating Specialty Models
      </para>
      <para>
	An important point to note here is that the transparent and cutaway views
	are specialty models. They are similar in nature to items a manufacturer
	might make for special purposes. For example, an automobile manufacturer
	makes cars for everyday use, but also makes modified versions for display
	at certain events. The body panels might be replaced with a transparent
	material or be partially cut away to reveal interior components.
      </para>
      <para>
	Good modeling practice follows the same pattern. The actual model of an
	item should not have to be changed in order to create a specialty view of
	it. Instead, a modified version of the item should be created. Thus, the
	modeler will not have to worry about remembering to return the model to
	the original condition after its special-purpose use, and the modeler can
	also retain the "display model" for future use.
      </para>
      <para>
	There are two common approaches to making these specialty models: First,
	the modeler can copy the original and replace components with modified
	versions. Second, the modeler can create new, unique parts from scratch
	and construct the modified item. The method chosen is a matter of personal
	choice and is usually determined by the extent of the modifications being
	done and the complexity of the original object.
      </para>
      <sect2>
	<title>Transparent View</title>
	<para>
	  Making a specialty radio with a transparent case would probably be the
	  easiest way to view the circuit board inside. All we have to do is make a
	  copy of our present radio case and modify its material properties. We'll
	  call the specialty case case_clear.r. Type
	  
	  <command>cp case.r case_clear.r[Enter]</command>
	  
	  We can now use the Combination Editor to set the material properties on
	  this case without affecting the "master" design of the radio. When this
	  has been done, we can combine this modified case with the other unchanged
	  radio components and group them as a new specialty radio named
	  radio_clear.c.
	</para>
	<para>
	  To set the material properties of case_clear.r, choose plastic from the
	  drop-down menu to the right of the Shader entry box in the Combination
	  Editor. (Although this is the shader that is used by default, we want to
	  explicitly select it in order to change one of its values.) Now change the
	  Transparency of the case to a value of .8. Apply the change and close the
	  Combination Editor.
	</para>
	<para>
	  Finally, create the specialty radio combination by typing:
	  
	  <command>g radio_clear.c case_clear.r button.r knob.r ant.r board.r[Enter]</command>
	  
	  and then Blast the display with
	  
	  <command>B radio_clear.c[Enter]</command>
	</para>
	<para>
	  Now raytrace your design to view the resulting effect. The new transparent
	  case should appear similar to the following:
	  <figure>
	    <title>Transparent View of the Radio</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  As shown in the following tree diagram, the structure of this specialty
	  radio_clear.c is not much different than that of the regular radio.c. The
	  only difference is that case.c has been replaced with case_clear.c.
	  <literallayout>
   radio_clear.c/

   u case_clear.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s

   u ant2.s

   u board.r/R

   u board.s
	  </literallayout>
	</para>
	<note>
	  <para>
	    Notice in the preceding figure that the color chosen for the          
	    transparent case does influence the appearance of the internal        
	    objects. Although we made the circuit board green, the filter effect  
	    of the transparent magenta case-which allows no green light to enter  
	    or exit the case-causes the board to appear to be dark purple. This   
	    is okay in our situation. However, if accuracy in color is important  
	    in a model, the modeler should remember to select a neutral color     
	    (such as white or light gray) for the transparent object.             
	  </para>
	</note>
      </sect2>
      <sect2>
	<title>Cutaway View</title>
	<para>
	  Another way we can make the interior components of the radio visible is to
	  create a cutaway view. Although it is a little more complex to make than
	  the transparent view was, the cutaway view offers a particularly
	  interesting way to view geometry.
	</para>
	<para>
	There are several ways to make the cutaway view. Probably the easiest way
	is to use the "chainsaw" method to cut off part of the radio and reveal
	what is inside.
	</para>
	<para>
	  To do this, create an arb8 called cutaway.s, which will be used to cut off
	  the front corner of the radio. Because this is a cutting shape (i.e., it
	  is simply used to erase a portion of another shape and will not actually
	  be viewed), the dimensions of the arb8 are not critical. The only concern
	  is that cutaway.s be as tall as the case so that it completely removes a
	  corner from it.
	</para>
	<para>
	  Use the Shift Grips and multiple views (especially the Top view) to align
	  cutaway.s so that it angles diagonally across the top of the radio (as
	  shown in the following wireframe representation). When you've aligned the
	  shape the way you want it, create the following radio_cutaway.c
	  combination that unions in radio.c and subtracts out the shape (cutaway.s)
	  that is covering what you want to see (board.r):
	  
	  <command>comb radio_cutaway.c u radio.c - cutaway.s[Enter]</command>
  
	  <figure>
	    <title>Multipane View of Cutting Primitive</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  Blast the radio_cutaway.c combination onto the display and raytrace.
	  Depending on how your arb8 intersected the radio, the cutaway should look
	  similar to the following:
   
	  <figure>
	    <title>Cutaway View of Radio with Circuit Board Cut Off</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  Notice in the preceding figures that cutaway.s removes everything it
	  overlaps (including part of the circuit board). This is okay if we just
	  want to see inside the case. However, if we want to see all of the circuit
	  board and any other component overlapped by cutaway.s (e.g., button.r), we
	  would have to adjust our Boolean operations a little so that the cutaway
	  is subtracted only from our case.
	</para>
	<para>
	  To do this, we basically have two options: (1) we could move cutaway.s in
	  the structure so that it is subtracted from only case.r, or (2) we could
	  move cutaway.s in the structure so that it is subtracted from both body.s
	  and spkr.s, the two components that make up case.r. While both of these
	  options would produce the same effect, the first method requires just one
	  subtraction, whereas the second method potentially provides more control
	  by having the user select the individual components that will subtract out
	  the cutting shape.
	</para>
	<para>
	  Take a minute and compare the following trees for the cutaways we have
	  discussed so far. Especially note the position of cutaway.s in the
	  different structures. Also, note that when cutaway.s was subtracted from a
	  particular region or combination, the name of that region or combination
	  was changed. The reasoning behind this goes back to our original
	  discussion of specialty models. Remember that our purpose is to create a
	  new special-purpose model, not change the existing model. So, we must
	  change the name of any region or combination that contains any modified
	  components or structures. If we don't, the master model will also be
	  changed.
	</para>
	<para>*****Note - add figures showing tree structure - need to be redone*****</para>
      </sect2>
    </sect1>
    <sect1>
      <title>Redefining the Structure of the Radio</title>
      <para>
	As shapes are added in a design, the modeler often finds that the
	structure or association of components needs to change. Thus, we should
	pause at this point and consider how our radio is structured. While there
	are many ways to structure a model, two common modeling categories are
	location and functionality. For our radio, we have so far grouped
	everything together under the general category of Radio, as shown in the
	following:

  	<figure>
	  <title>Current Radio Structure</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
       </para>
       <para>
	 If we wanted to categorize our components according to location, however,
	 we might structure the model as follows:
	 
	 <figure>
	   <title>Location-Based Structure of Radio</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
       <para>
	 If we wanted to define our components according to functionality, we might
	 structure the model another way. For instance, to repair an actual radio,
	 we would open the case, take out the circuit board, fix it, and put it
	 back in. When taking out the board, however, the knob and button would
	 probably be attached to it in some way, and so they too would need to come
	 out. Accordingly, our structure should be changed as shown in the
	 following diagram to associate the knob and button with the circuit board.
	 
	 <figure>
	   <title>Function-Based Structure of Radio</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
       <para>
	 To accomplish this restructuring according to functionality, create an
	 assembly called electronics.c to hold these components together. Type:
	 
	 <command>g electronics.c board.r knob.r button.r[Enter]</command>
	 
	 Of course, we now need to remove board.r, knob.r, and button.r from the
	 radio.c assembly so that when electronics.c is added to the radio.c
	 assembly, we won't have the knob and button included twice in the model.
	 To do this, use the rm (remove) command:
	 
	 <command>rm radio.c board.r knob.r button.r[Enter]</command>
	 
	 and then union in the electronics assembly:
	 
	 <command>g radio.c electronics.c[Enter]</command>
       </para>
       <para>
	 Now the tree for radio.c should appear as follows:
	 <literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u ant.r/R

   u ant.s

   u ant2.s

   u electronics.c/

   u board.r/R

   u board.s

   u knob.r/R

   u knob.s

   u button.r/R

   u btn.s

   u btn2.s
	 </literallayout>
       </para>
       <para>
	 Now let's remake our cutaway view. This time, let's do what we discussed
	 earlier and make the cutaway remove material from only the case, showing
	 all the other components.
       </para>
       <para>
	 First, we need to get rid of the old radio_cutaway.c, which was based on
	 our previous structure. To do this, type
	 
	 <command>kill radio_cutaway.c[Enter]</command>
	 
	 and then remake the combination by typing
	 
	 <command>comb radio_cutaway.c u case.r - cutaway.s u electronics.c u ant.r[Enter]</command>
	 
	 Now when we Blast the display and raytrace radio_cutaway.c, we should see
	 the following:
	 <figure>
	   <title>View of Radio with Just the Case Cut Away</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
    </sect1>
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Made the shapes of the walkie-talkie radio into regions.</para>
	  </listitem>
	  <listitem>
	    <para>Gathered the regions into an assembly combination.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties to the regions.</para>
	  </listitem>
	  <listitem>
	    <para>Added internal components to the radio.</para>
	  </listitem>
	  <listitem>
	    <para>Created specialty models of the radio.</para>
	  </listitem>
	  <listitem>
	    <para>Redefined the structure of the radio.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

<appendix label="A">
  <title><application>MGED</application> Commands</title>
  <xi:include href="../../system/mged/mged_commands.xml" xpointer="mged_user_cmd_table"/>
  <xi:include href="../../system/mged/mged_commands.xml" xpointer="glossary"/>
</appendix>

</book>
