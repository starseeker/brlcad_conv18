<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">

  <info>
    <title>NURBS Boolean Evaluation Development Guide</title>
    <author>
      <personname>
        <firstname>Nicholas</firstname>
        <surname>Reed</surname>
      </personname>
    </author>
  </info>

  <section>
    <title>NURBS Boolean Evaluation Using the brep Command</title>
    <section>
      <title>Known Limitations</title>
      <itemizedlist>
        <listitem><para>Frequently produces incorrect output due to unhandled intersection cases.</para></listitem>
        <listitem><para>Unoptimized performance.</para></listitem>
	<listitem><para>Material properties of source objects are discarded.</para></listitem>
	<listitem><para>Some primitive conversions to NURBS are ill-defined.</para></listitem>
	<listitem><para>Hollow objects are not built topologically continuous.</para></listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Overview of the Implementation</title>
    <section>
      <title>Description of Major Functions</title>
      <section>
	<title><filename>src/libbrep/boolean.cpp</filename></title>
	<synopsis>
	<![CDATA[
int
ON_Boolean(
    ON_Brep *evaluated_brep,
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	In the nontrivial case where the bounding boxes of <parameter>brep1</parameter> and <parameter>brep2</parameter> intersect, <function>get_evaluated_faces</function> is called to get the trimmed NURBS faces of the evaluated boolean result. The faces are then combined into a single brep object returned via the <parameter>evaluated_brep</parameter> argument. 
	</para>
	<synopsis>
	<![CDATA[
ON_ClassArray< ON_SimpleArray<Trimmed Face *> >
get_evaluated_faces(
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	The intersection curves between the faces of <parameter>brep1</parameter> and <parameter>brep2</parameter> are found by <function>get_face_intersection_curves</function>. These curves are used to split the original surfaces into pieces, each becoming a new trimmed NURBS face. The <function>categorize_trimmed_faces</function> function is used to identify which pieces, based on the boolean operation, are part of the evaluated result. Each <classname>TrimmedFace</classname> whose <varname>m_belong_to_final</varname> member is marked <constant>TrimmedFace::BELONG</constant> is used by <function>ON_Boolean</function> to create the final evaluated result.
	</para>
	<synopsis>
	<![CDATA[
ON_ClassArray< ON_SimpleArray<SSICurve> >
get_face_intersection_curves(
    ON_SimpleArray<Subsurface *> &surf_tree1,
    ON_SimpleArray<Subsurface *> &surf_tree2,
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	    Each pair of <parameter>brep1</parameter> and <parameter>brep2</parameter> surfaces whose bounding boxes intersect are passed to the <function>ON_Intersect</function> surface-surface intersection routine. The surface-surface intersection curves are then clipped using the trimming curves of the associated faces by the <function>get_subcurves_inside_faces</function> routine.
	</para>
      </section>
      <section>
	<title><filename>src/libbrep/intersect.cpp</filename></title>
	<synopsis>
	<![CDATA[
int
ON_Intersect(const ON_Surface *surfA,
             const ON_Surface *surfB,
             ON_ClassArray<ON_SSX_EVENT> &x,
             double isect_tol,
             double overlap_tol,
             double fitting_tol,
             const ON_Interval *surfaceA_udomain,
             const ON_Interval *surfaceA_vdomain,
             const ON_Interval *surfaceB_udomain,
             const ON_Interval *surfaceB_vdomain,
             Subsurface *treeA,
             Subsurface *treeB);
	]]>
	</synopsis>
	<para>
	    The first stage of the surface-surface intersection algorithm attempts to identify overlap intersections (areas where the two surfaces are coincident). Our assumption is that the boundary curve of any overlap region must be formed from isocurves of the overlapping surfaces. Subcurves of isocurves that intersect both surfaces, such that the surfaces are coincident on one side of the curve but not the other, potentially form part of overlap boundaries. These curves are identified using <function>find_overlap_boundary_curves</function>, which may also return some intersection points and curves that aren't on overlap boundaries to avoid wasted effort. Then, the <function>split_overlaps_at_intersections</function> function is run, and curves that share endpoints are stitched together. Stitched curves that close to form loops are recorded as overlap intersection events.
	</para>
	<para>
	The second stage of the surface-surface intersection algorithm attempts to identify other intersection curves and points. The input surfaces <parameter>surfA</parameter> and <parameter>surfB</parameter> are subdivided into four subsurfaces, whose bounding boxes are tested in pairs for intersection. This subdivision repeats to a fixed depth determined by <constant>MAX_SSI_DEPTH</constant>. Subsurfaces that lie completely inside an overlap region identified in the first stage are discarded. Each final pair of subsurfaces with intersecting bounding boxes is approximated with two triangles. The triangles are then intersected, and the average of all intersection points is used as the initial guess for a Newton iterative solver, implemented by <function>newton_ssi</function>, which searches for a point close to the guess point which lies on both surfaces. Solved points that lies inside an overlap region identified in the first stage are discarded. Nearby points in the set of solved intersection points between <parameter>surfA</parameter> and <parameter>surfB</parameter> are then stitched together into polyline curves. If a line or conic curve can be fit to the polyline curves in 2D, the fit curve replaces the original <parameter>surfA</parameter> and/or <parameter>surfB</parameter> polyline curve. 
	</para>
      </section>
    </section>

    <section>
      <title>Visualizing the Algorithm</title>
      <para>Walking through an evaluation.</para>
    </section>

    <section>
      <title>The OpenNURBS API</title>
      <para>
        BRL-CAD leverages the OpenNURBS library primarily for its classes that represent general (NURBS) b-rep, surface, curve, and point geometry. The following sections describe the OpenNURBS library symbols most frequently used in the NURBS boolean evaluation implementation, with relevant usage notes.
      </para>
      <warning>
        <para>
          When using an OpenNURBS utility that hasn't been used elsewhere in the implementation, always check the documentation <emphasis>and</emphasis> the implementation to make sure it does what you expect.
        </para>
        <para>
          Misleading methods have been misused in the past. For example, <function><![CDATA[bool ON_Line::InPlane(ON_Plane& plane)]]></function> appears to test if a line lies in the given plane, but actually constructs a plane that contains the line.
        </para>
        <para>
          Another example is <function><![CDATA[double ON_Line::MinimumDistanceTo(const ON_Line&)]]></function>. While the function does indeed return the distance of the shortest path between one line and another, reading the implementation reveals an undocumented assumption that the <classname>ON_Line</classname> provided as an argument is not on the same infinite line as the instance the method is invoked on. That is, the <classname>ON_Line</classname>s can be parallel, but not coincident.
        </para>
      </warning>
      <section>
        <title>Arrays</title>
        <para>
          OpenNURBS includes two general array classes similar to C++'s <classname>std::vector</classname>, <classname>ON_ClassArray</classname> and <classname>ON_SimpleArray</classname>. Besides having slightly friendlier interfaces, they also feature some higher-level member functions like <function>Reverse</function> and <function>Quicksort</function>.
        </para>
        <para>
          The primary difference between the two classes is that <classname>ON_SimpleArray</classname> doesn't bother constructing and destructing its items. This makes it more efficient than <classname>ON_ClassArray</classname>, but unsuitable for class objects (though pointers to objects are fine). <classname>ON_ClassArray</classname> requires items to have working copy/assignment functions.
        </para>
	<para>
	  The NURBS boolean evaluation implementation frequently employs a combined array of known size to index elements from two input objects. For example, if <parameter>brepA</parameter> has <inlineequation><mathphrase>i</mathphrase></inlineequation> faces and <parameter>brepB</parameter> has <inlineequation><mathphrase>j</mathphrase></inlineequation> faces, a single array of <inlineequation><mathphrase>i + j</mathphrase></inlineequation> elements is created.
	</para>
	<warning>
	  <para>
	    The OpenNURBS array classes do not check for out-of-bounds indexing. This isn't a problem in the simple case where items are added with <function>Append</function> and elements <inlineequation><mathphrase>[0, </mathphrase></inlineequation><function>Count()</function><inlineequation><mathphrase> - 1]</mathphrase></inlineequation> are iterated over.
	  </para>
	  <para>
	    However, if the array will be a fixed size whose items are assigned in a non-sequential order, both the <emphasis>capacity</emphasis> and <emphasis>count</emphasis> should be set, or else the reported <function>Count</function> will be incorrect, and copying arrays by assignment won't work.
	  </para>
	  <programlisting>
	<![CDATA[
	ON_ClassArray< ON_SimpleArray<SSICurve> > curves_array(face_count1 + face_count2);
	curves_array.SetCount(curves_array.Capacity());
	]]>
	  </programlisting>
	</warning>
      </section>
      <section>
        <title>Memory</title>
        <para>
          Curves and surfaces are nearly always allocated on the heap and referenced by pointers, both in the OpenNURBS library, and in the NURBS boolean evaluation implementation.
        </para>
        <para>
          Mostly these allocations are simply done with the <code>new</code> keyword as with any other class. However, a few classes, noteably <classname>ON_Brep</classname> have a <function>New()</function> function that wraps the allocation, which is preferred over using <code>new</code> directly for technical reasons specified in <filename>opennurbs_brep.h</filename>.
        </para>
        <para>
          Pointers to objects, curves in particular, are frequently stolen rather than creating a new copy of the object.
          <warning>
            <para>
              Classes containing heap-allocated objects delete them in their destructors. Proper stealing of pointers requires the instance's members be set to NULL.
            </para>
	    <programlisting>
	      <![CDATA[
ON_SimpleArray<ON_SSX_EVENT> x;
...
for (int i = 0; i < csx_events.Count(); ++i) {
    // copy event
    x.Append(csx_events[i]);

    // clear pointers from original so they aren't deleted by the
    // ON_SSX_EVENT destructor
    csx_events[i].m_curveA = NULL;
    csx_events[i].m_curveB = NULL;
    csx_events[i].m_curve3d = NULL;
}
	      ]]>
	    </programlisting>
          </warning>
        </para>
      </section>
      <section>
        <title>Tolerance Tests</title>
        <para>
          The OpenNURBS routines make extensive use of the symbol <varname>ON_ZERO_TOLERANCE</varname> in calculations to test if a result is to be considered equal to zero, or if two values are to be considered equal.
        </para>
        <note>
          <para>
            The NURBS boolean evaluation implementation frequently uses the function <function>ON_NearZero(double x, double tolerance = ON_ZERO_TOLERANCE)</function> to check if values are near zero, or to check if two values are identical (e.g <function>ON_NearZero(t - last_t)</function>).
          </para>
          <para>
            This function is also used to determine if objects are close enough to be considered intersecting: <function>ON_NearZero(pt.DistanceTo(other.pt), INTERSECTION_TOL)</function>.
          </para>
        </note>
      </section>
      <section>
	<title>2D and 3D Points</title>
	<para>
	  The <classname>ON_2dPoint</classname> and <classname>ON_3dPoint</classname> classes implement the expected operators allowing points to be easily summed and scaled.
	</para>
	<para>
	  The <function>operator[]</function> functions are notable because coordinates are not actually stored as arrays in these classes, but rather in the named members <varname>x</varname>, <varname>y</varname>, and <varname>z</varname>. So while accessing coordinates as <varname>pt[0]</varname>, <varname>pt[1]</varname> is possible, the more readable <varname>pt.x</varname>, <varname>pt.y</varname>, is more typically seen.
	</para>

	<para>
	  The most frequently used member function is <function><![CDATA[DistanceTo(const ON_3dPoint &p)]]></function>, used to check inter-point distances, either as part of an intersection test or to identify closeable gaps or duplicate points.
	</para>
	<note>
	  <para>
	    <classname>ON_2dPoint</classname> objects can be, and are, safely passed to functions that take <classname>ON_3dPoint</classname> arguments. The <classname>ON_3dPoint</classname> arguments are constructed from the provided <classname>ON_2dPoint</classname> objects, with their <varname>z</varname> coordinates set to 0.
	  </para>
          <para>
            The NURBS boolean evaluation implementation frequently constructs 2D curves by populating an <classname>ON_3dPointArray</classname> with 2D points, rather than using an <classname>ON_2dPointArray</classname>, as the 3D version of the class (besides having additional useful member functions), can be used to initialize an <classname>ON_PolylineCurve</classname>.
          </para>
	</note>
      </section>
      <section>
	<title>Bounding Boxes</title>
        <para>
        <classname>ON_BoundingBox</classname> is returned by the <function>BoundingBox</function>, <function>GetTightBoundingBox</function>, and <function>GetBBox</function> functions, which are implemented by all geometry classes inheriting from <classname>ON_Geometry</classname>.
        </para>
        <para>
          The most commonly used members of <classname>ON_BoundingBox</classname> are <function>Diagonal</function> (usually in an expression such as <varname>bbox.Diagonal().Length()</varname> used as a scalar size estimate), and <function>IsPointIn</function> and <function>MinimumDistanceTo</function> (used in intersection tests).
        </para>
      </section>
      <section>
	<title>Domain Intervals</title>
	<para>
	  <classname>ON_Interval</classname> is used to represent the domains of parametric curves and surfaces. The domain <emphasis>starts</emphasis> at <varname>m_t[0]</varname> and <emphasis>ends</emphasis> at <varname>m_t[1]</varname>. These members can be set directly or via <function>Set(double t0, double t1)</function>.
	</para>
	<warning>
	  <para>
	    The start, end, and overall length of the domain are <emphasis>arbitrary</emphasis>, and <varname>m_t[0]</varname> need not be less than <varname>m_t[1]</varname>. If the numerically smaller or larger domain endpoint is needed, these should be accessed via the <function>Min</function> and <function>Max</function> member functions.
	  </para>
	</warning>
	<para>
	  The <function>ParameterAt(double x)</function> function translates a <emphasis>normalized</emphasis> parameter (from a domain starting at 0.0 and ending at 1.0) into a <emphasis>real</emphasis> parameter. Thus, the start of the domain is at <varname>domain.ParameterAt(0.0)</varname>, the midpoint is at <varname>domain.ParameterAt(.5)</varname>, etc.
	</para>
      </section>
      <section>
	<title>Parametric Curves</title>
	<para>
	  The most frequently used geometry class is <classname>ON_Curve</classname>, a generic container for parametric curves. The curve is interrogated by using the <function>PointAt(double t)</function> method to evaluate points at arbitrary values inside the curve's domain, which is specified by the <classname>ON_Interval</classname> returned by the <function>Domain()</function> method. The start and end points of the curve have dedicated access methods, <function>PointAtStart()</function> and <function>PointAtEnd()</function>.
	</para>
	<warning>
	  <para>
	    <function>PointAt</function> takes a real parameter; parameters normalized to <inlineequation><mathphrase>[0, 1]</mathphrase></inlineequation> must be converted. For example, the midpoint of the curve can be found as <varname>curve->PointAt(curve->Domain().ParameterAt(.5))</varname>. <function>PointAt</function> <emphasis role="bold">does not check</emphasis> if the <parameter>t</parameter> value you give it is inside the curve's domain, so you have to get this right!
	  </para>
	</warning>
	<para>
	  All the <function>PointAt</function> methods return an <classname>ON_3dPoint</classname>, though in the common case where <classname>ON_Curve</classname> objects are representing 2D trim curves, the z coordinate will be 0.0.
	</para>
	<para>
	  The curve's domain is frequently reversed using the <function>Reverse()</function> method to facilitate stitching curves together. The function has a boolean <type>int</type> return value that must be checked.
	</para>
	<para>
	  <programlisting>
<![CDATA[
if (curveA->PointAtStart().DistanceTo(curveB->PointAtStart()) < dist_tol) {
  if (curveA->Reverse()) {
      curveA = link_curves(curveA, curveB);
  }
}
]]>
	  </programlisting>
	</para>
	<warning>
	  <para>
	    Comparing curve endpoints, or even just bounding boxes (retrieved via the <function>BoundingBox()</function> method), is often sufficient in the context of different intersection and stitching procedures. However, it's important to keep in mind that in the general case, the shape of the curve between its endpoints or within its bounding box could be anything. For example, two curves with matching endpoints could both be linear, creating a degenerate loop. A curve whose endpoints are equal within the OpenNURBS <constant>ON_ZERO_TOLERANCE</constant> (testable using the <function>IsClosed()</function> method), may be self-intersecting, or degenerate to a point.
	  </para>
	</warning>
	<para>
	  A copy of the curve can be easily made using the <function>Duplicate()</function> member function, which simply wraps a standard copy procedure:
	</para>
	<programlisting>
ON_Curve* Duplicate()
{
  ON_Curve *p = new ON_Curve;
  if (p) *p = *this;
  return p;
}
	</programlisting>
	<para>
	  This function is common to all OpenNURBS geometry classes, but curves are by far the most frequently duplicated objects. However, if curves are simply being retained from a working set of container objects, the curve pointers are frequently stolen rather than copied, with curve members set to <constant>NULL</constant> so that the curves aren't destructed with the containers.
	</para>
      </section>
      <section>
	<title>Lines</title>
	<para>
	  <classname>ON_Line</classname> is used to represent an infinite line, defined by two points, <varname>from</varname> and <varname>to</varname>.
	</para>

	<para>
	  <classname>ON_Line</classname> is not a subclass of <classname>ON_Curve</classname> and should not be confused with <classname>ON_LineCurve</classname> (which has an <classname>ON_Line</classname> member), though it does have some of the same methods as an <classname>ON_Curve</classname> class, including <function>PointAt(double t)</function>. However, because the line has an infinite domain, it can be evaluated at any <varname>t</varname> value, though evaluating at 0.0 returns <varname>from</varname> and evaluating at 1.0 returns <varname>to</varname>, as if the line was a parametric curve with a domain between 0.0 and 1.0.
	</para>

	<para>
	  <classname>ON_Line</classname> has helpful line-specific methods such as <function><![CDATA[ClosestPointTo(const ON_3dPoint &point)]]></function>. Again, because the line is treated as infinite, this function doesn't necessarily return a point in the segment between <varname>from</varname> and <varname>to</varname>.
	</para>

	<para>
	</para>
      </section>
      <section>
	<title>Surfaces</title>
	<para>
	  An <classname>ON_Surface</classname> has a similar interface to an <classname>ON_Curve</classname>, but adapted to support the surface's two domains, <parameter>u</parameter> and <parameter>v</parameter> (sometimes called <parameter>s</parameter> and <parameter>t</parameter>) which correspond with 0 and 1 (first example) or <parameter>x</parameter> and <parameter>y</parameter> (second example).
	</para>
	<example>
	  <title>Projecting an arbitrary <inlineequation><mathphrase>(u, v)</mathphrase></inlineequation> point into 3D.</title>
	  <programlisting>
<![CDATA[
ON_Interval udom = surface->Domain(0);
ON_Interval vdom = surface->Domain(1);
ON_3dPoint surf_midpt_3d = surface->PointAt(udom.ParameterAt(.5), vdom.ParameterAt(.5));
]]>
	  </programlisting>
	</example>
	<example>
	  <title>Projecting a trim-curve point into 3d.</title>
	  <programlisting>
<![CDATA[
ON_Interval tdom = trim_curve->Domain();
ON_3dPoint trim_midpt_uv = trim_curve->PointAt(tdom.ParameterAt(.5));
ON_3dPoint trim_midpt_3d = surface->PointAt(trim_midpt_uv.x, trim_midpt_uv.y);
]]>
	  </programlisting>
	</example>
      </section>
      <section>
	<title>Boundary Representation Objects</title>
	<para>
	  <classname>ON_Brep</classname> is the top-level OpenNURBS class used to represent the two input objects and the evaluated result of the <function>ON_Boolean</function> function. The geometry is encoded as a collection of faces, which for our purposes should be topologically connected to enclose solid volumes.
	</para>
	<para>
	  An object's faces are <classname>ON_BrepFace</classname> objects stored in the <classname>ON_Brep</classname> face array, <varname>m_F</varname>.
	</para>
	<para>
	  Each <classname>ON_BrepFace</classname> is defined as the subset of an <classname>ON_Surface</classname> lying inside the face's <glossterm>outerloop</glossterm> (a.k.a. the <glossterm>face boundary</glossterm>) and outside all of its <glossterm>innerloops</glossterm> (a.k.a. <glossterm>trim loops</glossterm> or just <glossterm>trims</glossterm>). 
	</para>
	<para>
	  The loops of an <classname>ON_BrepFace</classname> are listed in its loop array <varname>m_li</varname> as indexes into the associated <classname>ON_Brep</classname> object's <classname>ON_BrepLoop</classname> array, <varname>m_L</varname>. The first (and possibly only) loop listed in the face's loop index array is the outerloop, and all following loops are inner trim loops. The type of the loop is also recorded in the loop's <varname>m_type</varname> member.
	</para>
	<programlisting>
brep->m_L[brep->m_F[0]->m_li[0]].m_type;      // ON_BrepLoop::outer
brep->m_L[brep->m_F[0]->m_li[1]].m_type;      // ON_BrepLoop::inner
...
brep->m_L[*brep->m_F[0]->m_li.Last()].m_type; // ON_BrepLoop::inner
	</programlisting>
      </section>
      <section>
        <title>Intersection Events</title>
        <para>
          There are two OpenNURBS classes for representing intersections. <classname>ON_X_EVENT</classname> is used for curve-curve and curve-surface intersections. <classname>ON_SSX_EVENT</classname> is used for surface-surface intersections.
        </para>
        <para>
          These classes enumerate a number of intersection types. The <varname>m_type</varname> of intersection events is frequently checked to determine how to further process them over the course of the evaluation.
        </para>
        <note>
          <para>
            The <varname>m_type</varname> of an intersection event determines how values in the <varname>m_a/m_b/m_A/m_B</varname> array members of the event instance are to be interpreted (documented in <filename>opennurbs_x.h</filename>).
          </para>
	  <warning>
	    <para>
	      It's very easy to confuse <varname>m_a</varname>, <varname>m_b</varname>, <varname>m_A</varname>, and <varname>m_B</varname>, as well as <varname>m_a[0]</varname> vs. <varname>m_a[1]</varname>, etc. This is especially true when copying and pasting code.
	    </para>
	  </warning>
	  <para>
	  </para>
          <para>
            For an <classname>ON_X_EVENT</classname> representing a curve-curve intersection whose <varname>m_type</varname> is <varname>ON_X_EVENT::ccx_overlap</varname>, (<varname>m_a[0]</varname>, <varname>m_a[1]</varname>) represents the portion of the first curve's domain that overlaps with the second curve, whereas in other cases <varname>m_a[1]</varname> is simply a duplicate of <varname>m_a[0]</varname>.
          </para>
          <para>
            As a result, a pattern seen repeatedly in the NURBS boolean evaluation implementation is a loop over intersection events that gathers intersection points for processing, including overlap endpoints if the event represents an overlap.
          </para>
          <programlisting>
            <![CDATA[
for (int i = 0; i < x_event.Count(); ++i) {
    x_points.Append(x_event[i].m_a[0]);
    if (x_event[i].m_type == ON_X_EVENT::ccx_overlap) {
        x_points.Append(x_event[i].m_a[1]);
    }
}
            ]]>
	  </programlisting>
        </note>
        <variablelist>
          <varlistentry>
            <term><varname>ON_X_EVENT::ccx_overlap</varname></term>
            <listitem>
              <para>
                Two curves are coincident with one another over a portion of their domains.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_overlap</varname></term>
            <listitem>
              <para>
                Two surfaces are coincident over a portion of their domains.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_tangent</varname>, <varname>ON_SSX_EVENT::ssx_transverse</varname></term>
            <listitem>
              <para>
                Two surfaces intersect in a curve. If the normals of the surfaces are parallel over all points of the curve, the intersection is tangent, and transverse otherwise.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_tangent_point</varname>, <varname>ON_SSX_EVENT::ssx_transverse_point</varname></term>
            <listitem>
              <para>
                Two surfaces intersect at a point. The intersection is tangent if the normals of the two surfaces are parallel at that point, and transverse otherwise.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <note>
          <para>
            An additional class, <classname>ON_PX_EVENT</classname> has been implemented as an extension to the OpenNURBS API to represent point-point, point-curve, and point-surface intersection events.
          </para>
        </note>
      </section>
    </section>
    <section>
      <title>Code Conventions and Pitfalls</title>
      <section>
        <title>2D vs 3D</title>
        <para>
          Implicit in working with parametric geometry is that some operations are done in 2D while others are done in 3D and it's very important to know the dimension currently being worked in at all times.
        </para>
        <para>
          As mentioned in the section above on 2D and 3D points, 3D classes are often used in the implementation to store 2D points, and thus are not a reliable indication that an operation is happening in 3D.
        </para>
        <para>
          Being that operations in 2D tend to be a lot simpler, 2D is normally the dimension being worked in. However, because parametric curves and surfaces of different objects have different parameterizations, determining where two objects intersect can't be done by comparing 2D parameters; it must happen in 3D.
        </para>
        <section>
          <title>Naming Convention</title>
          <para>
            Generally, when 2D and 3D operations are taking place near one another, you'll see a naming convention being used to disambiguate 2D and 3D data. 3D identifiers are unadorned, while 2D names will be suffixed with 1/2 or A/B.
          </para>
          <para>
            Suppose for example we have three arrays of corresponding points that are samples along an intersection curve between two surfaces. The 3D array might simply be named <varname>points</varname>. The corresponding 2D points in the domains of the two surfaces involved are then  very likely to be named <varname>points1</varname> and <varname>points2</varname> or <varname>pointsA</varname> and <varname>pointsB</varname>. Whether the 1/2 or A/B suffixes are used typically depends on whether the input surfaces have names like <varname>surf1</varname>/<varname>surf2</varname> or <varname>surfA</varname>/<varname>surfB</varname>. The latter is more likely to be used when processing intersection events, as members of the OpenNURBS intersection event classes are named <varname>m_a</varname> and <varname>m_b</varname>, etc.
          </para>
        </section>
        <section>
          <title>Intersection Tolerances</title>
          <para>
            The ON_Intersect intersection routines (<filename>intersect.cpp</filename>) generally take an <varname>isect_tol</varname> argument, which is a 3D tolerance normally equal to the constant <varname>ON_INTERSECTION_TOL</varname>. 2D tolerances, following the convention described above, are generally named <varname>isect_tolA</varname> and <varname>isect_tolB</varname>.
          </para>
          <para>
            2D tolerance values for curves and surfaces are derived from the 3D tolerance value using the <function>tolerance_2d_from_3d</function> routines. The length of the diagonal of the 3D bounding box of the curve or surface is divided by the length of the 2D domain to get a rough estimate of what distance in the 2D domain corresponds to the 3D tolerance distance. In other words, the hope is that two points on a <varname>curveA</varname> or <varname>surfA</varname> that are <varname>isect_tolA</varname> units apart in 2D, will evaluate to two 3D points that are <varname>isect_tol</varname> units apart in 3D.
          </para>
          <warning>
            <para>
              The difference between <varname>isect_tol</varname> and <varname>isect_tolA</varname> and <varname>isect_tolB</varname> can be arbitrarily large, so it's import that the correct tolerance is used in all cases. However, it's sometimes tempting to use the wrong tolerance, for instance using the 2D <varname>isect_tolA</varname> in a 3D intersection test simply because the 3D points were evaluated from 2D points in the <varname>surfA</varname> domain.
            </para>
          </warning>
        </section>
        <section>
          <title>Curve Traversal Directions</title>
          <para>
            It's important to remember that because parameterizations are arbitrary, there is no correspondence whatsoever between a 2D curve in one surface's domain and another surface's domain, even when those curves evaluate to the same 3D curve. In particular, you cannot assume that traversing different curves along their domain from <varname>m_t[0]</varname> to <varname>m_t[1]</varname> translates to a consistent direction in 3D. Put more simply, you cannot assume that the start and end points of such curves correspond in any particular way.
          </para>
          <warning>
            <para>
              Suppose you have an open 3D intersection <varname>curve</varname> spanning two 3D points <code>start = curve->PointAtStart()</code> and <code>end = curve->PointAtEnd()</code>. You also have the corresponding 2D curve in the domains of the two surfaces producing the intersection, a <varname>curveA</varname> spanning the points <code>startA = curveA->PointAtStart()</code> and <code>endA = curveA->PointAtEnd()</code>, and a <varname>curveB</varname> spanning the points <code>startB = curveB->PointAtStart()</code> and <code>endB = curveB->PointAtEnd()</code>.
            </para>
            <para>
              In this example, you cannot assume that (within tolerance) <code>startA == startB == start</code>. It could be that <code>startA == start</code> but <code>startB == end</code>, or that <code>startB == start</code> but <code>startA == end</code>, or that <code>startA == startB == end</code>.
            </para>
            <para>
              If <varname>curve</varname> is a closed loop, then you can't assume even that much. You would have (within tolerance) <code>start == end</code>, <code>startA == endA</code>, <code>startB == endB</code>. However, it could be that the "break" in the loop is different in every parameterization, so that <code>start != startA != startB</code>.
            </para>
          </warning>
        </section>
      </section>
      <section>
        <title>Accumulated Error</title>
        <para>
          By the nature of the math involved in representing parametric geometry, converting between 2D and 3D, and solving intersections between objects with different parameterizations, values that are expected to be identical are generally only equal within a certain tolerance, or error.
        </para>
        <para>
          Over the course of the evaluation, the same data is interrogated and processed a number of times. If ignored, the error introduced in one stage of the evaluation can grow over subsequent stages, causing an incorrect determination that leaves a curve unclosed, a surface unsplit, and ultimately an incorrect evaluated result.
        </para>
        <para>
          As a consequence, it's generally a good idea to remove fuzziness when you find it, and avoid algorithms that introduce more error.
        </para>
        <section>
          <title>Clamping</title>
          <para>
            Start and end points of closed curves are rarely identical. So if a curve is found to be closed within tolerance, it's a good idea to actually set the end point equal to the start point. Similarly, if an interval of a domain is calculated whose endpoints are within tolerance of the domain endpoints, the entire domain should be used.
          </para>
          <note>
            <para>
              Producing subcurves of existing curves is a common operation in the NURBS boolean evaluation implementation. This is a prime example of an operation that can introduce fuzziness into the evaluation. For example, we may be splitting a curve to remove a portion of it, and end up with two new curves with endpoints that used to align when part of the original curve, but no longer do.
            </para>
            <para>
              The <function>Split</function> method of <classname>ON_Curve</classname> can be used to produce subcurves, but in the implementation it's much preferred to use the <function>sub_curve</function> function defined in <filename>intersect.cpp</filename> which wraps <function>Split</function> and correctly handles clamping of curve parameters to domain endpoints.
            </para>
          </note>
        </section>
        <section>
          <title>Iterated Solutions</title>
          <para>
            The iterative method used to solve points on parametric curves and surfaces is expected to produce better answers given better inputs and more iterations. However, our algorithms can't always produce sufficient inputs, and the value the solver converges on isn't always the correct one.
          </para>
          <para>
            This fuzziness produced in the solver's results can be mitigated in the context of finding intersection curves for example, because we solve many points and fit a curve between them. So, one unsolved point on the curve isn't going to cause an evaluation failure.
          </para>
          <warning>
            <para>
              It's tempting to test curve characteristics or make inside/outside determinations, etc. by using the <function>ON_Intersect</function> functions. However, there's a persistent risk that the error in the iteratively solved results will cause incorrect determinations that cascade into larger problems over the course of the evaluation. For this reason, the <function>ON_Intersect</function> functions should be avoided whenever possible.
            </para>
          </warning>
        </section>
      </section>
    </section>
  </section>
</article>
