<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">

  <info>
    <title>NURBS Boolean Evaluation Development Guide</title>
    <author>
      <personname>
        <firstname>Nicholas</firstname>
        <surname>Reed</surname>
      </personname>
    </author>
  </info>

  <section>
    <title>NURBS Boolean Evaluation Using the brep Command</title>
    <section>
      <title>Known Limitations</title>
      <itemizedlist>
        <listitem>
          <para>
            Frequently produces incorrect output due to unhandled
            intersection cases.
          </para>
        </listitem>
        <listitem>
          <para>
            Unoptimized performance.
          </para>
        </listitem>
	<listitem>
          <para>
            Material properties of source objects are discarded.
          </para>
        </listitem>
	<listitem>
          <para>
            Some primitive conversions to NURBS are ill-defined.
          </para>
        </listitem>
	<listitem>
          <para>
            Hollow objects are not built topologically continuous.
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Evaluating a Combination Using the brep Command</title>
      <para>
        The <function>brep</function> command is available in the MGED
        and Archer applications. If the command is run with a single argument
        <literal>obj</literal> naming a combination, the components
        of the combination are converted into NURBS objects which are
        combined into a single evaluated NURBS object according to the
        Boolean operations in the combination.
      </para>
      <para>
        The evaluated brep-type object is written to the database with
        the name <literal>obj_brep</literal>. If a second argument is
        provided to the <function>brep</function> command, then it is
        used as the name for the evaluated brep.
      </para>
    </section>
  </section>

  <section>
    <title>Overview of the Implementation</title>
    <section>
      <title>Major Algorithms</title>
      <section>
        <para>
          The overall NURBS Boolean Evaluation algorithm is based on
          the paper <emphasis>BOOLE: A System to Compute Boolean
          Combinations of Sculptured Solids.</emphasis> (S. Krishnan
          et al., 1995). The main implementation file for the Boolean
          Evaluation algoritm is
          <filename>src/libbrep/boolean.cpp</filename>.
        </para>
        <para>
          The NURBS Surface-Surface intersection algorithm is based on
          the "NURBS Intersection Curve Evaluation" section of the
          paper <emphasis>Performing Efficient NURBS Modeling
          Operations on the GPU</emphasis> (A. Krishnamurthy et
          al., 2008). A detailed outline of the algorithm, as
          implemented, appears in the main implementation file for the
          NURBS Surface-Surface intersection algorithm is
          <filename>src/libbrep/intersection.cpp</filename>.
        </para>
      </section>        
    </section>
    <section>
      <title>Description of Major Functions</title>
      <section>
	<title><filename>src/libbrep/boolean.cpp</filename></title>
	<synopsis>
	<![CDATA[
int
ON_Boolean(
    ON_Brep *evaluated_brep,
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	In the nontrivial case where the bounding boxes of <parameter>brep1</parameter> and <parameter>brep2</parameter> intersect, <function>get_evaluated_faces</function> is called to get the trimmed NURBS faces of the evaluated boolean result. The faces are then combined into a single brep object returned via the <parameter>evaluated_brep</parameter> argument. 
	</para>
	<synopsis>
	<![CDATA[
ON_ClassArray< ON_SimpleArray<Trimmed Face *> >
get_evaluated_faces(
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	The intersection curves between the faces of <parameter>brep1</parameter> and <parameter>brep2</parameter> are found by <function>get_face_intersection_curves</function>. These curves are used to split the original surfaces into pieces, each becoming a new trimmed NURBS face. The <function>categorize_trimmed_faces</function> function is used to identify which pieces, based on the boolean operation, are part of the evaluated result. Each <classname>TrimmedFace</classname> whose <varname>m_belong_to_final</varname> member is marked <constant>TrimmedFace::BELONG</constant> is used by <function>ON_Boolean</function> to create the final evaluated result.
	</para>
	<synopsis>
	<![CDATA[
ON_ClassArray< ON_SimpleArray<SSICurve> >
get_face_intersection_curves(
    ON_SimpleArray<Subsurface *> &surf_tree1,
    ON_SimpleArray<Subsurface *> &surf_tree2,
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	    Each pair of <parameter>brep1</parameter> and <parameter>brep2</parameter> surfaces whose bounding boxes intersect are passed to the <function>ON_Intersect</function> surface-surface intersection routine. The surface-surface intersection curves are then clipped using the trimming curves of the associated faces by the <function>get_subcurves_inside_faces</function> routine.
	</para>
      </section>
      <section>
	<title><filename>src/libbrep/intersect.cpp</filename></title>
	<synopsis>
	<![CDATA[
int
ON_Intersect(const ON_Surface *surfA,
             const ON_Surface *surfB,
             ON_ClassArray<ON_SSX_EVENT> &x,
             double isect_tol,
             double overlap_tol,
             double fitting_tol,
             const ON_Interval *surfaceA_udomain,
             const ON_Interval *surfaceA_vdomain,
             const ON_Interval *surfaceB_udomain,
             const ON_Interval *surfaceB_vdomain,
             Subsurface *treeA,
             Subsurface *treeB);
	]]>
	</synopsis>
	<para>
	    The first stage of the surface-surface intersection
	    algorithm attempts to identify overlap intersections
	    (areas where the two surfaces are coincident). Our
	    assumption is that the boundary curve of any overlap
	    region must be formed from isocurves of the overlapping
	    surfaces.
        </para>
        <para>
            Subcurves of isocurves that intersect both
	    surfaces, such that the surfaces are coincident on one
	    side of the curve but not the other, potentially form part
	    of overlap boundaries. These curves are identified using
	    <function>find_overlap_boundary_curves</function>, which
	    may also return some intersection points and curves that
	    aren't on overlap boundaries to avoid wasted effort.
        </para>
        <para>
            Then, the
            <function>split_overlaps_at_intersections</function>
            function is run, and curves that share endpoints are
            stitched together. Stitched curves that close to form
            loops are recorded as overlap intersection events.
	</para>
	<para>
	The second stage of the surface-surface intersection algorithm
	attempts to identify other intersection curves and points. The
	input surfaces <parameter>surfA</parameter> and
	<parameter>surfB</parameter> are subdivided into four
	subsurfaces, whose bounding boxes are tested in pairs for
	intersection. This subdivision repeats to a fixed depth
	determined by <constant>MAX_SSI_DEPTH</constant>.
        </para>
        <para>
          Subsurfaces that lie completely inside an overlap region
          identified in the first stage are discarded. Each final pair
          of subsurfaces with intersecting bounding boxes is
          approximated with two triangles. The triangles are then
          intersected, and the average of all intersection points is
          used as the initial guess for a Newton iterative solver,
          implemented by <function>newton_ssi</function>, which
          searches for a point close to the initial guess point which
          lies on both surfaces.
        </para>
        <para>
          Solved points that lies inside an overlap region identified
          in the first stage are discarded. Nearby points in the set
          of solved intersection points between
          <parameter>surfA</parameter> and
          <parameter>surfB</parameter> are then stitched together into
          polyline curves. If a line or conic curve can be fit to the
          polyline curves in 2D, the fit curve replaces the original
          <parameter>surfA</parameter> and/or
          <parameter>surfB</parameter> polyline curve.
	</para>
      </section>
    </section>
    <section>
      <title>The OpenNURBS API</title>
      <para>
        BRL-CAD leverages the OpenNURBS library primarily for its classes that represent general (NURBS) b-rep, surface, curve, and point geometry. The following sections describe the OpenNURBS library symbols most frequently used in the NURBS boolean evaluation implementation, with relevant usage notes.
      </para>
      <warning>
        <para>
          When using an OpenNURBS utility that hasn't been used elsewhere in the implementation, always check the documentation <emphasis>and</emphasis> the implementation to make sure it does what you expect.
        </para>
        <para>
          Misleading methods have been misused in the past. For example, <function><![CDATA[bool ON_Line::InPlane(ON_Plane& plane)]]></function> appears to test if a line lies in the given plane, but actually constructs a plane that contains the line.
        </para>
        <para>
          Another example is <function><![CDATA[double ON_Line::MinimumDistanceTo(const ON_Line&)]]></function>. While the function does indeed return the distance of the shortest path between one line and another, reading the implementation reveals an undocumented assumption that the <classname>ON_Line</classname> provided as an argument is not on the same infinite line as the instance the method is invoked on. That is, the <classname>ON_Line</classname>s can be parallel, but not coincident.
        </para>
      </warning>
      <section>
        <title>Arrays</title>
        <para>
          OpenNURBS includes two general array classes similar to C++'s <classname>std::vector</classname>, <classname>ON_ClassArray</classname> and <classname>ON_SimpleArray</classname>. Besides having slightly friendlier interfaces, they also feature some higher-level member functions like <function>Reverse</function> and <function>Quicksort</function>.
        </para>
        <para>
          The primary difference between the two classes is that <classname>ON_SimpleArray</classname> doesn't bother constructing and destructing its items. This makes it more efficient than <classname>ON_ClassArray</classname>, but unsuitable for class objects (though pointers to objects are fine). <classname>ON_ClassArray</classname> requires items to have working copy/assignment functions.
        </para>
	<para>
	  The NURBS boolean evaluation implementation frequently employs a combined array of known size to index elements from two input objects. For example, if <parameter>brepA</parameter> has <inlineequation><mathphrase>i</mathphrase></inlineequation> faces and <parameter>brepB</parameter> has <inlineequation><mathphrase>j</mathphrase></inlineequation> faces, a single array of <inlineequation><mathphrase>i + j</mathphrase></inlineequation> elements is created.
	</para>
	<warning>
	  <para>
	    The OpenNURBS array classes do not check for out-of-bounds indexing. This isn't a problem in the simple case where items are added with <function>Append</function> and elements <inlineequation><mathphrase>[0, </mathphrase></inlineequation><function>Count()</function><inlineequation><mathphrase> - 1]</mathphrase></inlineequation> are iterated over.
	  </para>
	  <para>
	    However, if the array will be a fixed size whose items are assigned in a non-sequential order, both the <emphasis>capacity</emphasis> and <emphasis>count</emphasis> should be set, or else the reported <function>Count</function> will be incorrect, and copying arrays by assignment won't work.
	  </para>
	  <programlisting>
	<![CDATA[
	ON_ClassArray< ON_SimpleArray<SSICurve> > curves_array(face_count1 + face_count2);
	curves_array.SetCount(curves_array.Capacity());
	]]>
	  </programlisting>
	</warning>
      </section>
      <section>
        <title>Memory</title>
        <para>
          Curves and surfaces are nearly always allocated on the heap and referenced by pointers, both in the OpenNURBS library, and in the NURBS boolean evaluation implementation.
        </para>
        <para>
          Mostly these allocations are simply done with the <code>new</code> keyword as with any other class. However, a few classes, noteably <classname>ON_Brep</classname> have a <function>New()</function> function that wraps the allocation, which is preferred over using <code>new</code> directly for technical reasons specified in <filename>opennurbs_brep.h</filename>.
        </para>
        <para>
          Pointers to objects, curves in particular, are frequently stolen rather than creating a new copy of the object.
          <warning>
            <para>
              Classes containing heap-allocated objects delete them in their destructors. Proper stealing of pointers requires the instance's members be set to NULL.
            </para>
	    <programlisting>
	      <![CDATA[
ON_SimpleArray<ON_SSX_EVENT> x;
...
for (int i = 0; i < csx_events.Count(); ++i) {
    // copy event
    x.Append(csx_events[i]);

    // clear pointers from original so they aren't deleted by the
    // ON_SSX_EVENT destructor
    csx_events[i].m_curveA = NULL;
    csx_events[i].m_curveB = NULL;
    csx_events[i].m_curve3d = NULL;
}
	      ]]>
	    </programlisting>
          </warning>
        </para>
      </section>
      <section>
        <title>Tolerance Tests</title>
        <para>
          The OpenNURBS routines make extensive use of the symbol <varname>ON_ZERO_TOLERANCE</varname> in calculations to test if a result is to be considered equal to zero, or if two values are to be considered equal.
        </para>
        <note>
          <para>
            The NURBS boolean evaluation implementation frequently uses the function <function>ON_NearZero(double x, double tolerance = ON_ZERO_TOLERANCE)</function> to check if values are near zero, or to check if two values are identical (e.g <function>ON_NearZero(t - last_t)</function>).
          </para>
          <para>
            This function is also used to determine if objects are close enough to be considered intersecting: <function>ON_NearZero(pt.DistanceTo(other.pt), INTERSECTION_TOL)</function>.
          </para>
        </note>
      </section>
      <section>
	<title>2D and 3D Points</title>
	<para>
	  The <classname>ON_2dPoint</classname> and <classname>ON_3dPoint</classname> classes implement the expected operators allowing points to be easily summed and scaled.
	</para>
	<para>
	  The <function>operator[]</function> functions are notable because coordinates are not actually stored as arrays in these classes, but rather in the named members <varname>x</varname>, <varname>y</varname>, and <varname>z</varname>. So while accessing coordinates as <varname>pt[0]</varname>, <varname>pt[1]</varname> is possible, the more readable <varname>pt.x</varname>, <varname>pt.y</varname>, is more typically seen.
	</para>

	<para>
	  The most frequently used member function is <function><![CDATA[DistanceTo(const ON_3dPoint &p)]]></function>, used to check inter-point distances, either as part of an intersection test or to identify closeable gaps or duplicate points.
	</para>
	<note>
	  <para>
	    <classname>ON_2dPoint</classname> objects can be, and are, safely passed to functions that take <classname>ON_3dPoint</classname> arguments. The <classname>ON_3dPoint</classname> arguments are constructed from the provided <classname>ON_2dPoint</classname> objects, with their <varname>z</varname> coordinates set to 0.
	  </para>
          <para>
            The NURBS boolean evaluation implementation frequently constructs 2D curves by populating an <classname>ON_3dPointArray</classname> with 2D points, rather than using an <classname>ON_2dPointArray</classname>, as the 3D version of the class (besides having additional useful member functions), can be used to initialize an <classname>ON_PolylineCurve</classname>.
          </para>
	</note>
      </section>
      <section>
	<title>Bounding Boxes</title>
        <para>
        <classname>ON_BoundingBox</classname> is returned by the <function>BoundingBox</function>, <function>GetTightBoundingBox</function>, and <function>GetBBox</function> functions, which are implemented by all geometry classes inheriting from <classname>ON_Geometry</classname>.
        </para>
        <para>
          The most commonly used members of <classname>ON_BoundingBox</classname> are <function>Diagonal</function> (usually in an expression such as <varname>bbox.Diagonal().Length()</varname> used as a scalar size estimate), and <function>IsPointIn</function> and <function>MinimumDistanceTo</function> (used in intersection tests).
        </para>
      </section>
      <section>
	<title>Domain Intervals</title>
	<para>
	  <classname>ON_Interval</classname> is used to represent the domains of parametric curves and surfaces. The domain <emphasis>starts</emphasis> at <varname>m_t[0]</varname> and <emphasis>ends</emphasis> at <varname>m_t[1]</varname>. These members can be set directly or via <function>Set(double t0, double t1)</function>.
	</para>
	<warning>
	  <para>
	    The start, end, and overall length of the domain are <emphasis>arbitrary</emphasis>, and <varname>m_t[0]</varname> need not be less than <varname>m_t[1]</varname>. If the numerically smaller or larger domain endpoint is needed, these should be accessed via the <function>Min</function> and <function>Max</function> member functions.
	  </para>
	</warning>
	<para>
	  The <function>ParameterAt(double x)</function> function translates a <emphasis>normalized</emphasis> parameter (from a domain starting at 0.0 and ending at 1.0) into a <emphasis>real</emphasis> parameter. Thus, the start of the domain is at <varname>domain.ParameterAt(0.0)</varname>, the midpoint is at <varname>domain.ParameterAt(.5)</varname>, etc.
	</para>
      </section>
      <section>
	<title>Parametric Curves</title>
	<para>
	  The most frequently used geometry class is <classname>ON_Curve</classname>, a generic container for parametric curves. The curve is interrogated by using the <function>PointAt(double t)</function> method to evaluate points at arbitrary values inside the curve's domain, which is specified by the <classname>ON_Interval</classname> returned by the <function>Domain()</function> method. The start and end points of the curve have dedicated access methods, <function>PointAtStart()</function> and <function>PointAtEnd()</function>.
	</para>
	<warning>
	  <para>
	    <function>PointAt</function> takes a real parameter; parameters normalized to <inlineequation><mathphrase>[0, 1]</mathphrase></inlineequation> must be converted. For example, the midpoint of the curve can be found as <varname>curve->PointAt(curve->Domain().ParameterAt(.5))</varname>. <function>PointAt</function> <emphasis role="bold">does not check</emphasis> if the <parameter>t</parameter> value you give it is inside the curve's domain, so you have to get this right!
	  </para>
	</warning>
	<para>
	  All the <function>PointAt</function> methods return an <classname>ON_3dPoint</classname>, though in the common case where <classname>ON_Curve</classname> objects are representing 2D trim curves, the z coordinate will be 0.0.
	</para>
	<para>
	  The curve's domain is frequently reversed using the <function>Reverse()</function> method to facilitate stitching curves together. The function has a boolean <type>int</type> return value that must be checked.
	</para>
	<para>
	  <programlisting>
<![CDATA[
if (curveA->PointAtStart().DistanceTo(curveB->PointAtStart()) < dist_tol) {
  if (curveA->Reverse()) {
      curveA = link_curves(curveA, curveB);
  }
}
]]>
	  </programlisting>
	</para>
	<warning>
	  <para>
	    Comparing curve endpoints, or even just bounding boxes (retrieved via the <function>BoundingBox()</function> method), is often sufficient in the context of different intersection and stitching procedures. However, it's important to keep in mind that in the general case, the shape of the curve between its endpoints or within its bounding box could be anything. For example, two curves with matching endpoints could both be linear, creating a degenerate loop. A curve whose endpoints are equal within the OpenNURBS <constant>ON_ZERO_TOLERANCE</constant> (testable using the <function>IsClosed()</function> method), may be self-intersecting, or degenerate to a point.
	  </para>
	</warning>
	<para>
	  A copy of the curve can be easily made using the <function>Duplicate()</function> member function, which simply wraps a standard copy procedure:
	</para>
	<programlisting>
ON_Curve* Duplicate()
{
  ON_Curve *p = new ON_Curve;
  if (p) *p = *this;
  return p;
}
	</programlisting>
	<para>
	  This function is common to all OpenNURBS geometry classes, but curves are by far the most frequently duplicated objects. However, if curves are simply being retained from a working set of container objects, the curve pointers are frequently stolen rather than copied, with curve members set to <constant>NULL</constant> so that the curves aren't destructed with the containers.
	</para>
      </section>
      <section>
	<title>Lines</title>
	<para>
	  <classname>ON_Line</classname> is used to represent an infinite line, defined by two points, <varname>from</varname> and <varname>to</varname>.
	</para>

	<para>
	  <classname>ON_Line</classname> is not a subclass of <classname>ON_Curve</classname> and should not be confused with <classname>ON_LineCurve</classname> (which has an <classname>ON_Line</classname> member), though it does have some of the same methods as an <classname>ON_Curve</classname> class, including <function>PointAt(double t)</function>. However, because the line has an infinite domain, it can be evaluated at any <varname>t</varname> value, though evaluating at 0.0 returns <varname>from</varname> and evaluating at 1.0 returns <varname>to</varname>, as if the line was a parametric curve with a domain between 0.0 and 1.0.
	</para>

	<para>
	  <classname>ON_Line</classname> has helpful line-specific methods such as <function><![CDATA[ClosestPointTo(const ON_3dPoint &point)]]></function>. Again, because the line is treated as infinite, this function doesn't necessarily return a point in the segment between <varname>from</varname> and <varname>to</varname>.
	</para>

	<para>
	</para>
      </section>
      <section>
	<title>Surfaces</title>
	<para>
	  An <classname>ON_Surface</classname> has a similar interface to an <classname>ON_Curve</classname>, but adapted to support the surface's two domains, <parameter>u</parameter> and <parameter>v</parameter> (sometimes called <parameter>s</parameter> and <parameter>t</parameter>) which correspond with 0 and 1 (first example) or <parameter>x</parameter> and <parameter>y</parameter> (second example).
	</para>
	<example>
	  <title>Projecting an arbitrary <inlineequation><mathphrase>(u, v)</mathphrase></inlineequation> point into 3D.</title>
	  <programlisting>
<![CDATA[
ON_Interval udom = surface->Domain(0);
ON_Interval vdom = surface->Domain(1);
ON_3dPoint surf_midpt_3d = surface->PointAt(udom.ParameterAt(.5), vdom.ParameterAt(.5));
]]>
	  </programlisting>
	</example>
	<example>
	  <title>Projecting a trim-curve point into 3d.</title>
	  <programlisting>
<![CDATA[
ON_Interval tdom = trim_curve->Domain();
ON_3dPoint trim_midpt_uv = trim_curve->PointAt(tdom.ParameterAt(.5));
ON_3dPoint trim_midpt_3d = surface->PointAt(trim_midpt_uv.x, trim_midpt_uv.y);
]]>
	  </programlisting>
	</example>
      </section>
      <section>
	<title>Boundary Representation Objects</title>
	<para>
	  <classname>ON_Brep</classname> is the top-level OpenNURBS class used to represent the two input objects and the evaluated result of the <function>ON_Boolean</function> function. The geometry is encoded as a collection of faces, which for our purposes should be topologically connected to enclose solid volumes.
	</para>
	<para>
	  An object's faces are <classname>ON_BrepFace</classname> objects stored in the <classname>ON_Brep</classname> face array, <varname>m_F</varname>.
	</para>
	<para>
	  Each <classname>ON_BrepFace</classname> is defined as the subset of an <classname>ON_Surface</classname> lying inside the face's <glossterm>outerloop</glossterm> (a.k.a. the <glossterm>face boundary</glossterm>) and outside all of its <glossterm>innerloops</glossterm> (a.k.a. <glossterm>trim loops</glossterm> or just <glossterm>trims</glossterm>). 
	</para>
	<para>
	  The loops of an <classname>ON_BrepFace</classname> are listed in its loop array <varname>m_li</varname> as indexes into the associated <classname>ON_Brep</classname> object's <classname>ON_BrepLoop</classname> array, <varname>m_L</varname>. The first (and possibly only) loop listed in the face's loop index array is the outerloop, and all following loops are inner trim loops. The type of the loop is also recorded in the loop's <varname>m_type</varname> member.
	</para>
	<programlisting>
brep->m_L[brep->m_F[0]->m_li[0]].m_type;      // ON_BrepLoop::outer
brep->m_L[brep->m_F[0]->m_li[1]].m_type;      // ON_BrepLoop::inner
...
brep->m_L[*brep->m_F[0]->m_li.Last()].m_type; // ON_BrepLoop::inner
	</programlisting>
      </section>
      <section>
        <title>Intersection Events</title>
        <para>
          There are two OpenNURBS classes for representing intersections. <classname>ON_X_EVENT</classname> is used for curve-curve and curve-surface intersections. <classname>ON_SSX_EVENT</classname> is used for surface-surface intersections.
        </para>
        <para>
          These classes enumerate a number of intersection types. The <varname>m_type</varname> of intersection events is frequently checked to determine how to further process them over the course of the evaluation.
        </para>
        <note>
          <para>
            The <varname>m_type</varname> of an intersection event determines how values in the <varname>m_a/m_b/m_A/m_B</varname> array members of the event instance are to be interpreted (documented in <filename>opennurbs_x.h</filename>).
          </para>
	  <warning>
	    <para>
	      It's very easy to confuse <varname>m_a</varname>, <varname>m_b</varname>, <varname>m_A</varname>, and <varname>m_B</varname>, as well as <varname>m_a[0]</varname> vs. <varname>m_a[1]</varname>, etc. This is especially true when copying and pasting code.
	    </para>
	  </warning>
	  <para>
	  </para>
          <para>
            For an <classname>ON_X_EVENT</classname> representing a curve-curve intersection whose <varname>m_type</varname> is <varname>ON_X_EVENT::ccx_overlap</varname>, (<varname>m_a[0]</varname>, <varname>m_a[1]</varname>) represents the portion of the first curve's domain that overlaps with the second curve, whereas in other cases <varname>m_a[1]</varname> is simply a duplicate of <varname>m_a[0]</varname>.
          </para>
          <para>
            As a result, a pattern seen repeatedly in the NURBS boolean evaluation implementation is a loop over intersection events that gathers intersection points for processing, including overlap endpoints if the event represents an overlap.
          </para>
          <programlisting>
            <![CDATA[
for (int i = 0; i < x_event.Count(); ++i) {
    x_points.Append(x_event[i].m_a[0]);
    if (x_event[i].m_type == ON_X_EVENT::ccx_overlap) {
        x_points.Append(x_event[i].m_a[1]);
    }
}
            ]]>
	  </programlisting>
        </note>
        <variablelist>
          <varlistentry>
            <term><varname>ON_X_EVENT::ccx_overlap</varname></term>
            <listitem>
              <para>
                Two curves are coincident with one another over a portion of their domains.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_overlap</varname></term>
            <listitem>
              <para>
                Two surfaces are coincident over a portion of their domains.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_tangent</varname>, <varname>ON_SSX_EVENT::ssx_transverse</varname></term>
            <listitem>
              <para>
                Two surfaces intersect in a curve. If the normals of the surfaces are parallel over all points of the curve, the intersection is tangent, and transverse otherwise.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_tangent_point</varname>, <varname>ON_SSX_EVENT::ssx_transverse_point</varname></term>
            <listitem>
              <para>
                Two surfaces intersect at a point. The intersection is tangent if the normals of the two surfaces are parallel at that point, and transverse otherwise.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <note>
          <para>
            An additional class, <classname>ON_PX_EVENT</classname> has been implemented as an extension to the OpenNURBS API to represent point-point, point-curve, and point-surface intersection events.
          </para>
        </note>
      </section>
    </section>
    <section>
      <title>Code Conventions and Pitfalls</title>
      <section>
        <title>2D vs 3D</title>
        <para>
          Implicit in working with parametric geometry is that some operations are done in 2D while others are done in 3D and it's very important to know the dimension currently being worked in at all times.
        </para>
        <para>
          As mentioned in the section above on 2D and 3D points, 3D classes are often used in the implementation to store 2D points, and thus are not a reliable indication that an operation is happening in 3D.
        </para>
        <para>
          Being that operations in 2D tend to be a lot simpler, 2D is normally the dimension being worked in. However, because parametric curves and surfaces of different objects have different parameterizations, determining where two objects intersect can't be done by comparing 2D parameters; it must happen in 3D.
        </para>
        <section>
          <title>Naming Convention</title>
          <para>
            Generally, when 2D and 3D operations are taking place near one another, you'll see a naming convention being used to disambiguate 2D and 3D data. 3D identifiers are unadorned, while 2D names will be suffixed with 1/2 or A/B.
          </para>
          <para>
            Suppose for example we have three arrays of corresponding points that are samples along an intersection curve between two surfaces. The 3D array might simply be named <varname>points</varname>. The corresponding 2D points in the domains of the two surfaces involved are then  very likely to be named <varname>points1</varname> and <varname>points2</varname> or <varname>pointsA</varname> and <varname>pointsB</varname>. Whether the 1/2 or A/B suffixes are used typically depends on whether the input surfaces have names like <varname>surf1</varname>/<varname>surf2</varname> or <varname>surfA</varname>/<varname>surfB</varname>. The latter is more likely to be used when processing intersection events, as members of the OpenNURBS intersection event classes are named <varname>m_a</varname> and <varname>m_b</varname>, etc.
          </para>
        </section>
        <section>
          <title>Intersection Tolerances</title>
          <para>
            The ON_Intersect intersection routines (<filename>intersect.cpp</filename>) generally take an <varname>isect_tol</varname> argument, which is a 3D tolerance normally equal to the constant <varname>ON_INTERSECTION_TOL</varname>. 2D tolerances, following the convention described above, are generally named <varname>isect_tolA</varname> and <varname>isect_tolB</varname>.
          </para>
          <para>
            2D tolerance values for curves and surfaces are derived from the 3D tolerance value using the <function>tolerance_2d_from_3d</function> routines. The length of the diagonal of the 3D bounding box of the curve or surface is divided by the length of the 2D domain to get a rough estimate of what distance in the 2D domain corresponds to the 3D tolerance distance. In other words, the hope is that two points on a <varname>curveA</varname> or <varname>surfA</varname> that are <varname>isect_tolA</varname> units apart in 2D, will evaluate to two 3D points that are <varname>isect_tol</varname> units apart in 3D.
          </para>
          <warning>
            <para>
              The difference between <varname>isect_tol</varname> and <varname>isect_tolA</varname> and <varname>isect_tolB</varname> can be arbitrarily large, so it's import that the correct tolerance is used in all cases. However, it's sometimes tempting to use the wrong tolerance, for instance using the 2D <varname>isect_tolA</varname> in a 3D intersection test simply because the 3D points were evaluated from 2D points in the <varname>surfA</varname> domain.
            </para>
          </warning>
        </section>
        <section>
          <title>Curve Traversal Directions</title>
          <para>
            It's important to remember that because parameterizations are arbitrary, there is no correspondence whatsoever between a 2D curve in one surface's domain and another surface's domain, even when those curves evaluate to the same 3D curve. In particular, you cannot assume that traversing different curves along their domain from <varname>m_t[0]</varname> to <varname>m_t[1]</varname> translates to a consistent direction in 3D. Put more simply, you cannot assume that the start and end points of such curves correspond in any particular way.
          </para>
          <warning>
            <para>
              Suppose you have an open 3D intersection <varname>curve</varname> spanning two 3D points <code>start = curve->PointAtStart()</code> and <code>end = curve->PointAtEnd()</code>. You also have the corresponding 2D curve in the domains of the two surfaces producing the intersection, a <varname>curveA</varname> spanning the points <code>startA = curveA->PointAtStart()</code> and <code>endA = curveA->PointAtEnd()</code>, and a <varname>curveB</varname> spanning the points <code>startB = curveB->PointAtStart()</code> and <code>endB = curveB->PointAtEnd()</code>.
            </para>
            <para>
              In this example, you cannot assume that (within tolerance) <code>startA == startB == start</code>. It could be that <code>startA == start</code> but <code>startB == end</code>, or that <code>startB == start</code> but <code>startA == end</code>, or that <code>startA == startB == end</code>.
            </para>
            <para>
              If <varname>curve</varname> is a closed loop, then you can't assume even that much. You would have (within tolerance) <code>start == end</code>, <code>startA == endA</code>, <code>startB == endB</code>. However, it could be that the "break" in the loop is different in every parameterization, so that <code>start != startA != startB</code>.
            </para>
          </warning>
        </section>
      </section>
      <section>
        <title>Accumulated Error</title>
        <para>
          By the nature of the math involved in representing parametric geometry, converting between 2D and 3D, and solving intersections between objects with different parameterizations, values that are expected to be identical are generally only equal within a certain tolerance, or error.
        </para>
        <para>
          Over the course of the evaluation, the same data is interrogated and processed a number of times. If ignored, the error introduced in one stage of the evaluation can grow over subsequent stages, causing an incorrect determination that leaves a curve unclosed, a surface unsplit, and ultimately an incorrect evaluated result.
        </para>
        <para>
          As a consequence, it's generally a good idea to remove fuzziness when you find it, and avoid algorithms that introduce more error.
        </para>
        <section>
          <title>Clamping</title>
          <para>
            Start and end points of closed curves are rarely identical. So if a curve is found to be closed within tolerance, it's a good idea to actually set the end point equal to the start point. Similarly, if an interval of a domain is calculated whose endpoints are within tolerance of the domain endpoints, the entire domain should be used.
          </para>
          <note>
            <para>
              Producing subcurves of existing curves is a common operation in the NURBS boolean evaluation implementation. This is a prime example of an operation that can introduce fuzziness into the evaluation. For example, we may be splitting a curve to remove a portion of it, and end up with two new curves with endpoints that used to align when part of the original curve, but no longer do.
            </para>
            <para>
              The <function>Split</function> method of <classname>ON_Curve</classname> can be used to produce subcurves, but in the implementation it's much preferred to use the <function>sub_curve</function> function defined in <filename>intersect.cpp</filename> which wraps <function>Split</function> and correctly handles clamping of curve parameters to domain endpoints.
            </para>
          </note>
        </section>
        <section>
          <title>Iterated Solutions</title>
          <para>
            The iterative method used to solve points on parametric curves and surfaces is expected to produce better answers given better inputs and more iterations. However, our algorithms can't always produce sufficient inputs, and the value the solver converges on isn't always the correct one.
          </para>
          <para>
            This fuzziness produced in the solver's results can be mitigated in the context of finding intersection curves for example, because we solve many points and fit a curve between them. So, one unsolved point on the curve isn't going to cause an evaluation failure.
          </para>
          <warning>
            <para>
              It's tempting to test curve characteristics or make inside/outside determinations, etc. by using the <function>ON_Intersect</function> functions. However, there's a persistent risk that the error in the iteratively solved results will cause incorrect determinations that cascade into larger problems over the course of the evaluation. For this reason, the <function>ON_Intersect</function> functions should be avoided whenever possible.
            </para>
          </warning>
        </section>
      </section>
    </section>
  </section>
  <section>
    <title>Debugging NURBS Boolean Evaluations</title>
    <para>
      The current ongoing development activity for NURBS Boolean Evaluation is debugging specific evaluation cases in order to find bugs and unhandled geometry cases in the implementation to support the evaluation of more geometry.
    </para>
    <para>
      Because NURBS Boolean Evaluation is an immature feature still in development, new changes are made in a separate branch of the BRL-CAD code repository, <link>https://sourceforge.net/p/brlcad/code/HEAD/tree/brlcad/branches/brep-debug/</link>.
    </para>
    <section>
      <title>Debug Plotting</title>
      <para>
        There are two Archer commands that can be used to plot
        individual components of brep NURBS objects to facilitate
        debugging.
      </para>
      <para>
        These commands work by creating temporary wireframe objects
        that are drawn in the view window. While drawn, these objects
        appear in the in-memory database, so the
        <function>ls</function> command will show these objects (with
        names like <varname><![CDATA[_BC_S_<obj>_646464]]></varname>
        or <varname><![CDATA[bool1_brep1_surface03838ff]]></varname>,
        but they are not saved with the database, and are deleted when
        erased from the dislay.
      </para>
      <note>
        <para>
          Debug wireframe objects are not drawn the same way as
          geometry, and do not trigger an automatic resize and refresh
          of the view. This means that after running a plot command,
          you may have to trigger a refresh manually (e.g. by running
          the <function>autoview</function> command or interactively
          rotating/resizing the view.
        </para>
        <para>
          Also be aware that debug wireframes are drawn in a variety
          of hard-coded colors to help distinguish different
          subcomponents. These colors were designed to be best visible
          using a view whose background color is black (this should be
          the default, but can be easily changed in Archer via the
          view window's right-click menu).
        </para>
      </note>
      <para>
      </para>
      <section>
        <title>The brep Command</title>
        <para>
          The Archer <function>brep</function> command (also
          implemented in MGED) can be used to get structural
          information about brep objects and visualize different
          subcomponents.
        </para>
        <para>
          Most importantly, <function>brep &lt;obj&gt; info</function>
          will report summary information, including the number of
          NURBS surfaces and faces and <function>brep &lt;obj&gt; plot
          S &lt;index&gt;</function> can be used to plot individual
          surfaces in 3D.
        </para>
        <para>
          This is the primary way you can conceptually link a surface
          or face index to the 3D geometry it represents. So if you
          notice an error in an object while viewing it in the editor,
          you can use the <function>brep</function> command to
          determine the index of the surface with the error, and then
          inspect the in-memory object in a debugger using that index
          into the final surface array, tracing that surface object to
          where it was created, etc.
        </para>
        <note>
          <para>
            For evaluations involving more than two objects, the final
            brep NURBS object is made by converting two leaf objects
            into breps, performing a boolean evaluation on them,
            converting the next relevent object to brep and combining it
            with the first intermediate evaluation to make a second
            intermediate evaluation, and so on up the tree.
          </para>
          <para>
            When debugging such cases, it's typically necessary to
            manually create an intermediate combination (a subtree of
            the one being evaluated), and use the
            <function>brep</function> command to produce the
            intermediate result so you can inspect the surfaces and
            indices for that particular stage of the larger evaluation.
          </para>
        </note>
      </section>
      <section>
        <title>The dplot Command</title>
        <para>
          The <function>dplot</function> command is used to visualize
          the results of different stages of the NURBS Boolean
          Evaluation algorithm. This makes it easier to isolate the
          source of a problem in an evaluation.
        </para>
        <para>
          Unlike the <function>brep</function> command, the
          <function>dplot</function> command is purely a development
          tool. It does not honor library boundaries and does not
          conform to the typical conventions for editor commands, and
          for this reason is only available as an Archer command in
          the NURBS Boolean Evaluation development branch
          (<link>https://sourceforge.net/p/brlcad/code/HEAD/tree/brlcad/branches/brep-debug/</link>).
        </para>
        <para>
          In the devlopment branch, the NURBS Boolean Evaluation
          source code contains additional calls to
          <classname>DebugPlot</classname> functions (implemented in
          <filename>src/libbrep/debug_plot.*</filename>) that create
          wireframe visualizations of data produced during the
          evaluations.
        </para>
        <para>
          For development convenience, these wireframes are not saved
          as database objects, but rather are written as files in the
          current directory, with names of the form
          <filename>bool1_*.plot3</filename>.  An additional
          <filename>bool1.dplot</filename> is written which describes
          the <filename>.plot3</filename> files that were written in a
          format understood by the <function>dplot</function> command.
        </para>
        <para>
          One set of files is written for each evaluation. Between
          evaluations, a static counter increments the numeric suffix
          that's used in the output filenames. So for a combination
          consisting of three objects, the <filename>bool1*</filename>
          files will hold results from the intermediate boolean
          evaluation between the first two objects in the combination,
          and the <filename>bool2*</filename> files will hold results
          from the final evaluation between the intermediate evaluated
          object and the remaining leaf of the original comb.
        </para>
        <para>
          The <classname>DebugPlot</classname> functions always use
          the same file names and do not check if written files
          already exist. It is assumed that you will run an
          evaluation, inspect the generated files using the
          <function>dplot</function> command, and then manually remove
          (or just move) the generated <filename>.dplot</filename> and
          <filename>.plot3</filename> files before performing another
          evaluation with the <function>brep</function> command.
        </para>
        <section>
          <title>The ssx Subcommands</title>
          <itemizedlist>
            <listitem>
              <para>
                <emphasis role="bold"><function>dplot bool1.dplot
                ssx</function></emphasis> lets you interactively step
                through the pairs of surfaces whose axis-aligned
                bounding boxes were found to intersect. The wireframes
                of the brep objects being intersected are drawn with
                the current surface pair highlighted. The
                <varname>ssx_index</varname> assigned to the pair,
                which can be used as an argument to other dplot
                commands, is displayed in the command window.
              </para>
            </listitem>
	    <listitem>
              <para>
		<emphasis role="bold"><function>dplot bool1.dplot
		&lt;ssx_index&gt;</function></emphasis> lets you
		interactively step through the specific
		surface-surface intersections found between the pair
		of surfaces identified by an
		<varname>ssx_index</varname>, excluding
		isocurve-surface intersections (shown by
		<function>dplot bool1.dplot isocsx</function>).
              </para>
	      <para>
		To make it easier to check that drawn intersection
		curves are of the correct type and are open or closed
		curves as appropriate, intersections are color-coded
		by type (e.g. transverse intersections are drawn in
		yellow) and the ends of lines are decorated with
		arrows to indicate open ends or perpendicular segments
		to indicate coincident endpoints.
	      </para>
	    </listitem>
          </itemizedlist>
	  <para>
	    The ssx pairs are recorded in the
	    <function>find_overlap_boundary_curves</function> function
	    in <filename>src/libbrep/intersect.cpp</filename>.
	  </para>
        </section>
        <section>
          <title>The isocsx Subcommands</title>
          <itemizedlist>
            <listitem>
              <para>
		<emphasis role="bold"><function>dplot bool1.dplot
		isocsx &lt;ssx_index&gt;</function></emphasis> lets
		you step through the isocurve-surface intersections
		from the pair of intersecting surfaces identified by
		the given <varname>ssx_index</varname>. Wireframe
		plots of the two surfaces are drawn, with one surface
		and an intersecting isocurve of the second surface
		highlighted. Each combination of isocurve and surface
		is assigned an <varname>isocsx_index</varname> (shown
		in the command window) that can be used as an argument
		in the second form of the <function>isocsx</function>
		subcommand.
	      </para>
	    </listitem>
            <listitem>
              <para>
		<emphasis role="bold"><function>dplot bool1.dplot
		isocsx &lt;ssx_index&gt;
		&lt;isocsx_index&gt;</function></emphasis> shows the
		actual intersection curve found between the isocurve
		and surface pair identified by the given
		<varname>ssx_index</varname> and
		<varname>isocsx_index</varname>.
	      </para>
	      <para>
		The plotted intersection curves are color-coded for
		easy type-checking, e.g. overlap intersections are
		drawn in green.
	      </para>
	    </listitem>
	  </itemizedlist>
	  <para>
	    The isocsx curves are written in the
	    <function>find_overlap_boundary_curves</function> function in
	    <filename>src/libbrep/intersect.cpp</filename>.
	  </para>
	</section>
        <section>
          <title>Face-Evaluation Subcommands</title>
          <itemizedlist>
            <listitem>
              <para>
		<emphasis role="bold"><function>dplot bool1.dplot
		fcurves &lt;ssx_index&gt;</function></emphasis> lets
		you step through the surface-surface intersection
		curves identified by the given
		<varname>ssx_index</varname> after they've been
		clipped by face trimming curves.
	      </para>
	      <para>
		The clipped 2D intersection curves for the first
		surface are drawn projected to 3D, followed by the
		matching curves for the second surface.
	      </para>
	    </listitem>
            <listitem>
              <para>
		<emphasis role="bold"><function>dplot bool1.dplot
		lcurves</function></emphasis> steps through the final
		3D intersection curves used to split faces, after
		contiguous face-clipped pieces have been linked
		together.
	      </para>
	      <para>
		After each curve is drawn independently, all curves are
		drawn at the same time.
	      </para>
	      <para>
		This subcommand doesn't draw any contextual geometry;
		only the linked curves. Manually drawing a transparent
		shaded view of the original geometry usually works
		well for context.
	      </para>
	    </listitem>
            <listitem>
              <para>
		<emphasis role="bold"><function>dplot bool1.dplot
		faces</function></emphasis> lets you step through the
		new set of faces formed by splitting the original
		faces with the final linked intersection curves. Faces
		that are considered part of the final result are drawn
		highlighted, while faces that are discarded are drawn
		dim.
	      </para>
	      <para>
		After each face is drawn independently, all faces are
		drawn at the same time.
	      </para>
	      <para>
		This subcommand doesn't draw any contextual geometry;
		only the face curves. Manually drawing a transparent
		shaded view of the original geometry usually works
		well for context.
	      </para>
	    </listitem>
	  </itemizedlist>
          <para>
            The clipped face curves are recorded in
            <function>get_face_intersection_curves</function> in
            <filename>src/libbrep/boolean.cpp</filename>.
          </para>
          <para>
            The linked curves and the categorized split faces are
            recorded in <function>get_evaluated_faces</function> in
            <filename>src/libbrep/boolean.cpp</filename>.
          </para>
	</section>
      </section>
      <section>
        <title>Plotting Arbitrary Evaluation Curves</title>
        <para>
          It's possible to write out custom curves from any part of
          the evaluation (i.e. those not covered by
          <function>dplot</function>) and view them in MGED/Archer.
        </para>
        <para>
          You can pass a 3D <classname>ON_Curve</classname> to the
          <function>DebugPlot::Plot3DCurve</function> function or a 2D
          <classname>ON_Curve</classname> and an associated
          <classname>ON_Surface</classname> to the
          <function>DebugPlot::Plot3DCurve</function> function.
        </para>
        <para>
          Both of these functions take an arbitrary filename for a
          plot3 file the function will write, as well as a color for
          the curve. The <function>DebugPlot::Plot3DCurve</function>
          has an optional <varname>vlist</varname> parameter which you
          should omit (see the full definitions in
          <filename>src/libbrep/debug_plot.*</filename>).
        </para>
        <example>
	  <title>Writing a 2D Curve as a plot3 File</title>
	  <programlisting>
            <![CDATA[
// somewhere in boolean.cpp
if (face1_curves.Count() > 0) {
    static int calls = 0;
    unsigned char mycolor[] = {0, 0, 62};
    std::ostringstream plotname;

    // generate a unique filename
    plotname << "mycurve" << ++calls << ".plot3";

    // plot using method of global DebugPlot instance 'dplot'
    dplot->Plot3DCurveFrom2D(surf1, face1_curves[0],
        plotname.str().c_str(), mycolor);
}
            ]]>
	  </programlisting>
        </example>
        <para>
          After running an evaluation that produces a custom plot3
          file, you can draw it using the <function>overlay</function>
          editor command.
        </para>
        <example>
          <title>Drawing a plot3 File</title>
          <screen>
Archer> overlay mycurve1.plot3 1
          </screen>
	</example>
      </section>
    </section>
    <section>
      <title>Debugging with the dplot Command</title>
      <section>
        <title>Tracing Output to the Code That Created It</title>
        <para>
          After you notice a problem in the output shown by the
          <function>dplot</function> command, you need to locate the
          source code that created the erroneous geometry so you can
          start debugging. The following sections describe what
          specific actions to take in the editor and a debugger to
          start investigating some common issues.
        </para>
        <bridgehead>If the ssx subcommand shows that a surface-surface
        intersection is missing...</bridgehead>
        <orderedlist>
          <listitem>
            <para>
              Use the <function>info</function> and
              <function>plot</function> subcommands of the
              <function>brep</function> command to find the indexes
              (<literal>&lt;i&gt;</literal> and
              <literal>&lt;j&gt;</literal>) of the two faces involved
              in the missing intersection.
            </para>
            <para>
              For a multi-part evaluation, you'll need to manually
              create the appropriate intermediate evaluation,
              corresponding to the
              <filename>bool&lt;n&gt;.dplot</filename> showing the
              error, to run the <function>brep</function> command on.
            </para>
          </listitem>
          <listitem>
            <para>
              Set a breakpoint at the
              <function>ON_Intersect</function> call in
              <function>get_face_intersection_curves</function> with
              the condition <userinput>i == &lt;i&gt; &amp;&amp; j ==
              &lt;j&gt;</userinput>.
            </para>
            <para>
              For a multi-part evaluation, you'll need to first skip
              to the correct invocation of
              <function>ON_Boolean</function>, either manually, or by
              conditioning a breakpoint on the value of the static
              <varname>calls</varname> variable defined at the top of
              that function.
            </para>
          </listitem>
          <listitem>
            <para>
              Start stepping through the
              <classname>ON_Intersect</classname> call.
            </para>
          </listitem>          
        </orderedlist>
        <bridgehead>If the isocsx subcommand shows that an
        isocurve-surface intersection is missing...</bridgehead>
        <orderedlist>
          <listitem>
            <para>
              Note the index <literal>&lt;n&gt;</literal> of the
              surface-surface intersection used as the argument to the
              <function>isocsx</function> subcommand.
            </para>
          </listitem>
          <listitem>
            <para>
              Use the <function>info</function> and
              <function>plot</function> subcommands of the
              <function>brep</function> command to find the indexes
              (<literal>&lt;i&gt;</literal> and
              <literal>&lt;j&gt;</literal>) of the two faces involved
              in the missing intersection.
            </para>
            <para>
              For a multi-part evaluation, you'll need to manually
              create the appropriate intermediate evaluation,
              corresponding to the
              <filename>bool&lt;n&gt;.dplot</filename> showing the
              error, to run the <function>brep</function> command on.
            </para>
          </listitem>
          <listitem>
            <para>
              Set a breakpoint at the
              <function>ON_Intersect</function> call in
              <function>get_face_intersection_curves</function> with
              the condition <userinput>dplot->SurfacePairs() == &lt;n
              - 1&gt; &amp;&amp; i == &lt;i&gt; &amp;&amp; j ==
              &lt;j&gt;</userinput>.
            </para>
            <para>
              For a multi-part evaluation, you'll need to first skip
              to the correct invocation of
              <function>ON_Boolean</function>, either manually, or by
              conditioning a breakpoint on the value of the static
              <varname>calls</varname> variable defined at the top of
              that function.
            </para>
          </listitem>
          <listitem>
            <para>
              When the break is reached, add a breakpoint at
              <function>find_overlap_boundary_curves</function> and
              advance to that function.
            </para>
          </listitem>
          <listitem>
            <para>
              Step through the intersections, printing out the
              isocurve endpoints and visualize them in the context of
              the geometry in Archer (e.g. by centering the view at
              those points, or creating spheres centered on them,
              etc.) to find the isocurves of interest:
              <screen>
(gdb) print surf1_isocurve->PointAtStart()
(gdb) print surf1_isocurve->PointAtEnd()
              </screen>
            </para>
          </listitem>
          <listitem>
            <para>
              Investigate how the isocurves are processed.
            </para>
          </listitem>
        </orderedlist>
        <bridgehead>If the isocsx subcommand shows that isocurve
        intersections are incorrect...</bridgehead>
        <orderedlist>
          <listitem>
            <para>
              Note the index <literal>&lt;n&gt;</literal> of the
              surface-surface intersection used as the argument to the
              <function>isocsx</function> subcommand.
            </para>
          </listitem>
          <listitem>
            <para>
              Set a break after the call to
              <function>find_overlap_boundary_curves</function> in
              <filename>intersect.cpp</filename> with the condition
              <userinput>dplot->SurfacePairs() ==
              &lt;n&gt;</userinput>.
            </para>
            <para>
              For a multi-part evaluation, you'll need to first skip
              to the correct invocation of
              <function>ON_Boolean</function>, either manually, or by
              conditioning a breakpoint on the value of the static
              <varname>calls</varname> variable defined at the top of
              that function.
            </para>
          </listitem>
          <listitem>
            <para>
              Inspect the <varname>overlaps</varname> array.
            </para>
          </listitem>
        </orderedlist>
        <bridgehead>If the ssx subcommand shows an incorrect
        intersection curve...</bridgehead>
        <orderedlist>
          <listitem>
            <para>
              Note the index <literal>&lt;n&gt;</literal> of the
              surface-surface intersection used as the argument to the
              <function>ssx</function> subcommand, and the index
              <literal>&lt;k&gt;</literal> assigned to the incorrect
              intersection event.
            </para>
          </listitem>
          <listitem>
            <para>
              Set a breakpoint at the
              <function>ON_Intersect</function> call in
              <function>get_face_intersection_curves</function> with
              the condition <userinput>dplot->SurfacePairs() == &lt;n
              - 1&gt;</userinput>.
            </para>
            <para>
              For a multi-part evaluation, you'll need to first skip
              to the correct invocation of
              <function>ON_Boolean</function>, either manually, or by
              conditioning a breakpoint on the value of the static
              <varname>calls</varname> variable defined at the top of
              that function.
            </para>
          </listitem>
          <listitem>
            <para>
              Step into <function>ON_Intersect</function> and wait for
              <literal>x.Count() == &lt;k - 1&gt;</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              Investigate the creation of the next intersection event.
            </para>
          </listitem>
        </orderedlist>
        <bridgehead>
          If the ssx subcommand shows the correct intersections for a
          given surface pair, but the fcurves subcommand shows those
          curves are not being correctly clipped by faces...
        </bridgehead>
        <orderedlist>
          <listitem>
            <para>
              Note the index <literal>&lt;n&gt;</literal> of the
              surface-surface intersection used as the argument to the
              <function>ssx</function> and
              <function>fcurves</function> subcommands, and the index
              <literal>&lt;k&gt;</literal> assigned by
              <function>fcurves</function> to the incorrect clipped
              curves.
            </para>
          </listitem>
          <listitem>
            <para>
              Set a breakpoint at the
              <function>get_subcurves_inside_faces</function> call
              inside <function>get_face_intersection_curves</function>
              with the condition <userinput>dplot->SurfacePairs() ==
              &lt;n + 1&gt; &amp;&amp; k == &lt;k&gt;</userinput>.
            </para>
            <para>
              For a multi-part evaluation, you'll need to first skip
              to the correct invocation of
              <function>ON_Boolean</function>, either manually, or by
              conditioning a breakpoint on the value of the static
              <varname>calls</varname> variable defined at the top of
              that function.
            </para>
          </listitem>
          <listitem>
            <para>
              Start stepping through
              <function>get_face_intersection_curves</function> to
              investigate how the event intersection curves are being
              clipped.
            </para>
          </listitem>
        </orderedlist>
        <bridgehead>If the faces subcommand shows that an input face
        was not split correctly, but the lcurves subcommand shows the
        relevant intersection was accurate...</bridgehead>
        <orderedlist>
          <listitem>
            <para>
              Note the index <literal>&lt;n&gt;</literal> assigned by
              <function>lcurves</function> to the relevant linked
              curves.
            </para>
          </listitem>
          <listitem>
            <para>
              Set a breakpoint at the
              <function>split_trimmed_face</function> call inside
              <function>get_evaluated_faces</function> with the
              condition <userinput>dplot->LinkedCurves() >= &lt;n +
              1&gt;</userinput>.
            </para>
            <para>
              For a multi-part evaluation, you'll need to first skip
              to the correct invocation of
              <function>ON_Boolean</function>, either manually, or by
              conditioning a breakpoint on the value of the static
              <varname>calls</varname> variable defined at the top of
              that function.
            </para>
          </listitem>
          <listitem>
            <para>
              Inside <function>split_trimmed_face</function>, check
              the input face loops and ssx curves:
            </para>
            <screen>
(gdb) print orig_face->m_outerloop.m_a[i]->PointAtStart()
(gdb) print orig_face->m_outerloop.m_a[i]->PointAtEnd()
(gdb) print orig_face->m_innerloop.m_a[i]->PointAtStart()              
(gdb) print orig_face->m_innerloop.m_a[i]->PointAtEnd()              
(gdb) print ssx_curves.m_a[i].m_ssi_curves.m_a[i].m_curve->PointAtStart()
(gdb) print ssx_curves.m_a[i].m_ssi_curves.m_a[i].m_curve->PointAtEnd()
            </screen>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>A Historical Example</title>
        <para>
          What follows is a step-by-step debugging of a real issue
          affecting the <literal>X</literal> combination from the
          BRL-CAD sample database <filename>axis.g</filename>.
        </para>
        <para>
          This issue was fixed in revision 65179 in the NURBS Boolean
          Evaluation development branch of the source repository
          (<link>https://sourceforge.net/p/brlcad/code/HEAD/tree/brlcad/branches/brep-debug/</link>).
        </para>
        <para>
          If you want to follow along, you can reinstate the error in
          a checkout of the development branch:
          <screen>
$ svn merge -r 65179:65178 ^/brlcad/branches/brep-debug
          </screen>
        </para>
        <orderedlist>
          <listitem>
            <para>
              Open <filename>axis.g</filename> in Archer and convert
              the original combination to <type>brep</type>.
              <screen>
Archer> opendb axis.g
Archer> brep X
X_brep is made.
              </screen>
            </para>
            <para>
              The file <filename>bool1.dplot</filename> is created in
              the current directory, as well as a few hundred
              <filename>.plot3</filename> files.
            </para>
          </listitem>
          <listitem>
            <para>The object <literal>X</literal> is the union of two
            intersecting arb8 boxes. The arb8s are perpendicularly
            intersecting plates that create a 3D shape that looks like
            a 2D letter "X" in the X-Y plane that has been extruded
            along the Z axis.
            </para>
            <para>
              The <function>ssx</function> subcommand of
              <function>dplot</function> is used to check that all
              expected surface-surface intersections were attempted
              between the brep NURBS versions of the two arb8s,
              hereafter referred to as <emphasis>brep1</emphasis> and
              <emphasis>brep2</emphasis>.
            </para>
            <para>
              <screen>
Archer> dplot bool1.dplot ssx
Press [Enter] to show surface-surface intersection 0
...
Press [Enter] to show surface-surface intersection 13
              </screen>
            </para>
            <para>
              All 14 expected intersection events are reported. Each
              of the two larger-area faces of
              <emphasis>brep1</emphasis> transversally intersects the
              two similar faces of <emphasis>brep2</emphasis>
              (<varname>ssx_index</varname> 0, 1, 4, 5). Two edges of
              each of these faces lie in the same plane (the X-Y
              plane and another plane parallel to it) as two of the
              four smaller-area faces of the other brep
              (<varname>ssx_index</varname> 2, 3, 6, 7, 8, 9, 11,
              12). These two pairs of smaller area faces also
              intersect each other in square overlap intersections
              (<varname>ssx_index</varname> 10, 13).
            </para>
          </listitem>
          <listitem>
            <para>
              The <function>ssx &lt;ssx_index&gt;</function> subcommand of
              <function>dplot</function> is used to check the
              individual intersection events.
            </para>
            <screen>
Archer> dplot bool1.dplot ssx 0
...              
Archer> dplot bool1.dplot ssx 13
            </screen>
            <para>
              The surface-surface intersection with
              <varname>ssx_index</varname> 10 appears incorrect
              (compare to the other overlap intersection,
              <varname>ssx_index</varname> 13). It's been correctly
              identified as an overlap intersection, but it doesn't
              contain the full, square area of the overlap.
            </para>
          </listitem>
          <listitem>
            <para>
              The overlap intersection should have been created by
              stitching together the four isocurve-surface
              intersections that make each edge of the square overlap.
            </para>
            <para>
              The <function>isocsx &lt;ssx_index&gt;</function> subcommand of
              the <function>dplot</function> command is used to check
              that all isocurve-surface intersections were attempted.
            </para>
            <screen>
Archer> dplot bool1.dplot ssx 10
            </screen>
            <para>
              All four expected isocurve-surface intersections are
              reported.
            </para>
          </listitem>
          <listitem>
            <para>
              The <function>isocsx &lt;ssx_index&gt;
              &lt;isocsx_index&gt;</function> subcommand of the
              <function>dplot</function> command is used to check each
              isocurve-surface intersection curve.
            </para>
            <screen>
Archer> dplot bool1.dplot isocsx 10 0
Archer> dplot bool1.dplot isocsx 10 1
Archer> dplot bool1.dplot isocsx 10 2
Archer> dplot bool1.dplot isocsx 10 3
            </screen>
            <para>
              Each of the four overlap curves appears correct.
            </para>
            <para>
              At this point, the problem doesn't seem to be with the
              intersection curves, but with how they were processed.
            </para>
          </listitem>
          <listitem>
            <para>
              The <function>fcurves</function> subcommand of the
              <function>dplot</function> command is used to check the
              overlap intersection curve that resulted from stitching
              together the four (correct) isocurve-surface
              intersection curves. The command shows the 3D projection
              of the 2D curve recorded in the
              <emphasis>brep1</emphasis> and
              <emphasis>brep2</emphasis> domains, after they were
              clipped to fit inside the containing face (though
              clipping was unnecessary in this case, as the outer
              loops of the faces coincide with the boundaries of the
              surfaces).
            </para>
            <screen>
Archer> dplot bool1.dplot fcurves 10
            </screen>
            <para>
              The clipped curves are shown to be incorrect. This
              isolates the problem to a point between the time the
              isocurve-surface intersections were found and the time
              the clipped curves were created.
            </para>
          </listitem>
          <listitem>
            <para>
              The isocsx plots are written by the
              <function>DebugPlot::IsoCSX</function> method inside the
              <function>find_overlap_boundary_curves</function>
              routine in
              <filename>src/libbrep/intersect.cpp</filename>.
              <function>find_overlap_boundary_curves</function> is
              called from <function>ON_Intersect</function>
              surface-surface intersection function, also defined in
              <filename>src/libbrep/intersect.cpp</filename>. The next
              call after
              <function>find_overlap_boundary_curves</function>
              returns is
              <function>split_overlaps_at_intersections</function>.
            </para>
            <para>
              To quickly check if the splitting function changes the
              overlap curves, we insert code to write out the overlap
              curves as <filename>.plot3</filename> files just after
              the <function>split_overlaps_at_intersections</function>
              call.
            </para>
            <para>
              Since the <varname>ssx_index</varname> values reported
              by <function>dplot</function> are numbered from 0, the
              intersection we want to investigate, whose
              <varname>ssx_index</varname> is 10, will be the 11th
              intersection recorded during the evaluation.
            </para>
            <para>
              <varname>dplot->SurfacePairs()</varname> reports the
              number of surface-surface intersections that have been
              recorded, so we write our curves on the condition that
              <literal>dplot->SurfacePairs() == 10</literal>. Then
              we'll only get the curves from the 11th surface-surface
              intersection.
            </para>
            <programlisting>
<![CDATA[
 // intersect.cpp, inside
 // ON_Intersect(const ON_Surface *surfA, const ON_Surface *surfB, ...)

 split_overlaps_at_intersections(overlaps, surfA, surfB, treeA, treeB,
                                 isect_tol, isect_tolA, isect_tolB);
    
+if (dplot->SurfacePairs() == 10) {
+    for (int i = 0; i < overlaps.Count(); ++i) {
+        if (!overlaps[i]) {
+            continue;
+        }
+        unsigned char overlap_color[] = {0, 255, 0};
+        std::ostringstream plotname;
+
+        plotname << "split_overlap" << i << ".plot3";
+        dplot->Plot3DCurve(overlaps[i]->m_curve3d, plotname.str().c_str(),
+                overlap_color);
+    }
+}
+
 // add csx_events
 for (int i = 0; i &lt; csx_events.Count(); ++i) {
     x.Append(csx_events[i]);
]]>
            </programlisting>
          </listitem>
          <listitem>
            <para>
              After rebuilding the code, the evaluation is run again
              in Archer to produce the custom plot files
              <filename>split_overlap4.plot3</filename>,
              <filename>split_overlap5.plot3</filename>,
              <filename>split_overlap6.plot3</filename>, and
              <filename>split_overlap7.plot3</filename>.
            </para>
            <para>
              The <function>overlay</function> command is used to draw
              the contents of the <filename>.plot3</filename> files.
            </para>
            <screen>
Archer> brep X
Archer> overlay split_overlap4.plot3 1 ol4
Archer> overlay split_overlap5.plot3 1 ol5
Archer> overlay split_overlap6.plot3 1 ol6
Archer> overlay split_overlap7.plot3 1 ol7
            </screen>
            <para>
              When the four curves are drawn, we see they are still
              correct after splitting, and enclose the square overlap
              region.
            </para>
          </listitem>
          <listitem>
            <para>
              The next step in processing the overlap curves is
              linking contiguous curve segments together. We'll once
              again modify the source code, this time to write out the
              intermediate linked overlap curves.
            </para>
            <para>
              Curve endpoints are tested to see if they coincide, and
              contiguous curves are linked with the
              <function>link_curves</function> routine, which returns
              a linked curve that replaces the original curves in the
              <varname>overlaps</varname> array. We'll write out each
              such curve returned by <function>link_curves</function>.
            </para>
            <programlisting>
<![CDATA[
 // intersect.cpp, inside
 // ON_Intersect(const ON_Surface *surfA, const ON_Surface *surfB, ...)
 // after the calls to link_curves
 
         overlaps[i]->m_curveB = link_curves(overlaps[i]->m_curveB, overlaps[j]->m_curveB);
     }
 }
+if (dplot->SurfacePairs() == 10) {
+    unsigned char linked_curve_color[] = {0, 0, 255};
+    std::ostringstream plotname;
+
+    plotname << "linked_" << i << "_" << j << ".plot3";
+    dplot->Plot3DCurve(overlaps[i]->m_curve3d, plotname.str().c_str(),
+                       linked_curve_color);
+}
 if (!is_valid_overlap(overlaps[j])) {
     delete overlaps[j];
     overlaps[j] = NULL;

]]>
            </programlisting>
          </listitem>
          <listitem>
            <para>
              The code is re-compiled, <literal>X_brep</literal> is
              removed from the database, and the dplot-related files
              are once again cleared from the working directory before
              re-running the evaluation.
            </para>
            <para>
              We draw our four new linked curve
              <filename>.plot3</filename> files.
            </para>
            <screen>
Archer > overlay linked_4_5.plot3 1
Archer > overlay linked_4_6.plot3 1
Archer > overlay linked_4_7.plot3 1
Archer > overlay linked_5_4.plot3 1
            </screen>
            <para>
              The intermediate curve represented by
              <literal>linked_4_7.plot3</literal> is clearly
              incorrect, as it cuts diagonally through the square
              overlap region.
            </para>
          </listitem>
          <listitem>
            <para>
              We'll perform the evaluation again via a
              debugger. <literal>X_brep</literal> is removed from the
              database, and the <filename>*.dplot</filename> and
              <filename>*.plot3</filename> files are removed from the
              working directory.
            </para>
            <para>
              A breakpoint is set just before the calls to
              <function>link_curves</function> in the
              <function>ON_Intersect</function> surface-surface
              intersection function (line 3885 in
              <filename>intersect.cpp</filename> at the time of
              writing), with the condition that
              <literal>dplot->SurfacePairs() == 10</literal>, and
              that the overlap indices <varname>i</varname> and
              <varname>j</varname> match the linked curve of interest.
            </para>
            <screen>
<![CDATA[
$ gdb mged
(gdb) set args axis.g brep X
(gdb) start
(gdb) break intersect.cpp:3885 if dplot->SurfacePairs() == 10 && i == 4 && j == 7
(gdb) continue
]]>
            </screen>
            <para>
              Stepping from the breakpoint (e.g. with gdb's
              <function>next</function> command) we see that the macro
              test <literal>OVERLAPS_LINKED(Start, End)</literal>
              evaluates as true, indicating that the start of the
              <varname>overlaps[i]</varname> curves coincide with the
              end of the <varname>overlaps[j]</varname> curves.
            </para>
            <para>
              Looking at the implementation of
              <function>link_curves</function> in
              <filename>intersect.cpp</filename>, we can see that the
              second curve argument is joined to the first curve
              argument using the OpenNURBS
              <function>ON_NurbsCurve::Append</function> member
              function. So, the start point of the second curve
              argument is joined to the end point of the first curve
              argument.
            </para>
            <programlisting>
<![CDATA[
HIDDEN ON_Curve *   
link_curves(ON_Curve *&c1, ON_Curve *&c2)
{
    extend_curve_end_to_pt(c1, c2->PointAtEnd(), ON_ZERO_TOLERANCE);

    ON_NurbsCurve *nc1 = c1->NurbsCurve();
    ON_NurbsCurve *nc2 = c2->NurbsCurve();
    if (nc1 && nc2) {
        nc1->Append(*nc2);
        delete c1;
        delete c2;
        c1 = NULL;
        c2 = NULL;
        delete nc2;
        return nc1;
    } else if (nc1) {
        delete nc1;
    } else if (nc2) {
        delete nc2;
    }
    return NULL;
}   
]]>
            </programlisting>
            <para>
              <function>link_curves</function> is here being called
              with <varname>overlaps[j]->m_curve*</varname> as its
              first argument and
              <varname>overlaps[i]->m_curve*</varname> as its second
              argument. This matches our intention to link the end of
              <varname>overlaps[j]</varname> to the start of
              <varname>overlaps[i]</varname>, which have been
              determined to be coincident.
            </para>
            <para>
              However, going back to the
              <function>link_curves</function> implementation, we also
              see a call to
              <function>extend_curve_end_to_point</function> which may
              modify the first curve argument.
            </para>
            <para>
               This intent of this call is to ensure the end point of
               the first curve meets the start point of the second
               curve as tightly as possible (tighter than the
               <varname>isect_tol</varname> value that was used to
               determine the points were coincident) before the curves
               are joined together.
            </para>
            <para>
              However, we see the point argument passed to
              <function>extend_curve_end_to_point</function> is
              <varname>c2->PointAtEnd()</varname>, when it should be
              <varname>c2->PointAtStart()</varname>.
            </para>
          </listitem>
          <listitem>
            <para>
              This error is corrected and the code is rebuilt. The
              evaluation is re-run, and we use the
              <function>dplot</function> command to verify that the
              overlap intersection associated with
              <varname>ssx_index</varname> 10 is now correct.
            </para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
</article>
