<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='crtslave3'>

<!-- '\" Copyright (c) 1995\-1996 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>7.6</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_CreateSlave</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>7.6</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_IsSafe</refname>
<refname>Tcl_MakeSafe</refname>
<refname>Tcl_CreateSlave</refname>
<refname>Tcl_GetSlave</refname>
<refname>Tcl_GetMaster</refname>
<refname>Tcl_GetInterpPath</refname>
<refname>Tcl_CreateAlias</refname>
<refname>Tcl_CreateAliasObj</refname>
<refname>Tcl_GetAlias</refname>
<refname>Tcl_GetAliasObj</refname>
<refname>Tcl_ExposeCommand</refname>
<refname>Tcl_HideCommand</refname>
<refpurpose>manage multiple Tcl interpreters, aliases and hidden commands</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>Tcl_IsSafe</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_MakeSafe</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Interp</function> *Tcl_CreateSlave</funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>slaveName</parameter></paramdef>
<paramdef><parameter>isSafe</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Interp</function> *Tcl_GetSlave</funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>slaveName</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Interp</function> *Tcl_GetMaster</funcdef>
<paramdef><parameter>interp</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetInterpPath</function></funcdef>
<paramdef><parameter>askingInterp</parameter></paramdef>
<paramdef><parameter>slaveInterp</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_CreateAlias</function></funcdef>
<paramdef><parameter>slaveInterp</parameter></paramdef>
<paramdef><parameter>slaveCmd</parameter></paramdef>
<paramdef><parameter>targetInterp</parameter></paramdef>
<paramdef><parameter>targetCmd</parameter></paramdef>
<paramdef><parameter>
 argc</parameter></paramdef>
<paramdef><parameter>argv</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_CreateAliasObj</function></funcdef>
<paramdef><parameter>slaveInterp</parameter></paramdef>
<paramdef><parameter>slaveCmd</parameter></paramdef>
<paramdef><parameter>targetInterp</parameter></paramdef>
<paramdef><parameter>targetCmd</parameter></paramdef>
<paramdef><parameter>
 objc</parameter></paramdef>
<paramdef><parameter>objv</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetAlias</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>slaveCmd</parameter></paramdef>
<paramdef><parameter>targetInterpPtr</parameter></paramdef>
<paramdef><parameter>targetCmdPtr</parameter></paramdef>
<paramdef><parameter>
 argcPtr</parameter></paramdef>
<paramdef><parameter>argvPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetAliasObj</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>slaveCmd</parameter></paramdef>
<paramdef><parameter>targetInterpPtr</parameter></paramdef>
<paramdef><parameter>targetCmdPtr</parameter></paramdef>
<paramdef><parameter>
 objcPtr</parameter></paramdef>
<paramdef><parameter>objvPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ExposeCommand</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>hiddenCmdName</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_HideCommand</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
<paramdef><parameter>hiddenCmdName</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS const char *const **targetInterpPtr out -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Interp"</entry><entry>"*interp"</entry><entry>"in"</entry>
<entry>
<para>Interpreter in which to execute the specified command.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*slaveName</entry><entry>in</entry>
<entry>
<para>Name of slave interpreter to create or manipulate.</para>
</entry>
</row>
<row><entry>int</entry><entry>isSafe</entry><entry>in</entry>
<entry>
<para>If non-zero, a
<quote>safe</quote>
slave that is suitable for running untrusted code
is created, otherwise a trusted slave is created.</para>
</entry>
</row>
<row><entry>Tcl_Interp</entry><entry>*slaveInterp</entry><entry>in</entry>
<entry>
<para>Interpreter to use for creating the source command for an alias (see
below).</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*slaveCmd</entry><entry>in</entry>
<entry>
<para>Name of source command for alias.</para>
</entry>
</row>
<row><entry>Tcl_Interp</entry><entry>*targetInterp</entry><entry>in</entry>
<entry>
<para>Interpreter that contains the target command for an alias.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*targetCmd</entry><entry>in</entry>
<entry>
<para>Name of target command for alias in <emphasis remap='I'>targetInterp</emphasis>.</para>
</entry>
</row>
<row><entry>int</entry><entry>argc</entry><entry>in</entry>
<entry>
<para>Count of additional arguments to pass to the alias command.</para>
</entry>
</row>
<row><entry>"const char *const"</entry><entry>*argv</entry><entry>in</entry>
<entry>
<para>Vector of strings, the additional arguments to pass to the alias command.
This storage is owned by the caller.</para>
</entry>
</row>
<row><entry>int</entry><entry>objc</entry><entry>in</entry>
<entry>
<para>Count of additional object arguments to pass to the alias object command.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>**objv</entry><entry>in</entry>
<entry>
<para>Vector of Tcl_Obj structures, the additional object arguments to pass to
the alias object command.
This storage is owned by the caller.</para>
</entry>
</row>
<row><entry>Tcl_Interp</entry><entry>**targetInterpPtr</entry><entry>in</entry>
<entry>
<para>Pointer to location to store the address of the interpreter where a target
command is defined for an alias.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>**targetCmdPtr</entry><entry>out</entry>
<entry>
<para>Pointer to location to store the address of the name of the target command
for an alias.</para>
</entry>
</row>
<row><entry>int</entry><entry>*argcPtr</entry><entry>out</entry>
<entry>
<para>Pointer to location to store count of additional arguments to be passed to
the alias. The location is in storage owned by the caller.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>***argvPtr</entry><entry>out</entry>
<entry>
<para>Pointer to location to store a vector of strings, the additional arguments
to pass to an alias. The location is in storage owned by the caller, the
vector of strings is owned by the called function.</para>
</entry>
</row>
<row><entry>int</entry><entry>*objcPtr</entry><entry>out</entry>
<entry>
<para>Pointer to location to store count of additional object arguments to be
passed to the alias. The location is in storage owned by the caller.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>***objvPtr</entry><entry>out</entry>
<entry>
<para>Pointer to location to store a vector of Tcl_Obj structures, the additional
arguments to pass to an object alias command. The location is in storage
owned by the caller, the vector of Tcl_Obj structures is owned by the
called function.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*cmdName</entry><entry>in</entry>
<entry>
<para>Name of an exposed command to hide or create.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*hiddenCmdName</entry><entry>in</entry>
<entry>
<para>Name under which a hidden command is stored and with which it can be
exposed or invoked.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para>These procedures are intended for access to the multiple interpreter
facility from inside C programs. They enable managing multiple interpreters
in a hierarchical relationship, and the management of aliases, commands
that when invoked in one interpreter execute a command in another
interpreter. The return value for those procedures that return an <emphasis remap='B'>int</emphasis>
is either <emphasis remap='B'>TCL_OK</emphasis> or <emphasis remap='B'>TCL_ERROR</emphasis>. If <emphasis remap='B'>TCL_ERROR</emphasis> is returned
then the <emphasis remap='B'>result</emphasis> field of the interpreter contains an error message.</para>

<para><emphasis remap='B'>Tcl_CreateSlave</emphasis> creates a new interpreter as a slave of <emphasis remap='I'>interp</emphasis>.
It also creates a slave command named <emphasis remap='I'>slaveName</emphasis> in <emphasis remap='I'>interp</emphasis> which 
allows <emphasis remap='I'>interp</emphasis> to manipulate the new slave. 
If <emphasis remap='I'>isSafe</emphasis> is zero, the command creates a trusted slave in which Tcl
code has access to all the Tcl commands.
If it is <literal>1</literal>, the command creates a
<quote>safe</quote>
slave in which Tcl code has access only to set of Tcl commands defined as
<quote>Safe Tcl</quote>;
see the manual entry for the Tcl <emphasis remap='B'>interp</emphasis> command for details.
If the creation of the new slave interpreter failed, <emphasis remap='B'>NULL</emphasis> is returned.</para>

<para><function>Tcl_IsSafe</function> returns <literal>1</literal> if <emphasis remap='I'>interp</emphasis> is
<quote>safe</quote>
(was created with the <emphasis remap='B'>TCL_SAFE_INTERPRETER</emphasis> flag specified),
<literal>0</literal> otherwise.</para>

<para><function>Tcl_MakeSafe</function> marks <emphasis remap='I'>interp</emphasis> as
<quote>safe</quote>,
so that future
calls to <function>Tcl_IsSafe</function> will return 1.  It also removes all known
potentially-unsafe core functionality (both commands and variables)
from <emphasis remap='I'>interp</emphasis>.  However, it cannot know what parts of an extension
or application are safe and does not make any attempt to remove those
parts, so safety is not guaranteed after calling <function>Tcl_MakeSafe</function>.
Callers will want to take care with their use of <function>Tcl_MakeSafe</function>
to avoid false claims of safety.  For many situations, <emphasis remap='B'>Tcl_CreateSlave</emphasis>
may be a better choice, since it creates interpreters in a known-safe state.</para>

<para><emphasis remap='B'>Tcl_GetSlave</emphasis> returns a pointer to a slave interpreter of
<emphasis remap='I'>interp</emphasis>. The slave interpreter is identified by <emphasis remap='I'>slaveName</emphasis>.
If no such slave interpreter exists, <emphasis remap='B'>NULL</emphasis> is returned.</para>

<para><emphasis remap='B'>Tcl_GetMaster</emphasis> returns a pointer to the master interpreter of
<emphasis remap='I'>interp</emphasis>. If <emphasis remap='I'>interp</emphasis> has no master (it is a
top-level interpreter) then <emphasis remap='B'>NULL</emphasis> is returned.</para>

<para><function>Tcl_GetInterpPath</function> sets the <emphasis remap='I'>result</emphasis> field in <emphasis remap='I'>askingInterp</emphasis>
to the relative path between <emphasis remap='I'>askingInterp</emphasis> and <emphasis remap='I'>slaveInterp</emphasis>;
<emphasis remap='I'>slaveInterp</emphasis> must be a slave of <emphasis remap='I'>askingInterp</emphasis>. If the computation
of the relative path succeeds, <emphasis remap='B'>TCL_OK</emphasis> is returned, else
<emphasis remap='B'>TCL_ERROR</emphasis> is returned and the <emphasis remap='I'>result</emphasis> field in
<emphasis remap='I'>askingInterp</emphasis> contains the error message.</para>

<para><function>Tcl_CreateAlias</function> creates an object command named <emphasis remap='I'>slaveCmd</emphasis> in
<emphasis remap='I'>slaveInterp</emphasis> that when invoked, will cause the file <command>targetCmd</command>
to be invoked in <emphasis remap='I'>targetInterp</emphasis>. The arguments specified by the strings
contained in <emphasis remap='I'>argv</emphasis> are always prepended to any arguments supplied in the
invocation of <emphasis remap='I'>slaveCmd</emphasis> and passed to <emphasis remap='I'>targetCmd</emphasis>.
This operation returns <emphasis remap='B'>TCL_OK</emphasis> if it succeeds, or <emphasis remap='B'>TCL_ERROR</emphasis> if
it fails; in that case, an error message is left in the object result
of <emphasis remap='I'>slaveInterp</emphasis>.
Note that there are no restrictions on the ancestry relationship (as
created by <emphasis remap='B'>Tcl_CreateSlave</emphasis>) between <emphasis remap='I'>slaveInterp</emphasis> and
<emphasis remap='I'>targetInterp</emphasis>. Any two interpreters can be used, without any
restrictions on how they are related.</para>

<para><function>Tcl_CreateAliasObj</function> is similar to <function>Tcl_CreateAlias</function> except 
that it takes a vector of objects to pass as additional arguments instead
of a vector of strings.</para>

<para><function>Tcl_GetAlias</function> returns information about an alias <emphasis remap='I'>aliasName</emphasis>
in <emphasis remap='I'>interp</emphasis>. Any of the result fields can be <emphasis remap='B'>NULL</emphasis>, in
which case the corresponding datum is not returned. If a result field is
non-<emphasis remap='B'>NULL</emphasis>, the address indicated is set to the corresponding datum.
For example, if <emphasis remap='I'>targetNamePtr</emphasis> is non-<emphasis remap='B'>NULL</emphasis> it is set to a
pointer to the string containing the name of the target command.</para>

<para><function>Tcl_GetAliasObj</function> is similar to <function>Tcl_GetAlias</function> except that it
returns a pointer to a vector of Tcl_Obj structures instead of a vector of
strings.</para>

<para><function>Tcl_ExposeCommand</function> moves the command named <emphasis remap='I'>hiddenCmdName</emphasis> from
the set of hidden commands to the set of exposed commands, putting
it under the name
<emphasis remap='I'>cmdName</emphasis>. 
<emphasis remap='I'>HiddenCmdName</emphasis> must be the name of an existing hidden
command, or the operation will return <emphasis remap='B'>TCL_ERROR</emphasis> and leave an error
message in the <emphasis remap='I'>result</emphasis> field in <emphasis remap='I'>interp</emphasis>.
If an exposed command named <emphasis remap='I'>cmdName</emphasis> already exists,
the operation returns <emphasis remap='B'>TCL_ERROR</emphasis> and leaves an error message in the
object result of <emphasis remap='I'>interp</emphasis>.
If the operation succeeds, it returns <emphasis remap='B'>TCL_OK</emphasis>.
After executing this command, attempts to use <emphasis remap='I'>cmdName</emphasis> in a call to
<emphasis remap='B'>Tcl_Eval</emphasis> or with the Tcl <emphasis remap='B'>eval</emphasis> command will again succeed.</para>

<para><function>Tcl_HideCommand</function> moves the command named <emphasis remap='I'>cmdName</emphasis> from the set of
exposed commands to the set of hidden commands, under the name
<emphasis remap='I'>hiddenCmdName</emphasis>.
<emphasis remap='I'>CmdName</emphasis> must be the name of an existing exposed
command, or the operation will return <emphasis remap='B'>TCL_ERROR</emphasis> and leave an error
message in the object result of <emphasis remap='I'>interp</emphasis>.
Currently both <emphasis remap='I'>cmdName</emphasis> and <emphasis remap='I'>hiddenCmdName</emphasis> must not contain
namespace qualifiers, or the operation will return <emphasis remap='B'>TCL_ERROR</emphasis> and
leave an error message in the object result of <emphasis remap='I'>interp</emphasis>.
The <emphasis remap='I'>CmdName</emphasis> will be looked up in the global namespace, and not
relative to the current namespace, even if the current namespace is not the
global one.
If a hidden command whose name is <emphasis remap='I'>hiddenCmdName</emphasis> already
exists, the operation also returns <emphasis remap='B'>TCL_ERROR</emphasis> and the <emphasis remap='I'>result</emphasis>
field in <emphasis remap='I'>interp</emphasis> contains an error message.
If the operation succeeds, it returns <emphasis remap='B'>TCL_OK</emphasis>.
After executing this command, attempts to use <emphasis remap='I'>cmdName</emphasis> in a call to
<emphasis remap='B'>Tcl_Eval</emphasis> or with the Tcl <emphasis remap='B'>eval</emphasis> command will fail.</para>

<para>For a description of the Tcl interface to multiple interpreters, see
<emphasis remap='I'>interp(n)</emphasis>.</para>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>interp</para>

</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>alias, command, exposed commands, hidden commands, interpreter, invoke,
master, slave</para>
</refsect1>
</refentry>

