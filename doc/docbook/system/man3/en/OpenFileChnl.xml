<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='openfilechnl3'>

<!-- '\" Copyright (c) 1996\-1997 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES. -->

<!-- '\" RCS: @(#) $Id$ -->
<refentryinfo><date>8.3</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_OpenFileChannel</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>8.3</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_OpenFileChannel</refname>
<refname>Tcl_OpenCommandChannel</refname>
<refname>Tcl_MakeFileChannel</refname>
<refname>Tcl_GetChannel</refname>
<refname>Tcl_GetChannelNames</refname>
<refname>Tcl_GetChannelNamesEx</refname>
<refname>Tcl_RegisterChannel</refname>
<refname>Tcl_UnregisterChannel</refname>
<refname>Tcl_DetachChannel</refname>
<refname>Tcl_IsStandardChannel</refname>
<refname>Tcl_Close</refname>
<refname>Tcl_ReadChars</refname>
<refname>Tcl_Read</refname>
<refname>Tcl_GetsObj</refname>
<refname>Tcl_Gets</refname>
<refname>Tcl_WriteObj</refname>
<refname>Tcl_WriteChars</refname>
<refname>Tcl_Write</refname>
<refname>Tcl_Flush</refname>
<refname>Tcl_Seek</refname>
<refname>Tcl_Tell</refname>
<refname>Tcl_TruncateChannel</refname>
<refname>Tcl_GetChannelOption</refname>
<refname>Tcl_SetChannelOption</refname>
<refname>Tcl_Eof</refname>
<refname>Tcl_InputBlocked</refname>
<refname>Tcl_InputBuffered</refname>
<refname>Tcl_OutputBuffered</refname>
<refname>Tcl_Ungets</refname>
<refname>Tcl_ReadRaw</refname>
<refname>Tcl_WriteRaw</refname>
<refpurpose>buffered I/O facilities using channels</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>Tcl_Channel <function>Tcl_OpenFileChannel</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>fileName</parameter></paramdef>
<paramdef><parameter>mode</parameter></paramdef>
<paramdef><parameter>permissions</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_Channel <function>Tcl_OpenCommandChannel</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>argc</parameter></paramdef>
<paramdef><parameter>argv</parameter></paramdef>
<paramdef><parameter>flags</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_Channel <function>Tcl_MakeFileChannel</function></funcdef>
<paramdef><parameter>handle</parameter></paramdef>
<paramdef><parameter>readOrWrite</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_Channel <function>Tcl_GetChannel</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>channelName</parameter></paramdef>
<paramdef><parameter>modePtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetChannelNames</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetChannelNamesEx</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pattern</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>void <function>Tcl_RegisterChannel</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_UnregisterChannel</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_DetachChannel</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_IsStandardChannel</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_Close</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ReadChars</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>readObjPtr</parameter></paramdef>
<paramdef><parameter>charsToRead</parameter></paramdef>
<paramdef><parameter>appendFlag</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_Read</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>readBuf</parameter></paramdef>
<paramdef><parameter>bytesToRead</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetsObj</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>lineObjPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_Gets</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>lineRead</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_Ungets</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>input</parameter></paramdef>
<paramdef><parameter>inputLen</parameter></paramdef>
<paramdef><parameter>addAtEnd</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_WriteObj</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>writeObjPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_WriteChars</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>charBuf</parameter></paramdef>
<paramdef><parameter>bytesToWrite</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_Write</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>byteBuf</parameter></paramdef>
<paramdef><parameter>bytesToWrite</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ReadRaw</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>readBuf</parameter></paramdef>
<paramdef><parameter>bytesToRead</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_WriteRaw</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>byteBuf</parameter></paramdef>
<paramdef><parameter>bytesToWrite</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_Eof</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_Flush</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_InputBlocked</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_InputBuffered</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_OutputBuffered</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_WideInt <function>Tcl_Seek</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>offset</parameter></paramdef>
<paramdef><parameter>seekMode</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_WideInt <function>Tcl_Tell</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_TruncateChannel</function></funcdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>length</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetChannelOption</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>optionName</parameter></paramdef>
<paramdef><parameter>optionValue</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_SetChannelOption</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>channel</parameter></paramdef>
<paramdef><parameter>optionName</parameter></paramdef>
<paramdef><parameter>newValue</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tcl_DString *channelName in/out -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Interp"</entry><entry>"*interp"</entry><entry>"in"</entry>
<entry>
<para>Used for error reporting and to look up a channel registered in it.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*fileName</entry><entry>in</entry>
<entry>
<para>The name of a local or network file.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*mode</entry><entry>in</entry>
<entry>
<para>Specifies how the file is to be accessed.  May have any of the values
allowed for the <emphasis remap='I'>mode</emphasis> argument to the Tcl <emphasis remap='B'>open</emphasis> command.</para>  
</entry>
</row>
<row><entry>int</entry><entry>permissions</entry><entry>in</entry>
<entry>
<para>POSIX-style permission flags such as 0644.  If a new file is created, these
permissions will be set on the created file.</para>
</entry>
</row>
<row><entry>int</entry><entry>argc</entry><entry>in</entry>
<entry>
<para>The number of elements in <emphasis remap='I'>argv</emphasis>.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>**argv</entry><entry>in</entry>
<entry>
<para>Arguments for constructing a command pipeline.  These values have the same
meaning as the non-switch arguments to the Tcl <emphasis remap='B'>exec</emphasis> command.</para>
</entry>
</row>
<row><entry>int</entry><entry>flags</entry><entry>in</entry>
<entry>
<para>Specifies the disposition of the stdio handles in pipeline: OR-ed
combination of <emphasis remap='B'>TCL_STDIN</emphasis>, <emphasis remap='B'>TCL_STDOUT</emphasis>, <emphasis remap='B'>TCL_STDERR</emphasis>, and
<emphasis remap='B'>TCL_ENFORCE_MODE</emphasis>. If <emphasis remap='B'>TCL_STDIN</emphasis> is set, stdin for the first child
in the pipe is the pipe channel, otherwise it is the same as the standard
input of the invoking process; likewise for <emphasis remap='B'>TCL_STDOUT</emphasis> and
<emphasis remap='B'>TCL_STDERR</emphasis>. If <emphasis remap='B'>TCL_ENFORCE_MODE</emphasis> is not set, then the pipe can
redirect stdio handles to override the stdio handles for which
<emphasis remap='B'>TCL_STDIN</emphasis>, <emphasis remap='B'>TCL_STDOUT</emphasis> and <emphasis remap='B'>TCL_STDERR</emphasis> have been set.  If it
is set, then such redirections cause an error.</para>
</entry>
</row>
<row><entry>ClientData</entry><entry>handle</entry><entry>in</entry>
<entry>
<para>Operating system specific handle for I/O to a file. For Unix this is a
file descriptor, for Windows it is a HANDLE.</para>
</entry>
</row>
<row><entry>int</entry><entry>readOrWrite</entry><entry>in</entry>
<entry>
<para>OR-ed combination of <emphasis remap='B'>TCL_READABLE</emphasis> and <emphasis remap='B'>TCL_WRITABLE</emphasis> to indicate
what operations are valid on <emphasis remap='I'>handle</emphasis>.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*channelName</entry><entry>in</entry>
<entry>
<para>The name of the channel.</para> 
</entry>
</row>
<row><entry>int</entry><entry>*modePtr</entry><entry>out</entry>
<entry>
<para>Points at an integer variable that will receive an OR-ed combination of
<emphasis remap='B'>TCL_READABLE</emphasis> and <emphasis remap='B'>TCL_WRITABLE</emphasis> denoting whether the channel is
open for reading and writing.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*pattern</entry><entry>in</entry>
<entry>
<para>The pattern to match on, passed to Tcl_StringMatch, or NULL.</para>
</entry>
</row>
<row><entry>Tcl_Channel</entry><entry>channel</entry><entry>in</entry>
<entry>
<para>A Tcl channel for input or output.  Must have been the return value
from a procedure such as <function>Tcl_OpenFileChannel</function>.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*readObjPtr</entry><entry>in/out</entry>
<entry>
<para>A pointer to a Tcl Object in which to store the characters read from the
channel.</para>
</entry>
</row>
<row><entry>int</entry><entry>charsToRead</entry><entry>in</entry>
<entry>
<para>The number of characters to read from the channel.  If the channel's encoding 
is <emphasis remap='B'>binary</emphasis>, this is equivalent to the number of bytes to read from the 
channel.</para>
</entry>
</row>
<row><entry>int</entry><entry>appendFlag</entry><entry>in</entry>
<entry>
<para>If non-zero, data read from the channel will be appended to the object.
Otherwise, the data will replace the existing contents of the object.</para>
</entry>
</row>
<row><entry>char</entry><entry>*readBuf</entry><entry>out</entry>
<entry>
<para>A buffer in which to store the bytes read from the channel.</para>
</entry>
</row>
<row><entry>int</entry><entry>bytesToRead</entry><entry>in</entry>
<entry>
<para>The number of bytes to read from the channel.  The buffer <emphasis remap='I'>readBuf</emphasis> must
be large enough to hold this many bytes.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*lineObjPtr</entry><entry>in/out</entry>
<entry>
<para>A pointer to a Tcl object in which to store the line read from the
channel.  The line read will be appended to the current value of the
object.</para> 
</entry>
</row>
<row><entry>Tcl_DString</entry><entry>*lineRead</entry><entry>in/out</entry>
<entry>
<para>A pointer to a Tcl dynamic string in which to store the line read from the
channel.  Must have been initialized by the caller.  The line read will be
appended to any data already in the dynamic string.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*input</entry><entry>in</entry>
<entry>
<para>The input to add to a channel buffer.</para>
</entry>
</row>
<row><entry>int</entry><entry>inputLen</entry><entry>in</entry>
<entry>
<para>Length of the input</para>
</entry>
</row>
<row><entry>int</entry><entry>addAtEnd</entry><entry>in</entry>
<entry>
<para>Flag indicating whether the input should be added to the end or
beginning of the channel buffer.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*writeObjPtr</entry><entry>in</entry>
<entry>
<para>A pointer to a Tcl Object whose contents will be output to the channel.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*charBuf</entry><entry>in</entry>
<entry>
<para>A buffer containing the characters to output to the channel.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*byteBuf</entry><entry>in</entry>
<entry>
<para>A buffer containing the bytes to output to the channel.</para>
</entry>
</row>
<row><entry>int</entry><entry>bytesToWrite</entry><entry>in</entry>
<entry>
<para>The number of bytes to consume from <emphasis remap='I'>charBuf</emphasis> or <emphasis remap='I'>byteBuf</emphasis> and
output to the channel.</para>
</entry>
</row>
<row><entry>Tcl_WideInt</entry><entry>offset</entry><entry>in</entry>
<entry>
<para>How far to move the access point in the channel at which the next input or
output operation will be applied, measured in bytes from the position
given by <emphasis remap='I'>seekMode</emphasis>.  May be either positive or negative.</para>
</entry>
</row>
<row><entry>int</entry><entry>seekMode</entry><entry>in</entry>
<entry>
<para>Relative to which point to seek; used with <emphasis remap='I'>offset</emphasis> to calculate the new
access point for the channel. Legal values are <emphasis remap='B'>SEEK_SET</emphasis>,
<emphasis remap='B'>SEEK_CUR</emphasis>, and <emphasis remap='B'>SEEK_END</emphasis>.</para>
</entry>
</row>
<row><entry>Tcl_WideInt</entry><entry>length</entry><entry>in</entry>
<entry>
<para>The (non-negative) length to truncate the channel the channel to.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*optionName</entry><entry>in</entry>
<entry>
<para>The name of an option applicable to this channel, such as <option>-blocking</option>.
May have any of the values accepted by the <emphasis remap='B'>fconfigure</emphasis> command.</para>
</entry>
</row>
<row><entry>Tcl_DString</entry><entry>*optionValue</entry><entry>in</entry>
<entry>
<para>Where to store the value of an option or a list of all options and their
values. Must have been initialized by the caller.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*newValue</entry><entry>in</entry>
<entry>
<para>New value for the option given by <emphasis remap='I'>optionName</emphasis>.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para>The Tcl channel mechanism provides a device-independent and
platform-independent mechanism for performing buffered input
and output operations on a variety of file, socket, and device
types.
The channel mechanism is extensible to new channel types, by
providing a low-level channel driver for the new type; the channel driver
interface is described in the manual entry for <emphasis remap='B'>Tcl_CreateChannel</emphasis>. The
channel mechanism provides a buffering scheme modeled after
Unix's standard I/O, and it also allows for nonblocking I/O on
channels.</para>

<para>The procedures described in this manual entry comprise the C APIs of the
generic layer of the channel architecture. For a description of the channel
driver architecture and how to implement channel drivers for new types of
channels, see the manual entry for <emphasis remap='B'>Tcl_CreateChannel</emphasis>.</para>

</refsect1>

<refsect1 xml:id='tcl_openfilechannel'><title>TCL_OPENFILECHANNEL</title>
<para><function>Tcl_OpenFileChannel</function> opens a file specified by <emphasis remap='I'>fileName</emphasis> and
returns a channel handle that can be used to perform input and output on
the file. This API is modeled after the <emphasis remap='B'>fopen</emphasis> procedure of
the Unix standard I/O library.
The syntax and meaning of all arguments is similar to those
given in the Tcl <emphasis remap='B'>open</emphasis> command when opening a file.
If an error occurs while opening the channel, <function>Tcl_OpenFileChannel</function>
returns NULL and records a POSIX error code that can be
retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.
In addition, if <emphasis remap='I'>interp</emphasis> is non-NULL, <function>Tcl_OpenFileChannel</function>
leaves an error message in <emphasis remap='I'>interp</emphasis>'s result after any error.  
As of Tcl 8.4, the object-based API <emphasis remap='B'>Tcl_FSOpenFileChannel</emphasis> should 
be used in preference to <function>Tcl_OpenFileChannel</function> wherever possible.</para>

<para>The newly created channel is not registered in the supplied interpreter; to
register it, use <function>Tcl_RegisterChannel</function>, described below.
If one of the standard channels, <emphasis remap='B'>stdin, stdout</emphasis> or <emphasis remap='B'>stderr</emphasis> was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.</para>

</refsect1>

<refsect1 xml:id='tcl_opencommandchannel'><title>TCL_OPENCOMMANDCHANNEL</title>
<para><function>Tcl_OpenCommandChannel</function> provides a C-level interface to the
functions of the <emphasis remap='B'>exec</emphasis> and <emphasis remap='B'>open</emphasis> commands.
It creates a sequence of subprocesses specified
by the <emphasis remap='I'>argv</emphasis> and <emphasis remap='I'>argc</emphasis> arguments and returns a channel that can
be used to communicate with these subprocesses.
The <emphasis remap='I'>flags</emphasis> argument indicates what sort of communication will
exist with the command pipeline.</para>

<para>If the <emphasis remap='B'>TCL_STDIN</emphasis> flag is set then the standard input for the
first subprocess will be tied to the channel: writing to the channel
will provide input to the subprocess.  If <emphasis remap='B'>TCL_STDIN</emphasis> is not set,
then standard input for the first subprocess will be the same as this
application's standard input.  If <emphasis remap='B'>TCL_STDOUT</emphasis> is set then
standard output from the last subprocess can be read from the channel;
otherwise it goes to this application's standard output.  If
<emphasis remap='B'>TCL_STDERR</emphasis> is set, standard error output for all subprocesses is
returned to the channel and results in an error when the channel is
closed; otherwise it goes to this application's standard error.  If
<emphasis remap='B'>TCL_ENFORCE_MODE</emphasis> is not set, then <emphasis remap='I'>argc</emphasis> and <emphasis remap='I'>argv</emphasis> can
redirect the stdio handles to override <emphasis remap='B'>TCL_STDIN</emphasis>,
<emphasis remap='B'>TCL_STDOUT</emphasis>, and <emphasis remap='B'>TCL_STDERR</emphasis>; if it is set, then it is an
error for argc and argv to override stdio channels for which
<emphasis remap='B'>TCL_STDIN</emphasis>, <emphasis remap='B'>TCL_STDOUT</emphasis>, and <emphasis remap='B'>TCL_STDERR</emphasis> have been set.</para>

<para>If an error occurs while opening the channel, <function>Tcl_OpenCommandChannel</function>
returns NULL and records a POSIX error code that can be retrieved with
<emphasis remap='B'>Tcl_GetErrno</emphasis>.
In addition, <function>Tcl_OpenCommandChannel</function> leaves an error message in
the interpreter's result if <emphasis remap='I'>interp</emphasis> is not NULL.</para>

<para>The newly created channel is not registered in the supplied interpreter; to
register it, use <function>Tcl_RegisterChannel</function>, described below.
If one of the standard channels, <emphasis remap='B'>stdin, stdout</emphasis> or <emphasis remap='B'>stderr</emphasis> was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.</para>

</refsect1>

<refsect1 xml:id='tcl_makefilechannel'><title>TCL_MAKEFILECHANNEL</title>
<para><function>Tcl_MakeFileChannel</function> makes a <type>Tcl_Channel</type> from an existing,
platform-specific, file handle.
The newly created channel is not registered in the supplied interpreter; to
register it, use <function>Tcl_RegisterChannel</function>, described below.
If one of the standard channels, <emphasis remap='B'>stdin, stdout</emphasis> or <emphasis remap='B'>stderr</emphasis> was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.</para>

</refsect1>

<refsect1 xml:id='tcl_getchannel'><title>TCL_GETCHANNEL</title>
<para><function>Tcl_GetChannel</function> returns a channel given the <emphasis remap='I'>channelName</emphasis> used to
create it with <emphasis remap='B'>Tcl_CreateChannel</emphasis> and a pointer to a Tcl interpreter in
<emphasis remap='I'>interp</emphasis>. If a channel by that name is not registered in that interpreter,
the procedure returns NULL. If the <emphasis remap='I'>modePtr</emphasis> argument is not NULL, it
points at an integer variable that will receive an OR-ed combination of
<emphasis remap='B'>TCL_READABLE</emphasis> and <emphasis remap='B'>TCL_WRITABLE</emphasis> describing whether the channel is
open for reading and writing.</para>

<para><function>Tcl_GetChannelNames</function> and <function>Tcl_GetChannelNamesEx</function> write the
names of the registered channels to the interpreter's result as a
list object.  <function>Tcl_GetChannelNamesEx</function> will filter these names
according to the <emphasis remap='I'>pattern</emphasis>.  If <emphasis remap='I'>pattern</emphasis> is NULL, then it
will not do any filtering.  The return value is <emphasis remap='B'>TCL_OK</emphasis> if no
errors occurred writing to the result, otherwise it is <emphasis remap='B'>TCL_ERROR</emphasis>,
and the error message is left in the interpreter's result.</para>

</refsect1>

<refsect1 xml:id='tcl_registerchannel'><title>TCL_REGISTERCHANNEL</title>
<para><function>Tcl_RegisterChannel</function> adds a channel to the set of channels accessible
in <emphasis remap='I'>interp</emphasis>. After this call, Tcl programs executing in that
interpreter can refer to the channel in input or output operations using
the name given in the call to <emphasis remap='B'>Tcl_CreateChannel</emphasis>.  After this call,
the channel becomes the property of the interpreter, and the caller should
not call <function>Tcl_Close</function> for the channel; the channel will be closed
automatically when it is unregistered from the interpreter.</para>

<para>Code executing outside of any Tcl interpreter can call
<function>Tcl_RegisterChannel</function> with <emphasis remap='I'>interp</emphasis> as NULL, to indicate that it
wishes to hold a reference to this channel. Subsequently, the channel can
be registered in a Tcl interpreter and it will only be closed when the
matching number of calls to <function>Tcl_UnregisterChannel</function> have been made.
This allows code executing outside of any interpreter to safely hold a
reference to a channel that is also registered in a Tcl interpreter.</para>

<para>This procedure interacts with the code managing the standard
channels. If no standard channels were initialized before the first
call to <function>Tcl_RegisterChannel</function>, they will get initialized by that
call. See <emphasis remap='B'>Tcl_StandardChannels</emphasis> for a general treatise about
standard channels and the behaviour of the Tcl library with regard to
them.</para>

</refsect1>

<refsect1 xml:id='tcl_unregisterchannel'><title>TCL_UNREGISTERCHANNEL</title>
<para><function>Tcl_UnregisterChannel</function> removes a channel from the set of channels
accessible in <emphasis remap='I'>interp</emphasis>. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
If this operation removed the last registration of the channel in any
interpreter, the channel is also closed and destroyed.</para>

<para>Code not associated with a Tcl interpreter can call
<function>Tcl_UnregisterChannel</function> with <emphasis remap='I'>interp</emphasis> as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, it will now be closed.  <function>Tcl_UnregisterChannel</function>
is very similar to <function>Tcl_DetachChannel</function> except that it will also
close the channel if no further references to it exist.</para>

</refsect1>

<refsect1 xml:id='tcl_detachchannel'><title>TCL_DETACHCHANNEL</title>
<para><function>Tcl_DetachChannel</function> removes a channel from the set of channels
accessible in <emphasis remap='I'>interp</emphasis>. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
Beyond that, this command has no further effect.  It cannot be used on
the standard channels (stdout, stderr, stdin), and will return
<emphasis remap='B'>TCL_ERROR</emphasis> if passed one of those channels.</para>

<para>Code not associated with a Tcl interpreter can call
<function>Tcl_DetachChannel</function> with <emphasis remap='I'>interp</emphasis> as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, unlike <function>Tcl_UnregisterChannel</function>, 
it will not be closed.</para>

</refsect1>

<refsect1 xml:id='tcl_isstandardchannel'><title>TCL_ISSTANDARDCHANNEL</title>
<para><function>Tcl_IsStandardChannel</function> tests whether a channel is one of the
three standard channels, stdin, stdout or stderr.  If so, it returns
1, otherwise 0.</para>

<para>No attempt is made to check whether the given channel or the standard 
channels are initialized or otherwise valid.</para>

</refsect1>

<refsect1 xml:id='tcl_close'><title>TCL_CLOSE</title>
<para><function>Tcl_Close</function> destroys the channel <emphasis remap='I'>channel</emphasis>, which must denote a
currently open channel. The channel should not be registered in any
interpreter when <function>Tcl_Close</function> is called. Buffered output is flushed to
the channel's output device prior to destroying the channel, and any
buffered input is discarded.  If this is a blocking channel, the call does
not return until all buffered data is successfully sent to the channel's
output device.  If this is a nonblocking channel and there is buffered
output that cannot be written without blocking, the call returns
immediately; output is flushed in the background and the channel will be
closed once all of the buffered data has been output.  In this case errors
during flushing are not reported.</para>

<para>If the channel was closed successfully, <function>Tcl_Close</function> returns <emphasis remap='B'>TCL_OK</emphasis>.
If an error occurs, <function>Tcl_Close</function> returns <emphasis remap='B'>TCL_ERROR</emphasis> and records a
POSIX error code that can be retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.
If the channel is being closed synchronously and an error occurs during
closing of the channel and <emphasis remap='I'>interp</emphasis> is not NULL, an error message is
left in the interpreter's result.</para>

<para>Note: it is not safe to call <function>Tcl_Close</function> on a channel that has been
registered using <function>Tcl_RegisterChannel</function>; see the documentation for
<function>Tcl_RegisterChannel</function>, above, for details. If the channel has ever
been given as the <emphasis remap='B'>chan</emphasis> argument in a call to
<function>Tcl_RegisterChannel</function>, you should instead use
<function>Tcl_UnregisterChannel</function>, which will internally call <function>Tcl_Close</function>
when all calls to <function>Tcl_RegisterChannel</function> have been matched by
corresponding calls to <function>Tcl_UnregisterChannel</function>.</para>

</refsect1>

<refsect1 xml:id='tcl_readchars_and_tcl_read'><title>TCL_READCHARS AND TCL_READ</title>
<para><function>Tcl_ReadChars</function> consumes bytes from <emphasis remap='I'>channel</emphasis>, converting the bytes
to UTF-8 based on the channel's encoding and storing the produced data in 
<emphasis remap='I'>readObjPtr</emphasis>'s string representation.  The return value of
<function>Tcl_ReadChars</function> is the number of characters, up to <emphasis remap='I'>charsToRead</emphasis>,
that were stored in <emphasis remap='I'>readObjPtr</emphasis>.  If an error occurs while reading, the
return value is -1 and <function>Tcl_ReadChars</function> records a POSIX error code that
can be retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.</para>

<para>Setting <emphasis remap='I'>charsToRead</emphasis> to <option>-1</option> will cause the command to read
all characters currently available (non-blocking) or everything until
eof (blocking mode).</para>

<para>The return value may be smaller than the value to read, indicating that less
data than requested was available.  This is called a <emphasis remap='I'>short read</emphasis>.  In
blocking mode, this can only happen on an end-of-file.  In nonblocking mode,
a short read can also occur if there is not enough input currently
available:  <function>Tcl_ReadChars</function> returns a short count rather than waiting
for more data.</para>

<para>If the channel is in blocking mode, a return value of zero indicates an
end-of-file condition.  If the channel is in nonblocking mode, a return
value of zero indicates either that no input is currently available or an
end-of-file condition.  Use <function>Tcl_Eof</function> and <function>Tcl_InputBlocked</function> to tell
which of these conditions actually occurred.</para>

<para><function>Tcl_ReadChars</function> translates the various end-of-line representations into
the canonical <emphasis remap='B'>\n</emphasis> internal representation according to the current
end-of-line recognition mode.  End-of-line recognition and the various
platform-specific modes are described in the manual entry for the Tcl
<emphasis remap='B'>fconfigure</emphasis> command.</para>

<para>As a performance optimization, when reading from a channel with the encoding
<emphasis remap='B'>binary</emphasis>, the bytes are not converted to UTF-8 as they are read.
Instead, they are stored in <emphasis remap='I'>readObjPtr</emphasis>'s internal representation as a
byte-array object.  The string representation of this object will only be
constructed if it is needed (e.g., because of a call to
<emphasis remap='B'>Tcl_GetStringFromObj</emphasis>).  In this way, byte-oriented data can be read
from a channel, manipulated by calling <emphasis remap='B'>Tcl_GetByteArrayFromObj</emphasis> and
related functions, and then written to a channel without the expense of ever
converting to or from UTF-8.</para>

<para><function>Tcl_Read</function> is similar to <function>Tcl_ReadChars</function>, except that it does not do
encoding conversions, regardless of the channel's encoding.  It is deprecated
and exists for backwards compatibility with non-internationalized Tcl
extensions.  It consumes bytes from <emphasis remap='I'>channel</emphasis> and stores them in
<emphasis remap='I'>readBuf</emphasis>, performing end-of-line translations on the way.  The return value
of <function>Tcl_Read</function> is the number of bytes, up to <emphasis remap='I'>bytesToRead</emphasis>, written in
<emphasis remap='I'>readBuf</emphasis>.  The buffer produced by <function>Tcl_Read</function> is not null-terminated.
Its contents are valid from the zeroth position up to and excluding the
position indicated by the return value.</para>  

<para><function>Tcl_ReadRaw</function> is the same as <function>Tcl_Read</function> but does not
compensate for stacking. While <function>Tcl_Read</function> (and the other functions
in the API) always get their data from the topmost channel in the
stack the supplied channel is part of, <function>Tcl_ReadRaw</function> does
not. Thus this function is <emphasis remap='B'>only</emphasis> usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the channel below into the transformation.</para>

</refsect1>

<refsect1 xml:id='tcl_getsobj_and_tcl_gets'><title>TCL_GETSOBJ AND TCL_GETS</title>
<para><function>Tcl_GetsObj</function> consumes bytes from <emphasis remap='I'>channel</emphasis>, converting the bytes to
UTF-8 based on the channel's encoding, until a full line of input has been
seen.  If the channel's encoding is <emphasis remap='B'>binary</emphasis>, each byte read from the
channel is treated as an individual Unicode character.  All of the
characters of the line except for the terminating end-of-line character(s)
are appended to <emphasis remap='I'>lineObjPtr</emphasis>'s string representation.  The end-of-line
character(s) are read and discarded.</para>

<para>If a line was successfully read, the return value is greater than or equal
to zero and indicates the number of bytes stored in <emphasis remap='I'>lineObjPtr</emphasis>.  If an
error occurs, <function>Tcl_GetsObj</function> returns -1 and records a POSIX error code
that can be retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.  <function>Tcl_GetsObj</function> also
returns -1 if the end of the file is reached; the <function>Tcl_Eof</function> procedure
can be used to distinguish an error from an end-of-file condition.</para>

<para>If the channel is in nonblocking mode, the return value can also be -1 if
no data was available or the data that was available did not contain an
end-of-line character.  When -1 is returned, the <function>Tcl_InputBlocked</function>
procedure may be invoked to determine if the channel is blocked because
of input unavailability.</para>

<para><function>Tcl_Gets</function> is the same as <function>Tcl_GetsObj</function> except the resulting
characters are appended to the dynamic string given by
<emphasis remap='I'>lineRead</emphasis> rather than a Tcl object.</para>

</refsect1>

<refsect1 xml:id='tcl_ungets'><title>TCL_UNGETS</title>
<para><function>Tcl_Ungets</function> is used to add data to the input queue of a channel,
at either the head or tail of the queue.  The pointer <emphasis remap='I'>input</emphasis> points
to the data that is to be added.  The length of the input to add is given
by <emphasis remap='I'>inputLen</emphasis>.  A non-zero value of <emphasis remap='I'>addAtEnd</emphasis> indicates that the
data is to be added at the end of queue; otherwise it will be added at the
head of the queue.  If <emphasis remap='I'>channel</emphasis> has a
<quote>sticky</quote>
EOF set, no data will be
added to the input queue.  <function>Tcl_Ungets</function> returns <emphasis remap='I'>inputLen</emphasis> or
-1 if an error occurs.</para>

</refsect1>

<refsect1 xml:id='tcl_writechars_tcl_writeobj_and_tcl_writ'><title>TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE</title>
<para><function>Tcl_WriteChars</function> accepts <emphasis remap='I'>bytesToWrite</emphasis> bytes of character data at
<emphasis remap='I'>charBuf</emphasis>.  The UTF-8 characters in the buffer are converted to the
channel's encoding and queued for output to <emphasis remap='I'>channel</emphasis>.  If
<emphasis remap='I'>bytesToWrite</emphasis> is negative, <function>Tcl_WriteChars</function> expects <emphasis remap='I'>charBuf</emphasis>
to be null-terminated and it outputs everything up to the null.</para>

<para>Data queued for output may not appear on the output device immediately, due
to internal buffering.  If the data should appear immediately, call
<function>Tcl_Flush</function> after the call to <function>Tcl_WriteChars</function>, or set the 
<option>-buffering</option> option on the channel to <emphasis remap='B'>none</emphasis>.  If you wish the data
to appear as soon as a complete line is accepted for output, set the
<option>-buffering</option> option on the channel to <emphasis remap='B'>line</emphasis> mode.</para>

<para>The return value of <function>Tcl_WriteChars</function> is a count of how many bytes were
accepted for output to the channel.  This is either greater than zero to
indicate success or -1 to indicate that an error occurred.  If an error
occurs, <function>Tcl_WriteChars</function> records a POSIX error code that may be
retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.</para>

<para>Newline characters in the output data are translated to platform-specific
end-of-line sequences according to the <option>-translation</option> option for the
channel.  This is done even if the channel has no encoding.</para>

<para><function>Tcl_WriteObj</function> is similar to <function>Tcl_WriteChars</function> except it
accepts a Tcl object whose contents will be output to the channel.  The
UTF-8 characters in <emphasis remap='I'>writeObjPtr</emphasis>'s string representation are converted
to the channel's encoding and queued for output to <emphasis remap='I'>channel</emphasis>.  
As a performance optimization, when writing to a channel with the encoding
<emphasis remap='B'>binary</emphasis>, UTF-8 characters are not converted as they are written.
Instead, the bytes in <emphasis remap='I'>writeObjPtr</emphasis>'s internal representation as a
byte-array object are written to the channel.  The byte-array representation
of the object will be constructed if it is needed.  In this way,
byte-oriented data can be read from a channel, manipulated by calling
<emphasis remap='B'>Tcl_GetByteArrayFromObj</emphasis> and related functions, and then written to a
channel without the expense of ever converting to or from UTF-8.</para>

<para><function>Tcl_Write</function> is similar to <function>Tcl_WriteChars</function> except that it does not do
encoding conversions, regardless of the channel's encoding.  It is
deprecated and exists for backwards compatibility with non-internationalized
Tcl extensions.  It accepts <emphasis remap='I'>bytesToWrite</emphasis> bytes of data at
<emphasis remap='I'>byteBuf</emphasis> and queues them for output to <emphasis remap='I'>channel</emphasis>.  If
<emphasis remap='I'>bytesToWrite</emphasis> is negative, <function>Tcl_Write</function> expects <emphasis remap='I'>byteBuf</emphasis> to be
null-terminated and it outputs everything up to the null.</para>

<para><function>Tcl_WriteRaw</function> is the same as <function>Tcl_Write</function> but does not
compensate for stacking. While <function>Tcl_Write</function> (and the other
functions in the API) always feed their input to the topmost channel
in the stack the supplied channel is part of, <function>Tcl_WriteRaw</function> does
not. Thus this function is <emphasis remap='B'>only</emphasis> usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the transformation into the channel below
it.</para>

</refsect1>

<refsect1 xml:id='tcl_flush'><title>TCL_FLUSH</title>
<para><function>Tcl_Flush</function> causes all of the buffered output data for <emphasis remap='I'>channel</emphasis>
to be written to its underlying file or device as soon as possible.
If the channel is in blocking mode, the call does not return until
all the buffered data has been sent to the channel or some error occurred.
The call returns immediately if the channel is nonblocking; it starts
a background flush that will write the buffered data to the channel
eventually, as fast as the channel is able to absorb it.</para>

<para>The return value is normally <emphasis remap='B'>TCL_OK</emphasis>.
If an error occurs, <function>Tcl_Flush</function> returns <emphasis remap='B'>TCL_ERROR</emphasis> and
records a POSIX error code that can be retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.</para>

</refsect1>

<refsect1 xml:id='tcl_seek'><title>TCL_SEEK</title>
<para><function>Tcl_Seek</function> moves the access point in <emphasis remap='I'>channel</emphasis> where subsequent
data will be read or written. Buffered output is flushed to the channel and
buffered input is discarded, prior to the seek operation.</para>

<para><function>Tcl_Seek</function> normally returns the new access point.
If an error occurs, <function>Tcl_Seek</function> returns -1 and records a POSIX error
code that can be retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.
After an error, the access point may or may not have been moved.</para>

</refsect1>

<refsect1 xml:id='tcl_tell'><title>TCL_TELL</title>
<para><function>Tcl_Tell</function> returns the current access point for a channel. The returned
value is -1 if the channel does not support seeking.</para>

</refsect1>

<refsect1 xml:id='tcl_truncatechannel'><title>TCL_TRUNCATECHANNEL</title>
<!-- .VS 8.5 -->
<para><function>Tcl_TruncateChannel</function> truncates the file underlying <emphasis remap='I'>channel</emphasis>
to a given <emphasis remap='I'>length</emphasis> of bytes. It returns <emphasis remap='B'>TCL_OK</emphasis> if the
operation succeeded, and <emphasis remap='B'>TCL_ERROR</emphasis> otherwise.</para>
<!-- .VE 8.5 -->

</refsect1>

<refsect1 xml:id='tcl_getchanneloption'><title>TCL_GETCHANNELOPTION</title>
<para><function>Tcl_GetChannelOption</function> retrieves, in <emphasis remap='I'>optionValue</emphasis>, the value of one of
the options currently in effect for a channel, or a list of all options and
their values.  The <emphasis remap='I'>channel</emphasis> argument identifies the channel for which
to query an option or retrieve all options and their values.
If <emphasis remap='I'>optionName</emphasis> is not NULL, it is the name of the
option to query; the option's value is copied to the Tcl dynamic string
denoted by <emphasis remap='I'>optionValue</emphasis>. If
<emphasis remap='I'>optionName</emphasis> is NULL, the function stores an alternating list of option
names and their values in <emphasis remap='I'>optionValue</emphasis>, using a series of calls to
<emphasis remap='B'>Tcl_DStringAppendElement</emphasis>. The various preexisting options and
their possible values are described in the manual entry for the Tcl
<emphasis remap='B'>fconfigure</emphasis> command. Other options can be added by each channel type.
These channel type specific options are described in the manual entry for
the Tcl command that creates a channel of that type; for example, the
additional options for TCP based channels are described in the manual entry
for the Tcl <emphasis remap='B'>socket</emphasis> command.
The procedure normally returns <emphasis remap='B'>TCL_OK</emphasis>. If an error occurs, it returns
<emphasis remap='B'>TCL_ERROR</emphasis> and calls <emphasis remap='B'>Tcl_SetErrno</emphasis> to store an appropriate POSIX
error code.</para>

</refsect1>

<refsect1 xml:id='tcl_setchanneloption'><title>TCL_SETCHANNELOPTION</title>
<para><function>Tcl_SetChannelOption</function> sets a new value <emphasis remap='I'>newValue</emphasis>
for an file <option>optionName</option> on <emphasis remap='I'>channel</emphasis>.
The procedure normally returns <emphasis remap='B'>TCL_OK</emphasis>.  If an error occurs,
it returns <emphasis remap='B'>TCL_ERROR</emphasis>;  in addition, if <emphasis remap='I'>interp</emphasis> is non-NULL,
<function>Tcl_SetChannelOption</function> leaves an error message in the interpreter's result.</para>

</refsect1>

<refsect1 xml:id='tcl_eof'><title>TCL_EOF</title>
<para><function>Tcl_Eof</function> returns a nonzero value if <emphasis remap='I'>channel</emphasis> encountered
an end of file during the last input operation.</para>

</refsect1>

<refsect1 xml:id='tcl_inputblocked'><title>TCL_INPUTBLOCKED</title>
<para><function>Tcl_InputBlocked</function> returns a nonzero value if <emphasis remap='I'>channel</emphasis> is in
nonblocking mode and the last input operation returned less data than
requested because there was insufficient data available.
The call always returns zero if the channel is in blocking mode.</para>

</refsect1>

<refsect1 xml:id='tcl_inputbuffered'><title>TCL_INPUTBUFFERED</title>
<para><function>Tcl_InputBuffered</function> returns the number of bytes of input currently
buffered in the internal buffers for a channel. If the channel is not open
for reading, this function always returns zero.</para>

</refsect1>

<refsect1 xml:id='tcl_outputbuffered'><title>TCL_OUTPUTBUFFERED</title>
<para><function>Tcl_OutputBuffered</function> returns the number of bytes of output
currently buffered in the internal buffers for a channel. If the
channel is not open for writing, this function always returns zero.</para>

</refsect1>

<refsect1 xml:id='platform_issues'><title>PLATFORM ISSUES</title>
<para>The handles returned from <emphasis remap='B'>Tcl_GetChannelHandle</emphasis> depend on the
platform and the channel type.  On Unix platforms, the handle is
always a Unix file descriptor as returned from the <emphasis remap='B'>open</emphasis> system
call.  On Windows platforms, the handle is a file <filename>HANDLE</filename> when
the channel was created with <function>Tcl_OpenFileChannel</function>,
<function>Tcl_OpenCommandChannel</function>, or <function>Tcl_MakeFileChannel</function>.  Other
channel types may return a different type of handle on Windows
platforms.</para>

</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>DS<citerefentry><refentrytitle>tring</refentrytitle><manvolnum>3</manvolnum></citerefentry>, fconfigure(n), filename(n), <citerefentry><refentrytitle>fopen</refentrytitle><manvolnum>3</manvolnum></citerefentry>, Tcl_CreateC<citerefentry><refentrytitle>hannel</refentrytitle><manvolnum>3</manvolnum></citerefentry></para>

</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>access point, blocking, buffered I/O, channel, channel driver, end of file,
flush, input, nonblocking, output, read, seek, write</para>
</refsect1>
</refentry>

