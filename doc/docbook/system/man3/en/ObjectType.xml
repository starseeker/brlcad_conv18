<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='objecttype3'>

<!-- '\" Copyright (c) 1996\-1997 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>8.0</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_ObjType</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>8.0</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_RegisterObjType</refname>
<refname>Tcl_GetObjType</refname>
<refname>Tcl_AppendAllObjTypes</refname>
<refname>Tcl_ConvertToType</refname>
<refpurpose>manipulate Tcl object types</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef><function>Tcl_RegisterObjType</function></funcdef>
<paramdef><parameter>typePtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_ObjType</function> *Tcl_GetObjType</funcdef>
<paramdef><parameter>typeName</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_AppendAllObjTypes</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ConvertToType</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>objPtr</parameter></paramdef>
<paramdef><parameter>typePtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS const char *typeName -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_ObjType"</entry><entry>"*typePtr"</entry><entry>"in"</entry>
<entry>
<para>Points to the structure containing information about the Tcl object type.
This storage must live forever,
typically by being statically allocated.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*typeName</entry><entry>in</entry>
<entry>
<para>The name of a Tcl object type that <emphasis remap='B'>Tcl_GetObjType</emphasis> should look up.</para>
</entry>
</row>
<row><entry>Tcl_Interp</entry><entry>*interp</entry><entry>in</entry>
<entry>
<para>Interpreter to use for error reporting.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*objPtr</entry><entry>in</entry>
<entry>
<para>For <function>Tcl_AppendAllObjTypes</function>, this points to the object onto which
it appends the name of each object type as a list element.
For <function>Tcl_ConvertToType</function>, this points to an object that
must have been the result of a previous call to <emphasis remap='B'>Tcl_NewObj</emphasis>.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para>The procedures in this man page manage Tcl object types.
They are used to register new object types, look up types,
and force conversions from one type to another.</para>

<para><function>Tcl_RegisterObjType</function> registers a new Tcl object type
in the table of all object types that <emphasis remap='B'>Tcl_GetObjType</emphasis>
can look up by name.  There are other object types supported by Tcl
as well, which Tcl chooses not to register.  Extensions can likewise
choose to register the object types they create or not.
The argument <emphasis remap='I'>typePtr</emphasis> points to a Tcl_ObjType structure that
describes the new type by giving its name
and by supplying pointers to four procedures
that implement the type.
If the type table already contains a type
with the same name as in <emphasis remap='I'>typePtr</emphasis>,
it is replaced with the new type.
The Tcl_ObjType structure is described
in the section <emphasis remap='B'>THE TCL_OBJTYPE STRUCTURE</emphasis> below.</para>

<para><emphasis remap='B'>Tcl_GetObjType</emphasis> returns a pointer to the registered Tcl_ObjType
with name <emphasis remap='I'>typeName</emphasis>.
It returns NULL if no type with that name is registered.</para>

<para><function>Tcl_AppendAllObjTypes</function> appends the name of each registered object type
as a list element onto the Tcl object referenced by <varname role='parameter'>objPtr</varname>.
The return value is <emphasis remap='B'>TCL_OK</emphasis> unless there was an error
converting <varname role='parameter'>objPtr</varname> to a list object;
in that case <emphasis remap='B'>TCL_ERROR</emphasis> is returned.</para>

<para><function>Tcl_ConvertToType</function> converts an object from one type to another
if possible.
It creates a new internal representation for <varname role='parameter'>objPtr</varname>
appropriate for the target type <emphasis remap='I'>typePtr</emphasis>
and sets its <emphasis remap='I'>typePtr</emphasis> member as determined by calling the 
<emphasis remap='I'>typePtr-&gt;setFromAnyProc</emphasis> routine.  
Any internal representation for <varname role='parameter'>objPtr</varname>'s old type is freed.
If an error occurs during conversion, it returns <emphasis remap='B'>TCL_ERROR</emphasis>
and leaves an error message in the result object for <varname role='parameter'>interp</varname>
unless <varname role='parameter'>interp</varname> is NULL.
Otherwise, it returns <emphasis remap='B'>TCL_OK</emphasis>.
Passing a NULL <varname role='parameter'>interp</varname> allows this procedure to be used
as a test whether the conversion can be done (and in fact was done).</para>
<!-- .VS 8.5 -->

<para>In many cases, the <emphasis remap='I'>typePtr-&gt;setFromAnyProc</emphasis> routine will
set <emphasis remap='I'>objPtr-&gt;typePtr</emphasis> to the argument value <emphasis remap='I'>typePtr</emphasis>,
but that is no longer guaranteed.  The <emphasis remap='I'>setFromAnyProc</emphasis> is
free to set the internal representation for <varname role='parameter'>objPtr</varname> to make
use of another related Tcl_ObjType, if it sees fit.</para>
<!-- .VE 8.5 -->
</refsect1>

<refsect1 xml:id='the_tcl_objtype_structure'><title>THE TCL_OBJTYPE STRUCTURE</title>
<para>Extension writers can define new object types by defining four
procedures and
initializing a Tcl_ObjType structure to describe the type.
Extension writers may also pass a pointer to their Tcl_ObjType
structure to <function>Tcl_RegisterObjType</function> if they wish to permit
other extensions to look up their Tcl_ObjType by name with
the <emphasis remap='B'>Tcl_GetObjType</emphasis> routine.
The <function>Tcl_ObjType</function> structure is defined as follows:</para>

<programlisting remap='CS'>
typedef struct Tcl_ObjType {
    char *<emphasis remap='I'>name</emphasis>;
    Tcl_FreeInternalRepProc *<emphasis remap='I'>freeIntRepProc</emphasis>;
    Tcl_DupInternalRepProc *<emphasis remap='I'>dupIntRepProc</emphasis>;
    Tcl_UpdateStringProc *<emphasis remap='I'>updateStringProc</emphasis>;
    Tcl_SetFromAnyProc *<emphasis remap='I'>setFromAnyProc</emphasis>;
} Tcl_ObjType;
</programlisting> <!-- remap='CE' -->

<refsect2 xml:id='the_name_field'><title>THE NAME FIELD</title>

<para>The <emphasis remap='I'>name</emphasis> member describes the name of the type, e.g. <emphasis remap='B'>int</emphasis>.
When a type is registered, this is the name used by callers
of <emphasis remap='B'>Tcl_GetObjType</emphasis> to lookup the type.  For unregistered
types, the <emphasis remap='I'>name</emphasis> field is primarily of value for debugging.
The remaining four members are pointers to procedures
called by the generic Tcl object code:</para>
</refsect2>

<refsect2 xml:id='the_setfromanyproc_field'><title>THE SETFROMANYPROC FIELD</title>

<para>The <emphasis remap='I'>setFromAnyProc</emphasis> member contains the address of a function
called to create a valid internal representation
from an object's string representation.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int ( <function>Tcl_SetFromAnyProc</function> )</funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>objPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>If an internal representation cannot be created from the string,
it returns <emphasis remap='B'>TCL_ERROR</emphasis> and puts a message
describing the error in the result object for <varname role='parameter'>interp</varname>
unless <varname role='parameter'>interp</varname> is NULL.
If <emphasis remap='I'>setFromAnyProc</emphasis> is successful,
it stores the new internal representation,
sets <varname role='parameter'>objPtr</varname>'s <emphasis remap='I'>typePtr</emphasis> member to point to
the <function>Tcl_ObjType</function> struct corresponding to the new
internal representation, and returns <emphasis remap='B'>TCL_OK</emphasis>.
Before setting the new internal representation,
the <emphasis remap='I'>setFromAnyProc</emphasis> must free any internal representation
of <varname role='parameter'>objPtr</varname>'s old type;
it does this by calling the old type's <emphasis remap='I'>freeIntRepProc</emphasis>
if it is not NULL.</para>

<para>As an example, the <emphasis remap='I'>setFromAnyProc</emphasis> for the built-in Tcl list type
gets an up-to-date string representation for <varname role='parameter'>objPtr</varname>
by calling <emphasis remap='B'>Tcl_GetStringFromObj</emphasis>.
It parses the string to verify it is in a valid list format and
to obtain each element value in the list, and, if this succeeds,
stores the list elements in <varname role='parameter'>objPtr</varname>'s internal representation
and sets <varname role='parameter'>objPtr</varname>'s <emphasis remap='I'>typePtr</emphasis> member to point to the list type's
Tcl_ObjType structure.</para>

<para>Do not release <varname role='parameter'>objPtr</varname>'s old internal representation unless you
replace it with a new one or reset the <emphasis remap='I'>typePtr</emphasis> member to NULL.</para>

<para>The <emphasis remap='I'>setFromAnyProc</emphasis> member may be set to NULL, if the routines
making use of the internal representation have no need to derive that
internal representation from an arbitrary string value.  However, in
this case, passing a pointer to the type to Tcl_ConvertToType() will
lead to a panic, so to avoid this possibility, the type
should <emphasis remap='I'>not</emphasis> be registered.</para>
</refsect2>

<refsect2 xml:id='the_updatestringproc_field'><title>THE UPDATESTRINGPROC FIELD</title>

<para>The <emphasis remap='I'>updateStringProc</emphasis> member contains the address of a function
called to create a valid string representation
from an object's internal representation.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcsynopsisinfo>
typedef void (Tcl_UpdateStringProc) (Tcl_Obj *objPtr);
</funcsynopsisinfo>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para><varname role='parameter'>objPtr</varname>'s <emphasis remap='I'>bytes</emphasis> member is always NULL when it is called.
It must always set <emphasis remap='I'>bytes</emphasis> non-NULL before returning.
We require the string representation's byte array
to have a null after the last byte, at offset <emphasis remap='I'>length</emphasis>,
and to have no null bytes before that; this allows string representations 
to be treated as conventional null character-terminated C strings.
These restrictions are easily met by using Tcl's internal UTF encoding
for the string representation, same as one would do for other
Tcl routines accepting string values as arguments.
Storage for the byte array must be allocated in the heap by <emphasis remap='B'>Tcl_Alloc</emphasis>
or <emphasis remap='B'>ckalloc</emphasis>.  Note that <emphasis remap='I'>updateStringProc</emphasis>s must allocate
enough storage for the string's bytes and the terminating null byte.</para>

<para>The <emphasis remap='I'>updateStringProc</emphasis> for Tcl's built-in double type, for example,
calls Tcl_PrintDouble to write to a buffer of size TCL_DOUBLE_SPACE,
then allocates and copies the string representation to just enough
space to hold it.  A pointer to the allocated space is stored in
the <emphasis remap='I'>bytes</emphasis> member.</para>

<para>The <emphasis remap='I'>updateStringProc</emphasis> member may be set to NULL, if the routines
making use of the internal representation are written so that the
string representation is never invalidated.  Failure to meet this
obligation will lead to panics or crashes when <emphasis remap='B'>Tcl_GetStringFromObj</emphasis>
or other similar routines ask for the string representation.</para>
</refsect2>

<refsect2 xml:id='the_dupintrepproc_field'><title>THE DUPINTREPPROC FIELD</title>

<para>The <emphasis remap='I'>dupIntRepProc</emphasis> member contains the address of a function
called to copy an internal representation from one object to another.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef void ( <function>Tcl_DupInternalRepProc</function> )</funcdef>
    <paramdef>Tcl_Obj * <parameter>srcPtr</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>dupPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para><varname role='parameter'>dupPtr</varname>'s internal representation is made a copy of <varname role='parameter'>srcPtr</varname>'s
internal representation.
Before the call,
<varname role='parameter'>srcPtr</varname>'s internal representation is valid and <varname role='parameter'>dupPtr</varname>'s is not.
<varname role='parameter'>srcPtr</varname>'s object type determines what
copying its internal representation means.</para>

<para>For example, the <emphasis remap='I'>dupIntRepProc</emphasis> for the Tcl integer type
simply copies an integer.
The built-in list type's <emphasis remap='I'>dupIntRepProc</emphasis> uses a far more
sophisticated scheme to continue sharing storage as much as it
reasonably can.</para>
</refsect2>

<refsect2 xml:id='the_freeintrepproc_field'><title>THE FREEINTREPPROC FIELD</title>

<para>The <emphasis remap='I'>freeIntRepProc</emphasis> member contains the address of a function
that is called when an object is freed.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcsynopsisinfo>
typedef void (Tcl_FreeInternalRepProc) (Tcl_Obj *objPtr);
</funcsynopsisinfo>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The <emphasis remap='I'>freeIntRepProc</emphasis> function can deallocate the storage
for the object's internal representation
and do other type-specific processing necessary when an object is freed.</para>

<para>For example, the list type's <emphasis remap='I'>freeIntRepProc</emphasis> respects
the storage sharing scheme established by the <emphasis remap='I'>dupIntRepProc</emphasis>
so that it only frees storage when the last object sharing it
is being freed.</para>

<para>The <emphasis remap='I'>freeIntRepProc</emphasis> member can be set to NULL
to indicate that the internal representation does not require freeing.
The <emphasis remap='I'>freeIntRepProc</emphasis> implementation must not access the
<emphasis remap='I'>bytes</emphasis> member of the object, since Tcl makes its own internal
uses of that field during object deletion.  The defined tasks for
the <emphasis remap='I'>freeIntRepProc</emphasis> have no need to consult the <emphasis remap='I'>bytes</emphasis>
member.</para>
</refsect2>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount</para>
</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>internal representation, object, object type, string representation, type conversion</para>
</refsect1>
</refentry>

