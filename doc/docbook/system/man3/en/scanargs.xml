<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='scanargs3'>
<refentryinfo><date>7/23/90</date></refentryinfo>
<refmeta>
<refentrytitle>SCANARGS</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>7/23/90</refmiscinfo>
</refmeta>
<refnamediv>
<refname>scanargs</refname>
<refname>qscanargs</refname>
<refpurpose>formatted conversion from command argument list</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;stdio.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef><function>scanargs</function></funcdef>
<paramdef><parameter>argc</parameter></paramdef>
<paramdef><parameter>argv</parameter></paramdef>
<paramdef><parameter>format 
 [</parameter></paramdef>
<paramdef><parameter>pointer ] ... 
</parameter></paramdef>
</funcprototype>
<funcsynopsisinfo>

int argc;

char *argv[];

char *format;
</funcsynopsisinfo>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para><emphasis remap='I'>Scanargs</emphasis>
reads
<emphasis remap='I'>argc</emphasis>
arguments from an argument list pointed to by
<emphasis remap='I'>argv.</emphasis>
It converts the argument list according to the format string,
and stores the results of the conversions in its parameters.</para>

<para>Scanargs expects as its parameters an argument count
<emphasis remap='I'>argc,</emphasis>
a pointer to an argument list
<emphasis remap='I'>argv</emphasis>
(see
<citerefentry><refentrytitle>exec</refentrytitle><manvolnum>2</manvolnum></citerefentry>),
a control string
<emphasis remap='I'>format,</emphasis>
described below, and a set of
<emphasis remap='I'>pointer</emphasis>
arguments indicating where the converted output should be stored.</para>

<para>The control string contains specifications, which are used to direct
interpretation of argument sequences.  It contains
the necessary information to describe an acceptable
syntax for the argument list, and the expected meaning of each argument.</para>

<para>If the scanning fails it will print a cryptic
message telling why it failed, and generate a
<emphasis remap='I'>usage</emphasis>
message from the control string.</para>

<para>The control string is composed of two parts:</para>

<para><emphasis remap='B'>Name: The first characters in the string are assumed to be the calling</emphasis>
name of the program being executed. This is used for generation of
usage messages, but is otherwise ignored.
If this field is a % sign, it is replaced with the contents of
<emphasis remap='I'>argv</emphasis>[0]
in the message.</para>

<para><emphasis remap='B'>Conversions: Following the name, an optional list of conversion specifications is given,</emphasis>
with separating spaces.  The structure of a conversion specification:</para>
  <blockquote remap='RS'>

<para><emphasis remap='B'>label_key_conversion</emphasis>
  </para></blockquote> <!-- remap='RE' -->

<para>consists of a
<emphasis remap='I'>label</emphasis>
which is a string of non-space characters describing the acceptable
argument, a
<emphasis remap='I'>key</emphasis>
which may be either of</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>%</emphasis></term>
  <listitem>
<para>The argument is optional. Its absence is ignored.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>!</emphasis></term>
  <listitem>
<para>A required argument. If absent, an error return ensues.</para>
  </listitem>
  </varlistentry>
</variablelist>

<para>The
<emphasis remap='I'>conversion</emphasis>
character indicates the interpretation of the argument; the corresponding
pointer parameter must be of a restricted type.</para>

<para>The following conversion characters are supported:</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>d D</emphasis></term>
  <listitem>
<para>a decimal integer is expected; the corresponding parameter should be an
<emphasis remap='I'>int</emphasis>
or a
<emphasis remap='I'>long</emphasis>
(if
<emphasis remap='B'>D</emphasis>
is specified) pointer.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>o O</emphasis></term>
  <listitem>
<para>an octal integer is expected; the corresponding parameter should be an
<emphasis remap='I'>int</emphasis>
or a
<emphasis remap='I'>long</emphasis>
pointer.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>x X</emphasis></term>
  <listitem>
<para>a hexadecimal integer is expected; the corresponding parameter should be an
<emphasis remap='I'>int</emphasis>
or a
<emphasis remap='I'>long</emphasis>
pointer.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>n N</emphasis></term>
  <listitem>
<para>an integer numeric conversion using
<emphasis remap='I'>C</emphasis>
language syntax.  Numbers beginning
<emphasis remap='B'>0x</emphasis>
are hexadecimal, numbers beginning
<literal>0</literal>
are octal, and other numbers are decimal.  Negative hex numbers must have
the minus sign
<emphasis remap='I'>following</emphasis>
the
<emphasis remap='B'>0x</emphasis>,
i.e. negative 0xa would be given as 0x-a.  The corresponding pointer
should point to an
<emphasis remap='I'>int</emphasis>
or a
<emphasis remap='I'>long.</emphasis></para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>f F</emphasis></term>
  <listitem>
<para>a floating point number is expected; the corresponding parameter should
be a pointer to a
<emphasis remap='I'>float</emphasis>
or a
<emphasis remap='I'>double.</emphasis></para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>s</emphasis></term>
  <listitem>
<para>a character string is expected; the corresponding parameter should be the
address of a pointer to
<emphasis remap='I'>char.</emphasis></para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>-</emphasis></term>
  <listitem>
<para>a single character flag is expected; the corresponding parameter should
be an
<emphasis remap='I'>int</emphasis>
pointer.  The occurrence of a
<emphasis remap='B'>-</emphasis>
followed by the character specified in the label
will cause the setting of the least significant bit of the integer pointed to
by the corresponding parameter.  The label may consist of up to sixteen
(actually, up to the number of bits in an <emphasis remap='I'>int</emphasis>) option
characters, in which case one of the bits of the integer is independently
set to reflect which one of the flags was present. (The right most character
corresponds to the LSB of the integer)  Only one option may be chosen from
each conversion specification.  The bits which are not set will remain in
their previous state.  For example, a specification of
<emphasis remap='B'>abc%-</emphasis>
would match one of
<option>-a -b</option>
or
<option>-c</option>
in the argument list.
<option>-c</option>
would cause the corresponding variable to be set to 1,
<option>-b</option>
to 2, and
<option>-a</option>
to 4.  (Actually, these bits would be ored in, but assuming an initial value
of 0, this is true).</para>
  </listitem>
  </varlistentry>
</variablelist>

  <blockquote remap='RS'>
<para>The
<emphasis remap='B'>-</emphasis>
may be followed immediately by more label_key_conversion specifications.
These should not be separated by blanks and should not contain any
<emphasis remap='B'>-</emphasis>
specifications.  They will be processed only if the flag argument is scanned.
This allows optional specification of parameters corresponding to a flag
(e.g.
<option>-f file</option>
).  Corresponding arguments on the command line must appear between the flag
which introduces them and the next flag in the command line.
  </para></blockquote> <!-- remap='RE' -->
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>$</emphasis></term>
  <listitem>
<para>This may appear only as the last specifier in the format string, and is used
to "eat up" the rest of the command arguments.  The corresponding function
argument is an
<emphasis remap='I'>int</emphasis>
pointer.  An index into
<emphasis remap='I'>argv</emphasis>
to the dividing point between the arguments which have been used, and those
which have not is returned.  This index points to the first unused command
argument.  If there is no such dividing point, an error
will be generated (but <emphasis remap='B'>$</emphasis> may match zero arguments, as long as
the entire set of arguments has already been matched).</para>
  </listitem>
  </varlistentry>
</variablelist>

<para>A string or numeric conversion character may be preceded by a
`<emphasis remap='B'>*</emphasis>' or a `<emphasis remap='B'>,</emphasis>' to indicate that a list of such arguments is
expected.  If `<emphasis remap='B'>,</emphasis>' is used, then the AT&amp;T proposed argument
standard is followed, and a single string is expected, with the
individual list elements separated by commas or spaces.  Two commas in
a row will produce a null entry (0 if numeric, zero-length string if
string conversion), but multiple spaces, and spaces following a comma,
are taken as a single separator.  If
`<emphasis remap='B'>*</emphasis>'
is specified, then multiple arguments are parsed to produce the list.  A
format specifier with a
`<emphasis remap='B'>*</emphasis>'
or a
`<emphasis remap='B'>,</emphasis>'
takes two arguments.  The first is an
<emphasis remap='B'>int</emphasis>
pointer, the number of items in the list is returned here.  The second is a
pointer to pointer to the correct data type for the format specifier.  A
pointer to the list of arguments is returned here.</para>

<para>The scanner will process the control string from left to right,
and where there are multiple conversions of the same type, they will
be assigned one to one with their order of occurrence in the argument list.
Where the order of the arguments is not ambiguous in the control string,
they may occur in any order in the argument list. (ie. A decimal number
will not be confused with a flag, but may
be confused with an octal number or another decimal number. So if an
octal and a decimal number are to be arguments, their order will determine
their conversion, while a decimal number and a flag as arguments may occur
in any order and still be converted correctly.)</para>

<para>An argument list that does not match the requirements of the control
string will cause the printing of a short message telling why, and
a message telling what the correct usage is.
This usage is gleaned from the control string, and the labels are used
directly.  The labels should be both terse and descriptive!  Spaces, tabs,
and newlines in the format string will be reproduced in the usage message,
and can be used for effective prettyprinting.  A single tab (following a
newline) will indent the line directly under the command name in the usage
message.</para>

<para>The
<function>scanargs</function>
function returns 1 when the argument list matched the requirements
of the control string, and returns 0 if there was a failure.
Parameters for any conversions not matched are left untouched.
<!-- .br -->
For example, the call</para>
  <blockquote remap='RS'>

<para>int i; double x; char *name;
<!-- .br -->
scanargs(argc, argv, "% decimal%d floating%F file%s",
<!-- .in 15 -->
&amp;i, &amp;x, &amp;name );
  </para></blockquote> <!-- remap='RE' -->

<para>in a C program executed by the shell command</para>
  <blockquote remap='RS'>

<para><emphasis remap='I'>%</emphasis>
program 10 3.5397 inputfile
  </para></blockquote> <!-- remap='RE' -->

<para>will assign to
<emphasis remap='I'>i</emphasis>
the value 10,
<emphasis remap='I'>x</emphasis>
the value 3.5397, and
<emphasis remap='I'>name</emphasis>
will point to the string "inputfile".</para>

<para>If the program was executed by the shell command</para>
  <blockquote remap='RS'>

<para><emphasis remap='I'>%</emphasis>
program  3.4 .7 inputfile
  </para></blockquote> <!-- remap='RE' -->

<para>the following would be printed on the standard error:</para>
  <blockquote remap='RS'>

<para>extra arguments not processed
<!-- .br -->
usage : program [decimal] [floating] [file]
  </para></blockquote> <!-- remap='RE' -->

<para>because 3.4 matches the type of 'floating' and .7 matches
the type of 'file', leaving inputfile unmatched.</para>

<para>Finally, executing the command</para>
  <blockquote remap='RS'>
<!-- .br -->
<para><emphasis remap='I'>%</emphasis>
program 10
  </para></blockquote> <!-- remap='RE'
.br -->
<para>would assign 10 to
<emphasis remap='I'>i</emphasis>,
leaving
<emphasis remap='I'>x</emphasis>
and
<emphasis remap='I'>name</emphasis>
unaffected.</para>

<para>This call could be used for the
<citerefentry><refentrytitle>diff</refentrytitle><manvolnum>1</manvolnum></citerefentry>
command</para>
  <blockquote remap='RS'>

<para>int blanks; int flags; char *file1; char *file2;
<!-- .br -->
scanargs(argc, argv, "diff b%- efh%- file1!s file2!s",
<!-- .in 15 -->
&amp;blanks, &amp;flags, &amp;file1, &amp;file2 );
  </para></blockquote> <!-- remap='RE' -->

<para>and would only allow one of either
<option>-e</option>, <option>-f</option>,
or
<option>-h</option>
to be chosen optionally, with
<option>-b</option>
as an independent option.
<emphasis remap='B'>File1</emphasis>
and
<emphasis remap='B'>file2</emphasis>
are both required.
The usage message for this version of
<emphasis remap='I'>diff</emphasis>
would be</para>
  <blockquote remap='RS'>

<para>usage : diff [-b] -{efh} file1 file2
  </para></blockquote> <!-- remap='RE' -->

<para>This call could be used for a simplified version of the
<citerefentry><refentrytitle>sed</refentrytitle><manvolnum>1</manvolnum></citerefentry>
command</para>
  <blockquote remap='RS'>

<para>int efile; int noprint; char *script;
<!-- .br -->
char *file1; char *file2;
<!-- .br -->
scanargs(argc, argv,
<!-- .in 15 -->
"sed n%- f%-editfile!s script%s file%s",
<!-- .in 15 -->
&amp;noprint, &amp;efile, &amp;file1, &amp;script, &amp;file2 );
  </para></blockquote> <!-- remap='RE' -->

<para>If the
<option>-f</option>
option is specified, then a file name must be given as the next string
argument.
The usage message for this version of
<emphasis remap='I'>sed</emphasis>
would be</para>
  <blockquote remap='RS'>

<para>usage : sed [-n] [-f editfile] [script] file
  </para></blockquote> <!-- remap='RE' -->


<para>Further notes on putting together a format string:</para>

<para>It is possible for conditional arguments to be confused with
arguments which stand alone.  For this reason, it is recommended that
all flags (and associated conditional arguments) be specified first in
the scanargs format string.  This ordering is not necessary for the
command line arguments, however.  The only case which could still cause
confusion if these rules are followed is illustrated below:</para>
<!-- .br -->
  <blockquote remap='RS'>
<para>format string:	"prog d%-num%d othernum%d"
<!-- .br -->
command line:	prog -d 9
  </para></blockquote> <!-- remap='RE'
.br -->
<para>It is unclear whether the number 9 should be associated with the
<emphasis remap='I'>num</emphasis>
parameter or the
<emphasis remap='I'>othernum</emphasis>
parameter.
<emphasis remap='I'>Scanargs</emphasis>
assigns it to the
<emphasis remap='I'>num</emphasis>
parameter.  To force it to be associated with
<emphasis remap='I'>othernum</emphasis>
the
command could be invoked as either</para>
<!-- .br -->
  <blockquote remap='RS'>
<para>		prog 9 -d
<!-- .br -->
or		prog -d -- 9
  </para></blockquote> <!-- remap='RE'
.br -->
<para>The
<option>--</option>
in the second example is interpreted as a flag, thereby
terminating the scan for arguments introduced by the
<option>-d</option>.
According to the proposed standard, an argument of
<option>--</option>
is to be interpreted as terminating the optional arguments on a flag.</para>

<para>Note that if the format string in the above example were</para>
<!-- .br -->
<literallayout remap='RS'>
		"prog othernum%d d%-num%d"
</literallayout> <!-- remap='RE'
.br -->
<para>it would be impossible to assign a value to
<emphasis remap='I'>num</emphasis>
without also
assigning a value to
<emphasis remap='I'>othernum.</emphasis>
A command line of</para>
<literallayout remap='RS'>
	prog -d 9
</literallayout> <!-- remap='RE' -->
<para>would match <emphasis remap='I'>othernum</emphasis> with 9, leaving nothing to match <emphasis remap='I'>num</emphasis>.</para>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para><citerefentry><refentrytitle>exec</refentrytitle><manvolnum>2</manvolnum></citerefentry>, <citerefentry><refentrytitle>scanf</refentrytitle><manvolnum>3S</manvolnum></citerefentry></para>
</refsect1>

<refsect1 xml:id='diagnostics'><title>DIAGNOSTICS</title>
<para>Returns 0 on error, 1 on success.</para>
</refsect1>

<refsect1 xml:id='author'><title>AUTHOR</title>
<para>Gary Newman - Ampex Corporation
<!-- .br -->
Spencer W. Thomas - University of Utah</para>
</refsect1>

<refsect1 xml:id='bugs'><title>BUGS</title>
<para>By its nature a call to scanargs defines a syntax
which may be ambiguous, and although the results may be surprising,
they are quite predictable.</para>
</refsect1>
</refentry>

