<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='filesystem3'>

<!-- '\" Copyright (c) 2001 Vincent Darley -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>8.4</date></refentryinfo>
<refmeta>
<refentrytitle>Filesystem</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>8.4</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_FSRegister</refname>
<refname>Tcl_FSUnregister</refname>
<refname>Tcl_FSData</refname>
<refname>Tcl_FSMountsChanged</refname>
<refname>Tcl_FSGetFileSystemForPath</refname>
<refname>Tcl_FSGetPathType</refname>
<refname>Tcl_FSCopyFile</refname>
<refname>Tcl_FSCopyDirectory</refname>
<refname>Tcl_FSCreateDirectory</refname>
<refname>Tcl_FSDeleteFile</refname>
<refname>Tcl_FSRemoveDirectory</refname>
<refname>Tcl_FSRenameFile</refname>
<refname>Tcl_FSListVolumes</refname>
<refname>Tcl_FSEvalFile</refname>
<refname>Tcl_FSEvalFileEx</refname>
<refname>Tcl_FSLoadFile</refname>
<refname>Tcl_FSMatchInDirectory</refname>
<refname>Tcl_FSLink</refname>
<refname>Tcl_FSLstat</refname>
<refname>Tcl_FSUtime</refname>
<refname>Tcl_FSFileAttrsGet</refname>
<refname>Tcl_FSFileAttrsSet</refname>
<refname>Tcl_FSFileAttrStrings</refname>
<refname>Tcl_FSStat</refname>
<refname>Tcl_FSAccess</refname>
<refname>Tcl_FSOpenFileChannel</refname>
<refname>Tcl_FSGetCwd</refname>
<refname>Tcl_FSChdir</refname>
<refname>Tcl_FSPathSeparator</refname>
<refname>Tcl_FSJoinPath</refname>
<refname>Tcl_FSSplitPath</refname>
<refname>Tcl_FSEqualPaths</refname>
<refname>Tcl_FSGetNormalizedPath</refname>
<refname>Tcl_FSJoinToPath</refname>
<refname>Tcl_FSConvertToPathType</refname>
<refname>Tcl_FSGetInternalRep</refname>
<refname>Tcl_FSGetTranslatedPath</refname>
<refname>Tcl_FSGetTranslatedStringPath</refname>
<refname>Tcl_FSNewNativePath</refname>
<refname>Tcl_FSGetNativePath</refname>
<refname>Tcl_FSFileSystemInfo</refname>
<refname>Tcl_AllocStatBuf</refname>
<refpurpose>procedures to interact with any filesystem</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>Tcl_FSRegister</function></funcdef>
<paramdef><parameter>clientData</parameter></paramdef>
<paramdef><parameter>fsPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSUnregister</function></funcdef>
<paramdef><parameter>fsPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>ClientData <function>Tcl_FSData</function></funcdef>
<paramdef><parameter>fsPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>void <function>Tcl_FSMountsChanged</function></funcdef>
<paramdef><parameter>fsPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Filesystem</function> *Tcl_FSGetFileSystemForPath</funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_PathType <function>Tcl_FSGetPathType</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSCopyFile</function></funcdef>
<paramdef><parameter>srcPathPtr</parameter></paramdef>
<paramdef><parameter>destPathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSCopyDirectory</function></funcdef>
<paramdef><parameter>srcPathPtr</parameter></paramdef>
<paramdef><parameter>destPathPtr</parameter></paramdef>
<paramdef><parameter>errorPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSCreateDirectory</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSDeleteFile</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSRemoveDirectory</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>int recursive</parameter></paramdef>
<paramdef><parameter>errorPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSRenameFile</function></funcdef>
<paramdef><parameter>srcPathPtr</parameter></paramdef>
<paramdef><parameter>destPathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSListVolumes</funcdef>
    <paramdef><parameter>void</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSEvalFileEx</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>encodingName</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSEvalFile</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSLoadFile</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>sym1</parameter></paramdef>
<paramdef><parameter>sym2</parameter></paramdef>
<paramdef><parameter>proc1Ptr</parameter></paramdef>
<paramdef><parameter>proc2Ptr</parameter></paramdef>
<paramdef><parameter>
 handlePtr</parameter></paramdef>
<paramdef><parameter>unloadProcPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSMatchInDirectory</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>resultPtr</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>pattern</parameter></paramdef>
<paramdef><parameter>types</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSLink</funcdef>
<paramdef><parameter>linkNamePtr</parameter></paramdef>
<paramdef><parameter>toPtr</parameter></paramdef>
<paramdef><parameter>linkAction</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSLstat</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>statPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSUtime</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>tval</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSFileAttrsGet</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>int index</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>objPtrRef</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSFileAttrsSet</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>int index</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>Tcl_Obj *objPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>const char **<function>Tcl_FSFileAttrStrings</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>objPtrRef</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSStat</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>statPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSAccess</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>mode</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_Channel <function>Tcl_FSOpenFileChannel</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>modeString</parameter></paramdef>
<paramdef><parameter>permissions</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSGetCwd</funcdef>
<paramdef><parameter>interp</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSChdir</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSPathSeparator</funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSJoinPath</funcdef>
<paramdef><parameter>listObj</parameter></paramdef>
<paramdef><parameter>elements</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSSplitPath</funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>lenPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSEqualPaths</function></funcdef>
<paramdef><parameter>firstPtr</parameter></paramdef>
<paramdef><parameter>secondPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSGetNormalizedPath</funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSJoinToPath</funcdef>
<paramdef><parameter>basePtr</parameter></paramdef>
<paramdef><parameter>objc</parameter></paramdef>
<paramdef><parameter>objv</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_FSConvertToPathType</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>ClientData <function>Tcl_FSGetInternalRep</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
<paramdef><parameter>fsPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSGetTranslatedPath</funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>const char *<function>Tcl_FSGetTranslatedStringPath</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSNewNativePath</funcdef>
<paramdef><parameter>fsPtr</parameter></paramdef>
<paramdef><parameter>clientData</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>const char *<function>Tcl_FSGetNativePath</function></funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_FSFileSystemInfo</funcdef>
<paramdef><parameter>pathPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_StatBuf</function> *Tcl_AllocStatBuf</funcdef>
<void/></funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tcl_FSUnloadFileProc **unloadProcPtr out -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Filesystem"</entry><entry>"*fsPtr"</entry><entry>"in"</entry>
<entry>
<para>Points to a structure containing the addresses of procedures that
can be called to perform the various filesystem operations.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*pathPtr</entry><entry>in</entry>
<entry>
<para>The path represented by this object is used for the operation in
question.  If the object does not already have an internal <emphasis remap='B'>path</emphasis>
representation, it will be converted to have one.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*srcPathPtr</entry><entry>in</entry>
<entry>
<para>As for <varname role='parameter'>pathPtr</varname>, but used for the source file for a copy or
rename operation.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*destPathPtr</entry><entry>in</entry>
<entry>
<para>As for <varname role='parameter'>pathPtr</varname>, but used for the destination filename for a copy or
rename operation.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*encodingName</entry><entry>in</entry>
<entry>
<para>The encoding of the data stored in the
file identified by <varname role='parameter'>pathPtr</varname> and to be evaluated.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*pattern</entry><entry>in</entry>
<entry>
<para>Only files or directories matching this pattern will be returned.</para>
</entry>
</row>
<row><entry>Tcl_GlobTypeData</entry><entry>*types</entry><entry>in</entry>
<entry>
<para>Only files or directories matching the type descriptions contained in
this structure will be returned.  This parameter may be NULL.</para>
</entry>
</row>
<row><entry>Tcl_Interp</entry><entry>*interp</entry><entry>in</entry>
<entry>
<para>Interpreter to use either for results, evaluation, or reporting error
messages.</para>
</entry>
</row>
<row><entry>ClientData</entry><entry>clientData</entry><entry>in</entry>
<entry>
<para>The native description of the path object to create.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*firstPtr</entry><entry>in</entry>
<entry>
<para>The first of two path objects to compare.  The object may be converted
to <emphasis remap='B'>path</emphasis> type.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*secondPtr</entry><entry>in</entry>
<entry>
<para>The second of two path objects to compare.  The object may be converted
to <emphasis remap='B'>path</emphasis> type.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*listObj</entry><entry>in</entry>
<entry>
<para>The list of path elements to operate on with a <emphasis remap='B'>join</emphasis> operation.</para>
</entry>
</row>
<row><entry>int</entry><entry>elements</entry><entry>in</entry>
<entry>
<para>If non-negative, the number of elements in the <emphasis remap='I'>listObj</emphasis> which should
be joined together.  If negative, then all elements are joined.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>**errorPtr</entry><entry>out</entry>
<entry>
<para>In the case of an error, filled with an object containing the name of
the file which caused an error in the various copy/rename operations.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>**objPtrRef</entry><entry>out</entry>
<entry>
<para>Filled with an object containing the result of the operation.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*resultPtr</entry><entry>out</entry>
<entry>
<para>Pre-allocated object in which to store (using
<emphasis remap='B'>Tcl_ListObjAppendElement</emphasis>) the list of
files or directories which are successfully matched.</para>
</entry>
</row>
<row><entry>int</entry><entry>mode</entry><entry>in</entry>
<entry>
<para>Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK.  R_OK,
W_OK and X_OK request checking whether the file exists and  has  read,
write and  execute  permissions, respectively.  F_OK just requests
checking for the existence of the file.</para>
</entry>
</row>
<row><entry>Tcl_StatBuf</entry><entry>*statPtr</entry><entry>out</entry>
<entry>
<para>The structure that contains the result of a stat or lstat operation.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*sym1</entry><entry>in</entry>
<entry>
<para>Name of a procedure to look up in the file's symbol table</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*sym2</entry><entry>in</entry>
<entry>
<para>Name of a procedure to look up in the file's symbol table</para>
</entry>
</row>
<row><entry>Tcl_PackageInitProc</entry><entry>**proc1Ptr</entry><entry>out</entry>
<entry>
<para>Filled with the init function for this code.</para>
</entry>
</row>
<row><entry>Tcl_PackageInitProc</entry><entry>**proc2Ptr</entry><entry>out</entry>
<entry>
<para>Filled with the safe-init function for this code.</para>
</entry>
</row>
<row><entry>ClientData</entry><entry>*clientDataPtr</entry><entry>out</entry>
<entry>
<para>Filled with the clientData value to pass to this code's unload
function when it is called.</para>
</entry>
</row>
<row><entry>Tcl_LoadHandle</entry><entry>*handlePtr</entry><entry>out</entry>
<entry>
<para>Filled with an abstract token representing the loaded file.</para>
</entry>
</row>
<row><entry>Tcl_FSUnloadFileProc</entry><entry>**unloadProcPtr</entry><entry>out</entry>
<entry>
<para>Filled with the function to use to unload this piece of code.</para>
</entry>
</row>
<row><entry>utimbuf</entry><entry>*tval</entry><entry>in</entry>
<entry>
<para>The access and modification times in this structure are read and
used to set those values for a given file.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*modeString</entry><entry>in</entry>
<entry>
<para>Specifies how the file is to be accessed.  May have any of the values
allowed for the <varname role='parameter'>mode</varname> argument to the Tcl <emphasis remap='B'>open</emphasis> command.</para>
</entry>
</row>
<row><entry>int</entry><entry>permissions</entry><entry>in</entry>
<entry>
<para>POSIX-style permission flags such as 0644.  If a new file is created, these
permissions will be set on the created file.</para>
</entry>
</row>
<row><entry>int</entry><entry>*lenPtr</entry><entry>out</entry>
<entry>
<para>If non-NULL, filled with the number of elements in the split path.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*basePtr</entry><entry>in</entry>
<entry>
<para>The base path on to which to join the given elements.  May be NULL.</para>
</entry>
</row>
<row><entry>int</entry><entry>objc</entry><entry>in</entry>
<entry>
<para>The number of elements in <emphasis remap='I'>objv</emphasis>.</para>
</entry>
</row>
<row><entry>"Tcl_Obj *const"</entry><entry>objv[]</entry><entry>in</entry>
<entry>
<para>The elements to join to the given base path.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*linkNamePtr</entry><entry>in</entry>
<entry>
<para>The name of the link to be created or read.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*toPtr</entry><entry>in</entry>
<entry>
<para>What the link called <varname role='parameter'>linkNamePtr</varname> should be linked to, or NULL if
the symbolic link specified by <varname role='parameter'>linkNamePtr</varname> is to be read.</para>
</entry>
</row>
<row><entry>int</entry><entry>linkAction</entry><entry>in</entry>
<entry>
<para>OR-ed combination of flags indicating what kind of link should be
created (will be ignored if <varname role='parameter'>toPtr</varname> is NULL). Valid bits to set
are <emphasis remap='B'>TCL_CREATE_SYMBOLIC_LINK</emphasis> and <emphasis remap='B'>TCL_CREATE_HARD_LINK</emphasis>.
When both flags are set and the underlying filesystem can do either,
symbolic links are preferred.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para>There are several reasons for calling the <emphasis remap='B'>Tcl_FS</emphasis> API functions
(e.g. <function>Tcl_FSAccess</function> and <function>Tcl_FSStat</function>)
rather than calling system level functions like <emphasis remap='B'>access</emphasis> and
<emphasis remap='B'>stat</emphasis> directly.  First, they will work cross-platform, so an
extension which calls them should work unmodified on Unix and
Windows.  Second, the Windows implementation of some of these functions
fixes some bugs in the system level calls.  Third, these function calls
deal with any
<quote>Utf to platform-native</quote>
path conversions which may be
required (and may cache the results of such conversions for greater
efficiency on subsequent calls).  Fourth, and perhaps most importantly,
all of these functions are
<quote>virtual filesystem aware</quote>.
Any virtual filesystem (VFS for short) which has been registered (through
<function>Tcl_FSRegister</function>) may reroute file access to alternative
media or access methods.  This means that all of these functions (and
therefore the corresponding <varname role='parameter'>file</varname>, <emphasis remap='B'>glob</emphasis>, <emphasis remap='B'>pwd</emphasis>, <emphasis remap='B'>cd</emphasis>,
<emphasis remap='B'>open</emphasis>, etc.  Tcl commands) may be operate on
<quote>files</quote>
which are not
native files in the native filesystem.  This also means that any Tcl
extension which accesses the filesystem (FS for short) through this API is
automatically
<quote>virtual filesystem aware</quote>.
Of course, if an extension
accesses the native filesystem directly (through platform-specific
APIs, for example), then Tcl cannot intercept such calls.</para>

<para>If appropriate VFSes have been registered, the
<quote>files</quote>
may, to give two
examples, be remote (e.g. situated on a remote ftp server) or archived
(e.g. lying inside a .zip archive).  Such registered filesystems provide
a lookup table of functions to implement all or some of the functionality
listed here.  Finally, the <function>Tcl_FSStat</function> and <function>Tcl_FSLstat</function> calls
abstract away from what the
<quote>struct stat</quote>
buffer is actually
declared to be, allowing the same code to be used both on systems with
and systems without support for files larger than 2GB in size.</para>

<para>The <emphasis remap='B'>Tcl_FS</emphasis> API is objectified and may cache internal
representations and other path-related strings (e.g. the current working
directory).  One side-effect of this is that one must not pass in objects
with a reference count of zero to any of these functions.  If such calls were
handled, they might result
in memory leaks (under some circumstances, the filesystem code may wish
to retain a reference to the passed in object, and so one must not assume
that after any of these calls return, the object still has a reference count of
zero - it may have been incremented) or in a direct segmentation fault
(or other memory access error)
due to the object being freed part way through the complex object
manipulation required to ensure that the path is fully normalized and
absolute for filesystem determination.  The practical lesson to learn
from this is that</para>
<programlisting remap='CS'>
Tcl_Obj *path = Tcl_NewStringObj(...);
<funcsynopsis>
<funcprototype>
<funcdef><function>Tcl_FSWhatever</function></funcdef>
    <paramdef><parameter>path</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_DecrRefCount</function></funcdef>
    <paramdef><parameter>path</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>is wrong, and may cause memory errors. The <emphasis remap='I'>path</emphasis> must have its
reference count incremented before passing it in, or
decrementing it.  For this reason, objects with a reference count of zero are
considered not to be valid filesystem paths and calling any Tcl_FS API
function with such an object will result in no action being taken.</para>

<refsect2 xml:id='fs_api_functions'><title>FS API FUNCTIONS</title>
<para><function>Tcl_FSCopyFile</function> attempts to copy the file given by <varname role='parameter'>srcPathPtr</varname> to the
path name given by <varname role='parameter'>destPathPtr</varname>.  If the two paths given lie in the same
filesystem (according to <emphasis remap='B'>Tcl_FSGetFileSystemForPath</emphasis>) then that
filesystem's
<quote>copy file</quote>
function is called (if it is non-NULL).
Otherwise the function returns -1 and sets the <varname>errno</varname> global C
variable to the
<quote>EXDEV</quote>
POSIX error code (which signifies a
<quote>cross-domain link</quote>).</para>

<para><function>Tcl_FSCopyDirectory</function> attempts to copy the directory given by <varname role='parameter'>srcPathPtr</varname> to the
path name given by <varname role='parameter'>destPathPtr</varname>.  If the two paths given lie in the same
filesystem (according to <emphasis remap='B'>Tcl_FSGetFileSystemForPath</emphasis>) then that
filesystem's
<quote>copy file</quote>
function is called (if it is non-NULL).
Otherwise the function returns -1 and sets the <varname>errno</varname> global C
variable to the
<quote>EXDEV</quote>
POSIX error code (which signifies a
<quote>cross-domain link</quote>).</para>

<para><function>Tcl_FSCreateDirectory</function> attempts to create the directory given by
<varname role='parameter'>pathPtr</varname> by calling the owning filesystem's
<quote>create directory</quote>
function.</para>

<para><function>Tcl_FSDeleteFile</function> attempts to delete the file given by
<varname role='parameter'>pathPtr</varname> by calling the owning filesystem's
<quote>delete file</quote>
function.</para>

<para><function>Tcl_FSRemoveDirectory</function> attempts to remove the directory given by
<varname role='parameter'>pathPtr</varname> by calling the owning filesystem's
<quote>remove directory</quote>
function.</para>

<para><function>Tcl_FSRenameFile</function> attempts to rename the file or directory given by
<varname role='parameter'>srcPathPtr</varname> to the path name given by <varname role='parameter'>destPathPtr</varname>.  If the two paths
given lie in the same filesystem (according to
<emphasis remap='B'>Tcl_FSGetFileSystemForPath</emphasis>) then that filesystem's
<quote>rename file</quote>
function is called (if it is non-NULL).  Otherwise the function returns -1
and sets the <varname>errno</varname> global C variable to the
<quote>EXDEV</quote>
POSIX error code (which signifies a
<quote>cross-domain link</quote>).</para>

<para><emphasis remap='B'>Tcl_FSListVolumes</emphasis> calls each filesystem which has a non-NULL
<quote>list volumes</quote>
function and asks them to return their list of root volumes.  It
accumulates the return values in a list which is returned to the
caller (with a reference count of 0).</para>

<!-- .VS 8.5 -->
<para><function>Tcl_FSEvalFileEx</function> reads the file given by <varname role='parameter'>pathPtr</varname> using
the encoding identified by <emphasis remap='I'>encodingName</emphasis> and evaluates
its contents as a Tcl script.  It returns the same information as
<emphasis remap='B'>Tcl_EvalObjEx</emphasis>.
If <emphasis remap='I'>encodingName</emphasis> is NULL, the system encoding is used for
reading the file contents.
If the file could not be read then a Tcl error is returned to describe
why the file could not be read.
The eofchar for files is
<quote>\32</quote>
(^Z) for all platforms.
If you require a
<quote>^Z</quote>
in code for string comparison, you can use
<quote>\032</quote>
or
<quote>\u001a</quote>,
which will be safely substituted by the Tcl interpreter into
<quote>^Z</quote>.
<function>Tcl_FSEvalFile</function> is a simpler version of
<function>Tcl_FSEvalFileEx</function> that always uses the system encoding
when reading the file.</para>
<!-- .VE 8.5 -->

<para><function>Tcl_FSLoadFile</function> dynamically loads a binary code file into memory and
returns the addresses of two procedures within that file, if they are
defined.  The appropriate function for the filesystem to which <varname role='parameter'>pathPtr</varname>
belongs will be called.  If that filesystem does not implement this
function (most virtual filesystems will not, because of OS limitations
in dynamically loading binary code), Tcl will attempt to copy the file
to a temporary directory and load that temporary file.</para>

<para>Returns a standard Tcl completion code.  If an error occurs, an error
message is left in the <varname role='parameter'>interp</varname>'s result.</para>

<para><function>Tcl_FSMatchInDirectory</function> is used by the globbing code to search a
directory for all files which match a given pattern.  The appropriate
function for the filesystem to which <varname role='parameter'>pathPtr</varname> belongs will be called.</para>

<para>The return value is a standard Tcl result indicating whether an error
occurred in globbing.  Error messages are placed in interp (unless 
interp is NULL, which is allowed), but good results are placed in the 
resultPtr given.</para>

<para>Note that the <emphasis remap='B'>glob</emphasis> code implements recursive patterns internally, so
this function will only ever be passed simple patterns, which can be
matched using the logic of <emphasis remap='B'>string match</emphasis>.  To handle recursion, Tcl
will call this function frequently asking only for directories to be
returned.  A special case of being called with a NULL pattern indicates
that the path needs to be checked only for the correct type.</para>

<para><emphasis remap='B'>Tcl_FSLink</emphasis> replaces the library version of <emphasis remap='B'>readlink</emphasis>, and
extends it to support the creation of links.  The appropriate function
for the filesystem to which <varname role='parameter'>linkNamePtr</varname> belongs will be called.</para>

<para>If the <varname role='parameter'>toPtr</varname> is NULL, a
<quote>read link</quote>
action is performed.  The result
is a Tcl_Obj specifying the contents of the symbolic link given by
<varname role='parameter'>linkNamePtr</varname>, or NULL if the link could not be read.  The result is owned
by the caller, which should call Tcl_DecrRefCount when the result is no
longer needed.  If the <varname role='parameter'>toPtr</varname> is not NULL, Tcl should create a link
of one of the types passed in in the <varname role='parameter'>linkAction</varname> flag.  This flag is
an ORed combination of <emphasis remap='B'>TCL_CREATE_SYMBOLIC_LINK</emphasis> and <emphasis remap='B'>TCL_CREATE_HARD_LINK</emphasis>.
Where a choice exists (i.e. more than one flag is passed in), the Tcl
convention is to prefer symbolic links.  When a link is successfully
created, the return value should be <varname role='parameter'>toPtr</varname> (which is therefore
already owned by the caller).  If unsuccessful, NULL is returned.</para>

<para><function>Tcl_FSLstat</function> fills the stat structure <varname role='parameter'>statPtr</varname> with information
about the specified file.  You do not need any access rights to the
file to get this information but you need search rights to all
directories named in the path leading to the file.  The stat structure
includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), group id (always 0 on Windows), rdev (same as device on
Windows), size, last access time, last modification time, and creation
time.</para>

<para>If <emphasis remap='I'>path</emphasis> exists, <function>Tcl_FSLstat</function> returns 0 and the stat structure
is filled with data.  Otherwise, -1 is returned, and no stat info is
given.</para>

<para><function>Tcl_FSUtime</function> replaces the library version of utime.</para>

<para>This returns 0 on success and -1 on error (as per the <emphasis remap='B'>utime</emphasis>
documentation).  If successful, the function
will update the
<quote>atime</quote>
and
<quote>mtime</quote>
values of the file given.</para>

<para><function>Tcl_FSFileAttrsGet</function> implements read access for the hookable <emphasis remap='B'>file
attributes</emphasis> subcommand.  The appropriate function for the filesystem to
which <varname role='parameter'>pathPtr</varname> belongs will be called.</para>

<para>If the result is <emphasis remap='B'>TCL_OK</emphasis>, then an object was placed in
<varname role='parameter'>objPtrRef</varname>, which
will only be temporarily valid (unless <emphasis remap='B'>Tcl_IncrRefCount</emphasis> is called).</para>

<para><function>Tcl_FSFileAttrsSet</function> implements write access for the hookable <emphasis remap='B'>file
attributes</emphasis> subcommand.  The appropriate function for the filesystem to
which <varname role='parameter'>pathPtr</varname> belongs will be called.</para>

<para><function>Tcl_FSFileAttrStrings</function> implements part of the hookable <emphasis remap='B'>file
attributes</emphasis> subcommand.  The appropriate function for the filesystem
to which <varname role='parameter'>pathPtr</varname> belongs will be called.</para>

<para>The called procedure may either return an array of strings, or may
instead return NULL and place a Tcl list into the given <varname role='parameter'>objPtrRef</varname>.  Tcl
will take that list and first increment its reference count before using it.
On completion of that use, Tcl will decrement its reference count.  Hence if
the list should be disposed of by Tcl when done, it should have a
reference count of zero, and if the list should not be disposed of, the
filesystem should ensure it retains a reference count to the object.</para>

<para><function>Tcl_FSAccess</function> checks whether the process would be allowed to read,
write or test for existence of the file (or other filesystem object)
whose name is <emphasis remap='I'>pathname</emphasis>.   If <emphasis remap='I'>pathname</emphasis> is a symbolic link on Unix,
then permissions of the file referred by this symbolic link are
tested.</para>

<para>On success (all requested permissions granted), zero is returned.  On
error (at least one bit in mode asked for a permission that is denied,
or some other error occurred), -1 is returned.</para>

<para><function>Tcl_FSStat</function> fills the stat structure <varname role='parameter'>statPtr</varname> with information
about the specified file.  You do not need any access rights to the
file to get this information but you need search rights to all
directories named in the path leading to the file.  The stat structure
includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), group id (always 0 on Windows), rdev (same as device on
Windows), size, last access time, last modification time, and creation
time.</para>

<para>If <emphasis remap='I'>path</emphasis> exists, <function>Tcl_FSStat</function> returns 0 and the stat structure
is filled with data.  Otherwise, -1 is returned, and no stat info is
given.</para>

<para><function>Tcl_FSOpenFileChannel</function> opens a file specified by <varname role='parameter'>pathPtr</varname> and
returns a channel handle that can be used to perform input and output on
the file. This API is modeled after the <emphasis remap='B'>fopen</emphasis> procedure of
the Unix standard I/O library.
The syntax and meaning of all arguments is similar to those
given in the Tcl <emphasis remap='B'>open</emphasis> command when opening a file.
If an error occurs while opening the channel, <function>Tcl_FSOpenFileChannel</function>
returns NULL and records a POSIX error code that can be
retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.
In addition, if <varname role='parameter'>interp</varname> is non-NULL, <function>Tcl_FSOpenFileChannel</function>
leaves an error message in <varname role='parameter'>interp</varname>'s result after any error.</para>

<para>The newly created channel is not registered in the supplied interpreter; to
register it, use <emphasis remap='B'>Tcl_RegisterChannel</emphasis>, described below.
If one of the standard channels, <emphasis remap='B'>stdin, stdout</emphasis> or <emphasis remap='B'>stderr</emphasis> was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.</para>

<para><emphasis remap='B'>Tcl_FSGetCwd</emphasis> replaces the library version of <emphasis remap='B'>getcwd</emphasis>.</para>

<para>It returns the Tcl library's current working directory.  This may be
different to the native platform's working directory, which happens when
the current working directory is not in the native filesystem.</para>

<para>The result is a pointer to a Tcl_Obj specifying the current directory,
or NULL if the current directory could not be determined.  If NULL is
returned, an error message is left in the <varname role='parameter'>interp</varname>'s result.</para>

<para>The result already has its reference count incremented for the caller.  When
it is no longer needed, that reference count should be decremented.  This is
needed for thread-safety purposes, to allow multiple threads to access
this and related functions, while ensuring the results are always
valid.</para>

<para><function>Tcl_FSChdir</function> replaces the library version of <emphasis remap='B'>chdir</emphasis>.  The path is
normalized and then passed to the filesystem which claims it.  If that
filesystem does not implement this function, Tcl will fallback to a
combination of <emphasis remap='B'>stat</emphasis> and <emphasis remap='B'>access</emphasis> to check whether the directory
exists and has appropriate permissions.</para>

<para>For results, see <emphasis remap='B'>chdir</emphasis> documentation.  If successful, we keep a
record of the successful path in <emphasis remap='I'>cwdPathPtr</emphasis> for subsequent calls to
<emphasis remap='B'>Tcl_FSGetCwd</emphasis>.</para>

<para><emphasis remap='B'>Tcl_FSPathSeparator</emphasis> returns the separator character to be used for
most specific element of the path specified by <varname role='parameter'>pathPtr</varname> (i.e. the last
part of the path).</para>

<para>The separator is returned as a Tcl_Obj containing a string of length
1.  If the path is invalid, NULL is returned.</para>

<para><emphasis remap='B'>Tcl_FSJoinPath</emphasis> takes the given Tcl_Obj, which must be a valid
list (which is allowed to have a reference count of zero), and returns the path
object given by considering the first <emphasis remap='I'>elements</emphasis> elements as valid path
segments (each path segment may be a complete path, a partial path or
just a single possible directory or file name).  If any path segment is
actually an absolute path, then all prior path segments are discarded.
If <emphasis remap='I'>elements</emphasis> is less than 0, we use the entire list.</para>

<para>It is possible that the returned object is actually an element
of the given list, so the caller should be careful to increment the
reference count of the result before freeing the list.</para>

<para>The returned object, typically with a reference count of zero (but it
could be shared
under some conditions), contains the joined path.  The caller must
add a reference count to the object before using it.  In particular, the
returned object could be an element of the given list, so freeing the
list might free the object prematurely if no reference count has been taken.
If the number of elements is zero, then the returned object will be
an empty-string Tcl_Obj.</para>

<para><emphasis remap='B'>Tcl_FSSplitPath</emphasis> takes the given Tcl_Obj, which should be a valid path,
and returns a Tcl list object containing each segment of that path as
an element.
It returns a list object with a reference count of zero.  If the
passed in <emphasis remap='I'>lenPtr</emphasis> is non-NULL, the variable it points to will be
updated to contain the number of elements in the returned list.</para>

<para><function>Tcl_FSEqualPaths</function> tests whether the two paths given represent the same
filesystem object</para>

<para>It returns 1 if the paths are equal, and 0 if they are different.  If
either path is NULL, 0 is always returned.</para>

<para><emphasis remap='B'>Tcl_FSGetNormalizedPath</emphasis> this important function attempts to extract
from the given Tcl_Obj a unique normalized path representation, whose
string value can be used as a unique identifier for the file.</para>

<para>It returns the normalized path object, owned by Tcl, or NULL if the path
was invalid or could otherwise not be successfully converted.
Extraction of absolute, normalized paths is very efficient (because the
filesystem operates on these representations internally), although the
result when the filesystem contains numerous symbolic links may not be
the most user-friendly version of a path.  The return value is owned by
Tcl and has a lifetime equivalent to that of the <varname role='parameter'>pathPtr</varname> passed in
(unless that is a relative path, in which case the normalized path
object may be freed any time the cwd changes) - the caller can of
course increment the refCount if it wishes to maintain a copy for longer.</para>

<para><emphasis remap='B'>Tcl_FSJoinToPath</emphasis> takes the given object, which should usually be a
valid path or NULL, and joins onto it the array of paths segments
given.</para>

<para>Returns object, typically with refCount of zero (but it could be shared
under some conditions), containing the joined path.  The caller must
add a refCount to the object before using it.  If any of the objects
passed into this function (pathPtr or path elements) have a refCount
of zero, they will be freed when this function returns.</para>

<para><function>Tcl_FSConvertToPathType</function> tries to convert the given Tcl_Obj to a valid
Tcl path type, taking account of the fact that the cwd may have changed
even if this object is already supposedly of the correct type.
The filename may begin with
<quote>~</quote>
(to indicate current user's home directory) or
<quote>~&lt;user&gt;</quote>
(to indicate any user's home directory).</para>

<para>If the conversion succeeds (i.e. the object is a valid path in one of
the current filesystems), then <emphasis remap='B'>TCL_OK</emphasis> is returned.  Otherwise
<emphasis remap='B'>TCL_ERROR</emphasis> is returned, and an error message may
be left in the interpreter.</para>

<para><function>Tcl_FSGetInternalRep</function> extracts the internal representation of a given
path object, in the given filesystem.  If the path object belongs to a
different filesystem, we return NULL. If the internal representation is
currently NULL, we attempt to generate it, by calling the filesystem's
<function>Tcl_FSCreateInternalRepProc</function>.</para>

<para>Returns NULL or a valid internal path representation.  This internal
representation is cached, so that repeated calls to this function will
not require additional conversions.</para>

<para><emphasis remap='B'>Tcl_FSGetTranslatedPath</emphasis> attempts to extract the translated path
from the given Tcl_Obj.</para>

<para>If the translation succeeds (i.e. the object is a valid path), then it is
returned.  Otherwise NULL will be returned, and an error message may be
left in the interpreter.  A
<quote>translated</quote>
path is one which contains no
<quote>~</quote>
or
<quote>~user</quote>
sequences (these have been expanded to their current
representation in the filesystem).  The object returned is owned by the
caller, which must store it or call Tcl_DecrRefCount to ensure memory is
freed.  This function is of little practical use, and
<emphasis remap='B'>Tcl_FSGetNormalizedPath</emphasis> or <emphasis remap='B'>Tcl_GetNativePath</emphasis> are usually
better functions to use for most purposes.</para>

<para><function>Tcl_FSGetTranslatedStringPath</function> does the same as
<emphasis remap='B'>Tcl_FSGetTranslatedPath</emphasis>, but returns a character string or NULL.
The string returned is dynamically allocated and owned by the caller,
which must store it or call <emphasis remap='B'>ckfree</emphasis> to ensure it is freed.  Again,
<emphasis remap='B'>Tcl_FSGetNormalizedPath</emphasis> or <emphasis remap='B'>Tcl_GetNativePath</emphasis> are usually
better functions to use for most purposes.</para>

<para><emphasis remap='B'>Tcl_FSNewNativePath</emphasis> performs something like the reverse of the
usual obj-&gt;path-&gt;nativerep conversions.  If some code retrieves a path
in native form (from, e.g. <emphasis remap='B'>readlink</emphasis> or a native dialog), and that path
is to be used at the Tcl level, then calling this function is an
efficient way of creating the appropriate path object type.</para>

<para>The resulting object is a pure
<quote>path</quote>
object, which will only receive
a UTF-8 string representation if that is required by some Tcl code.</para>

<para><function>Tcl_FSGetNativePath</function> is for use by the Win/Unix native
filesystems, so that they can easily retrieve the native (char* or
TCHAR*) representation of a path.  This function is a convenience
wrapper around <function>Tcl_FSGetInternalRep</function>, and assumes the native
representation is string-based.  It may be desirable in the future to
have non-string-based native representations (for example, on MacOSX, a
representation using a fileSpec of FSRef structure would probably be
more efficient).  On Windows a full Unicode representation would allow
for paths of unlimited length.  Currently the representation is simply a
character string which may contain either the relative path or a
complete, absolute normalized path in the native encoding (complex
conditions dictate which of these will be provided, so neither can be
relied upon, unless the path is known to be absolute).  If you need a
native path which must be absolute, then you should ask for the native
version of a normalized path.  If for some reason a non-absolute,
non-normalized version of the path is needed, that must be constructed
separately (e.g. using <emphasis remap='B'>Tcl_FSGetTranslatedPath</emphasis>).</para>

<para>The native representation is cached so that repeated calls to this
function will not require additional conversions.  The return value is
owned by Tcl and has a lifetime equivalent to that of the <varname role='parameter'>pathPtr</varname>
passed in (unless that is a relative path, in which case the native
representation may be freed any time the cwd changes).</para>

<para><emphasis remap='B'>Tcl_FSFileSystemInfo</emphasis> returns a list of two elements.  The first
element is the name of the filesystem (e.g.
<quote>native</quote>,
<quote>vfs</quote>,
<quote>zip</quote>,
or
<quote>prowrap</quote>,
perhaps), and the second is the particular type of the
given path within that filesystem (which is filesystem dependent).  The
second element may be empty if the filesystem does not provide a
further categorization of files.</para>

<para>A valid list object is returned, unless the path object is not
recognized, when NULL will be returned.</para>

<para><emphasis remap='B'>Tcl_FSGetFileSystemForPath</emphasis> returns the a pointer to the
<function>Tcl_Filesystem</function> which accepts this path as valid.</para>

<para>If no filesystem will accept the path, NULL is returned.</para>

<para><function>Tcl_FSGetPathType</function> determines whether the given path is relative
to the current directory, relative to the current volume, or
absolute.</para>

<para>It returns one of <emphasis remap='B'>TCL_PATH_ABSOLUTE</emphasis>, <emphasis remap='B'>TCL_PATH_RELATIVE</emphasis>, or
<emphasis remap='B'>TCL_PATH_VOLUME_RELATIVE</emphasis></para>

<para><emphasis remap='B'>Tcl_AllocStatBuf</emphasis> allocates a <type>Tcl_StatBuf</type> on the system
heap (which may be deallocated by being passed to <emphasis remap='B'>ckfree</emphasis>.)  This
allows extensions to invoke <function>Tcl_FSStat</function> and <emphasis remap='B'>Tcl_FSLStat</emphasis>
without being dependent on the size of the buffer.  That in turn
depends on the flags used to build Tcl.</para>
</refsect2>
</refsect1>

<refsect1 xml:id='the_virtual_filesystem_api'><title>THE VIRTUAL FILESYSTEM API</title>
<para>A filesystem provides a <function>Tcl_Filesystem</function> structure that contains
pointers to functions that implement the various operations on a
filesystem; these operations are invoked as needed by the generic
layer, which generally occurs through the functions listed above.</para>

<para>The <function>Tcl_Filesystem</function> structures are manipulated using the following
methods.</para>

<para><function>Tcl_FSRegister</function> takes a pointer to a filesystem structure and an
optional piece of data to associated with that filesystem.  On calling
this function, Tcl will attach the filesystem to the list of known
filesystems, and it will become fully functional immediately.  Tcl does
not check if the same filesystem is registered multiple times (and in
general that is not a good thing to do).  <emphasis remap='B'>TCL_OK</emphasis> will be returned.</para>

<para><function>Tcl_FSUnregister</function> removes the given filesystem structure from
the list of known filesystems, if it is known, and returns <emphasis remap='B'>TCL_OK</emphasis>.  If
the filesystem is not currently registered, <emphasis remap='B'>TCL_ERROR</emphasis> is returned.</para>

<para><function>Tcl_FSData</function> will return the ClientData associated with the given
filesystem, if that filesystem is registered.  Otherwise it will
return NULL.</para>

<para><function>Tcl_FSMountsChanged</function> is used to inform the Tcl's core that
the set of mount points for the given (already registered) filesystem
have changed, and that cached file representations may therefore no
longer be correct.</para>

<refsect2 xml:id='the_tcl_filesystem_structure'><title>THE TCL_FILESYSTEM STRUCTURE</title>

<para>The <function>Tcl_Filesystem</function> structure contains the following fields:</para>
<programlisting remap='CS'>
typedef struct Tcl_Filesystem {
    const char *<emphasis remap='I'>typeName</emphasis>;
    int <emphasis remap='I'>structureLength</emphasis>;
    Tcl_FSVersion <emphasis remap='I'>version</emphasis>;
    Tcl_FSPathInFilesystemProc *<emphasis remap='I'>pathInFilesystemProc</emphasis>;
    Tcl_FSDupInternalRepProc *<emphasis remap='I'>dupInternalRepProc</emphasis>;
    Tcl_FSFreeInternalRepProc *<emphasis remap='I'>freeInternalRepProc</emphasis>;
    Tcl_FSInternalToNormalizedProc *<emphasis remap='I'>internalToNormalizedProc</emphasis>;
    Tcl_FSCreateInternalRepProc *<emphasis remap='I'>createInternalRepProc</emphasis>;
    Tcl_FSNormalizePathProc *<emphasis remap='I'>normalizePathProc</emphasis>;
    Tcl_FSFilesystemPathTypeProc *<emphasis remap='I'>filesystemPathTypeProc</emphasis>;
    Tcl_FSFilesystemSeparatorProc *<emphasis remap='I'>filesystemSeparatorProc</emphasis>;
    Tcl_FSStatProc *<emphasis remap='I'>statProc</emphasis>;
    Tcl_FSAccessProc *<emphasis remap='I'>accessProc</emphasis>;
    Tcl_FSOpenFileChannelProc *<emphasis remap='I'>openFileChannelProc</emphasis>;
    Tcl_FSMatchInDirectoryProc *<emphasis remap='I'>matchInDirectoryProc</emphasis>;
    Tcl_FSUtimeProc *<emphasis remap='I'>utimeProc</emphasis>;
    Tcl_FSLinkProc *<emphasis remap='I'>linkProc</emphasis>;
    Tcl_FSListVolumesProc *<emphasis remap='I'>listVolumesProc</emphasis>;
    Tcl_FSFileAttrStringsProc *<emphasis remap='I'>fileAttrStringsProc</emphasis>;
    Tcl_FSFileAttrsGetProc *<emphasis remap='I'>fileAttrsGetProc</emphasis>;
    Tcl_FSFileAttrsSetProc *<emphasis remap='I'>fileAttrsSetProc</emphasis>;
    Tcl_FSCreateDirectoryProc *<emphasis remap='I'>createDirectoryProc</emphasis>;
    Tcl_FSRemoveDirectoryProc *<emphasis remap='I'>removeDirectoryProc</emphasis>;
    Tcl_FSDeleteFileProc *<emphasis remap='I'>deleteFileProc</emphasis>;
    Tcl_FSCopyFileProc *<emphasis remap='I'>copyFileProc</emphasis>;
    Tcl_FSRenameFileProc *<emphasis remap='I'>renameFileProc</emphasis>;
    Tcl_FSCopyDirectoryProc *<emphasis remap='I'>copyDirectoryProc</emphasis>;
    Tcl_FSLstatProc *<emphasis remap='I'>lstatProc</emphasis>;
    Tcl_FSLoadFileProc *<emphasis remap='I'>loadFileProc</emphasis>;
    Tcl_FSGetCwdProc *<emphasis remap='I'>getCwdProc</emphasis>;
    Tcl_FSChdirProc *<emphasis remap='I'>chdirProc</emphasis>;
} Tcl_Filesystem;
</programlisting> <!-- remap='CE' -->

<para>Except for the first three fields in this structure which contain
simple data elements, all entries contain addresses of functions called
by the generic filesystem layer to perform the complete range of
filesystem related actions.</para>

<para>The many functions in this structure are broken down into three
categories: infrastructure functions (almost all of which must be
implemented), operational functions (which must be implemented if a
complete filesystem is provided), and efficiency functions (which need
only be implemented if they can be done so efficiently, or if they have
side-effects which are required by the filesystem; Tcl has less
efficient emulations it can fall back on).  It is important to note
that, in the current version of Tcl, most of these fallbacks are only
used to handle commands initiated in Tcl, not in C. What this means is,
that if a <emphasis remap='B'>file rename</emphasis> command is issued in Tcl, and the relevant
filesystem(s) do not implement their <function>Tcl_FSRenameFileProc</function>, Tcl's
core will instead fallback on a combination of other filesystem
functions (it will use <function>Tcl_FSCopyFileProc</function> followed by
<function>Tcl_FSDeleteFileProc</function>, and if <function>Tcl_FSCopyFileProc</function> is not
implemented there is a further fallback).  However, if a
<function>Tcl_FSRenameFileProc</function> command is issued at the C level, no such
fallbacks occur.  This is true except for the last four entries in the
filesystem table (<emphasis remap='B'>lstat</emphasis>, <emphasis remap='B'>load</emphasis>, <emphasis remap='B'>getcwd</emphasis> and <emphasis remap='B'>chdir</emphasis>)
for which fallbacks do in fact occur at the C level.</para>

<para>Any functions which take path names in Tcl_Obj form take
those names in UTF-8 form.  The filesystem infrastructure API is
designed to support efficient, cached conversion of these UTF-8 paths
to other native representations.</para>
</refsect2>

<refsect2 xml:id='example_filesystem_definition'><title>EXAMPLE FILESYSTEM DEFINITION</title>

<para>Here is the filesystem lookup table used by the
<quote>vfs</quote>
extension which allows filesystem actions to be implemented in Tcl.</para>
<programlisting remap='CS'>
static Tcl_Filesystem vfsFilesystem = {
    "tclvfs",
    sizeof(Tcl_Filesystem),
    TCL_FILESYSTEM_VERSION_1,
    &amp;VfsPathInFilesystem,
    &amp;VfsDupInternalRep,
    &amp;VfsFreeInternalRep,
    /* No internal to normalized, since we don't create
     * any pure 'internal' Tcl_Obj path representations */
    NULL,
    /* No create native rep function, since we don't use
     * it and don't choose to support uses of
     * Tcl_FSNewNativePath */
    NULL,
    /* Normalize path isn't needed - we assume paths only
     * have one representation */
    NULL,
    &amp;VfsFilesystemPathType,
    &amp;VfsFilesystemSeparator,
    &amp;VfsStat,
    &amp;VfsAccess,
    &amp;VfsOpenFileChannel,
    &amp;VfsMatchInDirectory,
    &amp;VfsUtime,
    /* We choose not to support symbolic links inside our
     * VFS's */
    NULL,
    &amp;VfsListVolumes,
    &amp;VfsFileAttrStrings,
    &amp;VfsFileAttrsGet,
    &amp;VfsFileAttrsSet,
    &amp;VfsCreateDirectory,
    &amp;VfsRemoveDirectory,
    &amp;VfsDeleteFile,
    /* No copy file; use the core fallback mechanism */
    NULL,
    /* No rename file; use the core fallback mechanism */
    NULL,
    /* No copy directory; use the core fallback mechanism */
    NULL,
    /* Core will use stat for lstat */
    NULL,
    /* No load; use the core fallback mechanism */
    NULL,
    /* We don't need a getcwd or chdir; the core's own
     * internal value is suitable */
    NULL,
    NULL
};
</programlisting> <!-- remap='CE' -->
<para>These fields contain basic information about the filesystem structure
and addresses of functions which are used to associate
a particular filesystem with a file path, and deal with the internal
handling of path representations, for example copying and freeing such
representations.</para>
</refsect2>

<refsect2 xml:id='typename'><title>TYPENAME</title>

<para>The <emphasis remap='I'>typeName</emphasis> field contains a null-terminated string that
identifies the type of the filesystem implemented, e.g.
<quote>native</quote>,
<quote>zip</quote>
or
<quote>vfs</quote>.</para>
</refsect2>

<refsect2 xml:id='structure_length'><title>STRUCTURE LENGTH</title>

<para>The <emphasis remap='I'>structureLength</emphasis> field is generally implemented as
<emphasis remap='I'>sizeof(Tcl_Filesystem)</emphasis>, and is there to allow easier
binary backwards compatibility if the size of the structure
changes in a future Tcl release.</para>
</refsect2>

<refsect2 xml:id='version'><title>VERSION</title>

<para>The <emphasis remap='I'>version</emphasis> field should be set to <emphasis remap='B'>TCL_FILESYSTEM_VERSION_1</emphasis>.</para>
</refsect2>

<refsect2 xml:id='pathinfilesystemproc'><title>PATHINFILESYSTEMPROC</title>

<para>The <emphasis remap='I'>pathInFilesystemProc</emphasis> field contains the address of a function
which is called to determine whether a given path object belongs to this
filesystem or not.  Tcl will only call the rest of the filesystem
functions with a path for which this function has returned <emphasis remap='B'>TCL_OK</emphasis>.
If the path does not belong, -1 should be returned (the behaviour of Tcl
for any other return value is not defined).  If <emphasis remap='B'>TCL_OK</emphasis> is returned,
then the optional <varname role='parameter'>clientDataPtr</varname> output parameter can be used to
return an internal (filesystem specific) representation of the path,
which will be cached inside the path object, and may be retrieved
efficiently by the other filesystem functions.  Tcl will simultaneously
cache the fact that this path belongs to this filesystem.  Such caches
are invalidated when filesystem structures are added or removed from
Tcl's internal list of known filesystems.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSPathInFilesystemProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>ClientData * <parameter>clientDataPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>This function makes a copy of a path's internal representation, and is
called when Tcl needs to duplicate a path object.  If NULL, Tcl will
simply not copy the internal representation, which may then need to be
regenerated later.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef ClientData <function>Tcl_FSDupInternalRepProc</function></funcdef>
    <paramdef>ClientData <parameter>clientData</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Free the internal representation.  This must be implemented if internal
representations need freeing (i.e. if some memory is allocated when an
internal representation is generated), but may otherwise be NULL.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef void <function>Tcl_FSFreeInternalRepProc</function></funcdef>
    <paramdef>ClientData <parameter>clientData</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Function to convert internal representation to a normalized path.  Only
required if the filesystem creates pure path objects with no string/path
representation.  The return value is a Tcl object whose string
representation is the normalized path.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef <function>Tcl_Obj</function> *Tcl_FSInternalToNormalizedProc</funcdef>
    <paramdef>ClientData <parameter>clientData</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Function to take a path object, and calculate an internal
representation for it, and store that native representation in the
object.  May be NULL if paths have no internal representation, or if
the <function>Tcl_FSPathInFilesystemProc</function> for this filesystem always
immediately creates an internal representation for paths it accepts.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef ClientData <function>Tcl_FSCreateInternalRepProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Function to normalize a path.  Should be implemented for all
filesystems which can have multiple string representations for the same
path object.  In Tcl, every
<quote>path</quote>
must have a single unique
<quote>normalized</quote>
string representation.  Depending on the filesystem,
there may be more than one unnormalized string representation which
refers to that path (e.g. a relative path, a path with different
character case if the filesystem is case insensitive, a path contain a
reference to a home directory such as
<quote>~</quote>,
a path containing symbolic
links, etc).  If the very last component in the path is a symbolic
link, it should not be converted into the object it points to (but
its case or other aspects should be made unique).  All other path
components should be converted from symbolic links.  This one
exception is required to agree with Tcl's semantics with <emphasis remap='B'>file
delete</emphasis>, <emphasis remap='B'>file rename</emphasis>, <emphasis remap='B'>file copy</emphasis> operating on symbolic links.
This function may be called with <varname role='parameter'>nextCheckpoint</varname> either
at the beginning of the path (i.e. zero), at the end of the path, or
at any intermediate file separator in the path.  It will never
point to any other arbitrary position in the path. In the last of
the three valid cases, the implementation can assume that the path
up to and including the file separator is known and normalized.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSNormalizePathProc</function></funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>int <parameter>nextCheckpoint</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The fields in this section of the structure contain addresses of
functions which are called to carry out the basic filesystem
operations.  A filesystem which expects to be used with the complete
standard Tcl command set must implement all of these.  If some of
them are not implemented, then certain Tcl commands may fail when
operating on paths within that filesystem.  However, in some instances
this may be desirable (for example, a read-only filesystem should not
implement the last four functions, and a filesystem which does not
support symbolic links need not implement the <emphasis remap='B'>readlink</emphasis> function,
etc.  The Tcl core expects filesystems to behave in this way).</para>
</refsect2>

<refsect2 xml:id='filesystempathtypeproc'><title>FILESYSTEMPATHTYPEPROC</title>

<para>Function to determine the type of a path in this filesystem.  May be
NULL, in which case no type information will be available to users of
the filesystem.  The
<quote>type</quote>
is used only for informational purposes,
and should be returned as the string representation of the Tcl_Obj
which is returned.  A typical return value might be
<quote>networked</quote>,
<quote>zip</quote>
or
<quote>ftp</quote>.
The Tcl_Obj result is owned by the filesystem and so Tcl will
increment the refCount of that object if it wishes to retain a reference
to it.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef <function>Tcl_Obj</function> *Tcl_FSFilesystemPathTypeProc</funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Function to return the separator character(s) for this filesystem.
This need only be implemented if the filesystem wishes to use a
different separator than the standard string
<quote>/</quote>.
Amongst other
uses, it is returned by the <emphasis remap='B'>file separator</emphasis> command.  The
return value should be an object with refCount of zero.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef <function>Tcl_Obj</function> *Tcl_FSFilesystemSeparatorProc</funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Function to process a <function>Tcl_FSStat</function> call.  Must be implemented for any
reasonable filesystem, since many Tcl level commands depend crucially
upon it (e.g. <emphasis remap='B'>file atime</emphasis>, <emphasis remap='B'>file isdirectory</emphasis>, <emphasis remap='B'>file size</emphasis>,
<emphasis remap='B'>glob</emphasis>).</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSStatProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>Tcl_StatBuf * <parameter>statPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The <function>Tcl_FSStatProc</function> fills the stat structure <varname role='parameter'>statPtr</varname> with
information about the specified file.  You do not need any access
rights to the file to get this information but you need search rights
to all directories named in the path leading to the file.  The stat
structure includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), group id (always 0 on Windows), rdev (same as device on
Windows), size, last access time, last modification time, and creation
time.</para>

<para>If the file represented by <varname role='parameter'>pathPtr</varname> exists, the
<function>Tcl_FSStatProc</function> returns 0 and the stat structure is filled with
data.  Otherwise, -1 is returned, and no stat info is given.</para>
</refsect2>

<refsect2 xml:id='accessproc'><title>ACCESSPROC</title>

<para>Function to process a <function>Tcl_FSAccess</function> call.  Must be implemented for
any reasonable filesystem, since many Tcl level commands depend crucially
upon it (e.g. <emphasis remap='B'>file exists</emphasis>, <emphasis remap='B'>file readable</emphasis>).</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSAccessProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>int <parameter>mode</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The <function>Tcl_FSAccessProc</function> checks whether the process would be allowed
to read, write or test for existence of the file (or other filesystem
object) whose name is in <varname role='parameter'>pathPtr</varname>.  If the pathname refers to a
symbolic link, then the
permissions of the file referred by this symbolic link should be tested.</para>

<para>On success (all requested permissions granted), zero is returned.  On
error (at least one bit in mode asked for a permission that is denied,
or some other  error occurred), -1 is returned.</para>
</refsect2>

<refsect2 xml:id='openfilechannelproc'><title>OPENFILECHANNELPROC</title>

<para>Function to process a <function>Tcl_FSOpenFileChannel</function> call.  Must be
implemented for any reasonable filesystem, since any operations
which require open or accessing a file's contents will use it
(e.g. <emphasis remap='B'>open</emphasis>, <emphasis remap='B'>encoding</emphasis>, and many Tk commands).</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef Tcl_Channel <function>Tcl_FSOpenFileChannelProc</function></funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>int <parameter>mode</parameter></paramdef>
    <paramdef>int <parameter>permissions</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The <function>Tcl_FSOpenFileChannelProc</function> opens a file specified by
<varname role='parameter'>pathPtr</varname> and returns a channel handle that can be used to perform
input and output on the file.  This API is modeled after the <emphasis remap='B'>fopen</emphasis>
procedure of the Unix standard I/O library.  The syntax and meaning of
all arguments is similar to those given in the Tcl <emphasis remap='B'>open</emphasis> command
when opening a file, where the <varname role='parameter'>mode</varname> argument is a combination of
the POSIX flags O_RDONLY, O_WRONLY, etc.  If an error occurs while
opening the channel, the <function>Tcl_FSOpenFileChannelProc</function> returns NULL and
records a POSIX error code that can be retrieved with <emphasis remap='B'>Tcl_GetErrno</emphasis>.
In addition, if <varname role='parameter'>interp</varname> is non-NULL, the
<function>Tcl_FSOpenFileChannelProc</function> leaves an error message in <varname role='parameter'>interp</varname>'s
result after any error.</para>

<para>The newly created channel is not registered in the supplied
interpreter; to register it, use <emphasis remap='B'>Tcl_RegisterChannel</emphasis>. If one of
the standard channels, <emphasis remap='B'>stdin, stdout</emphasis> or <emphasis remap='B'>stderr</emphasis> was
previously closed, the act of creating the new channel also assigns it
as a replacement for the standard channel.</para>
</refsect2>

<refsect2 xml:id='matchindirectoryproc'><title>MATCHINDIRECTORYPROC</title>

<para>Function to process a <function>Tcl_FSMatchInDirectory</function> call.  If not
implemented, then glob and recursive copy functionality will be lacking
in the filesystem (and this may impact commands like <emphasis remap='B'>encoding names</emphasis>
which use glob functionality internally).</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSMatchInDirectoryProc</function></funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>resultPtr</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>const char * <parameter>pattern</parameter></paramdef>
    <paramdef>Tcl_GlobTypeData * <parameter>types</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The function should return all files or directories (or other filesystem
objects) which match the given pattern and accord with the <varname role='parameter'>types</varname>
specification given.  There are two ways in which this function may be
called.  If <varname role='parameter'>pattern</varname> is NULL, then <varname role='parameter'>pathPtr</varname> is a full path
specification of a single file or directory which should be checked for
existence and correct type.  Otherwise, <varname role='parameter'>pathPtr</varname> is a directory, the
contents of which the function should search for files or directories
which have the correct type.  In either case, <varname role='parameter'>pathPtr</varname> can be
assumed to be both non-NULL and non-empty.  It is not currently
documented whether <varname role='parameter'>pathPtr</varname> will have a file separator at its end of
not, so code should be flexible to both possibilities.</para>

<para>The return value is a standard Tcl result indicating whether an error
occurred in the matching process.  Error messages are placed in
<varname role='parameter'>interp</varname>, unless <varname role='parameter'>interp</varname> in NULL in which case no error
message need be generated; on a <emphasis remap='B'>TCL_OK</emphasis> result, results should be 
added to the <varname role='parameter'>resultPtr</varname> object given (which can be assumed to be a 
valid unshared Tcl list).  The matches added
to <varname role='parameter'>resultPtr</varname> should include any path prefix given in <varname role='parameter'>pathPtr</varname>
(this usually means they will be absolute path specifications).
Note that if no matches are found, that simply leads to an empty
result; errors are only signaled for actual file or filesystem
problems which may occur during the matching process.</para>

<para>The <type>Tcl_GlobTypeData</type> structure passed in the <varname role='parameter'>types</varname> 
parameter contains the following fields:</para>
<programlisting remap='CS'>
typedef struct Tcl_GlobTypeData {
        /* Corresponds to bcdpfls as in 'find -t' */
        int <emphasis remap='I'>type</emphasis>;
        /* Corresponds to file permissions */
        int <emphasis remap='I'>perm</emphasis>;
        /* Acceptable mac type */
        Tcl_Obj *<emphasis remap='I'>macType</emphasis>;
        /* Acceptable mac creator */
        Tcl_Obj *<emphasis remap='I'>macCreator</emphasis>;
} Tcl_GlobTypeData;
</programlisting> <!-- remap='CE' -->

<para>There are two specific cases which it is important to handle correctly,
both when <varname role='parameter'>types</varname> is non-NULL. The two cases are when <emphasis remap='I'>types-&gt;types
&amp; TCL_GLOB_TYPE_DIR</emphasis> or <emphasis remap='I'>types-&gt;types &amp; TCL_GLOB_TYPE_MOUNT</emphasis> are
true (and in particular when the other flags are false).  In the first of
these cases, the function must list the contained directories.  Tcl uses
this to implement recursive globbing, so it is critical that filesystems
implement directory matching correctly.  In the second of these cases,
with <emphasis remap='B'>TCL_GLOB_TYPE_MOUNT</emphasis>, the filesystem must list the mount points
which lie within the given <varname role='parameter'>pathPtr</varname> (and in this case, <varname role='parameter'>pathPtr</varname>
need not lie within the same filesystem - different to all other cases in
which this function is called).  Support for this is critical if Tcl is
to have seamless transitions between from one filesystem to another.</para>
</refsect2>

<refsect2 xml:id='utimeproc'><title>UTIMEPROC</title>

<para>Function to process a <function>Tcl_FSUtime</function> call.  Required to allow setting
(not reading) of times with <emphasis remap='B'>file mtime</emphasis>, <emphasis remap='B'>file atime</emphasis> and the
open-r/open-w/fcopy implementation of <emphasis remap='B'>file copy</emphasis>.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSUtimeProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>struct utimbuf * <parameter>tval</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The access and modification times of the file specified by <varname role='parameter'>pathPtr</varname>
should be changed to the values given in the <varname role='parameter'>tval</varname> structure.</para>

<para>The return value should be 0 on success and -1 on an error, as
with the system <emphasis remap='B'>utime</emphasis>.</para>
</refsect2>

<refsect2 xml:id='linkproc'><title>LINKPROC</title>

<para>Function to process a <emphasis remap='B'>Tcl_FSLink</emphasis> call.  Should be implemented
only if the filesystem supports links, and may otherwise be NULL.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef <function>Tcl_Obj</function> *Tcl_FSLinkProc</funcdef>
    <paramdef>Tcl_Obj * <parameter>linkNamePtr</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>toPtr</parameter></paramdef>
    <paramdef>int <parameter>linkAction</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>If <varname role='parameter'>toPtr</varname> is NULL, the function is being asked to read the
contents of a link.  The result is a Tcl_Obj specifying the contents of
the link given by <varname role='parameter'>linkNamePtr</varname>, or NULL if the link could
not be read.  The result is owned by the caller (and should therefore
have its ref count incremented before being returned).  Any callers
should call Tcl_DecrRefCount on this result when it is no longer needed.
If <varname role='parameter'>toPtr</varname> is not NULL, the function should attempt to create a link.
The result in this case should be <varname role='parameter'>toPtr</varname> if the link was successful
and NULL otherwise.  In this case the result is not owned by the caller
(i.e. no ref count manipulation on either end is needed). See
the documentation for <emphasis remap='B'>Tcl_FSLink</emphasis> for the correct interpretation
of the <varname role='parameter'>linkAction</varname> flags.</para>
</refsect2>

<refsect2 xml:id='listvolumesproc'><title>LISTVOLUMESPROC</title>

<para>Function to list any filesystem volumes added by this filesystem.
Should be implemented only if the filesystem adds volumes at the head
of the filesystem, so that they can be returned by <emphasis remap='B'>file volumes</emphasis>.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcsynopsisinfo>
typedef Tcl_Obj* Tcl_FSListVolumesProc(void);
</funcsynopsisinfo>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The result should be a list of volumes added by this filesystem, or
NULL (or an empty list) if no volumes are provided.  The result object
is considered to be owned by the filesystem (not by Tcl's core), but
should be given a refCount for Tcl.  Tcl will use the contents of the
list and then decrement that refCount.  This allows filesystems to
choose whether they actually want to retain a
<quote>master list</quote>
of volumes
or not (if not, they generate the list on the fly and pass it to Tcl
with a refCount of 1 and then forget about the list, if yes, then
they simply increment the refCount of their master list and pass it
to Tcl which will copy the contents and then decrement the count back
to where it was).</para>

<para>Therefore, Tcl considers return values from this proc to be read-only.</para>
</refsect2>

<refsect2 xml:id='fileattrstringsproc'><title>FILEATTRSTRINGSPROC</title>

<para>Function to list all attribute strings which are valid for this
filesystem.  If not implemented the filesystem will not support
the <emphasis remap='B'>file attributes</emphasis> command.  This allows arbitrary additional
information to be attached to files in the filesystem.  If it is
not implemented, there is no need to implement the <emphasis remap='B'>get</emphasis> and <emphasis remap='B'>set</emphasis>
methods.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef const char **<function>Tcl_FSFileAttrStringsProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>Tcl_Obj ** <parameter>objPtrRef</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The called function may either return an array of strings, or may
instead return NULL and place a Tcl list into the given <varname role='parameter'>objPtrRef</varname>.  Tcl
will take that list and first increment its reference count before using it.
On completion of that use, Tcl will decrement its reference count.  Hence if
the list should be disposed of by Tcl when done, it should have a
reference count of zero, and if the list should not be disposed of, the
filesystem should ensure it returns an object with a reference count
of at least one.</para>
</refsect2>

<refsect2 xml:id='fileattrsgetproc'><title>FILEATTRSGETPROC</title>

<para>Function to process a <function>Tcl_FSFileAttrsGet</function> call, used by <emphasis remap='B'>file
attributes</emphasis>.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSFileAttrsGetProc</function></funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>int <parameter>index</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>Tcl_Obj ** <parameter>objPtrRef</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Returns a standard Tcl return code.  The attribute value retrieved,
which corresponds to the <varname role='parameter'>index</varname>'th element in the list returned by
the <function>Tcl_FSFileAttrStringsProc</function>, is a Tcl_Obj placed in <varname role='parameter'>objPtrRef</varname> (if
<emphasis remap='B'>TCL_OK</emphasis> was returned) and is likely to have a reference count of zero.  Either
way we must either store it somewhere (e.g. the Tcl result), or
Incr/Decr its reference count to ensure it is properly freed.</para>
</refsect2>

<refsect2 xml:id='fileattrssetproc'><title>FILEATTRSSETPROC</title>

<para>Function to process a <function>Tcl_FSFileAttrsSet</function> call, used by <emphasis remap='B'>file
attributes</emphasis>.  If the filesystem is read-only, there is no need
to implement this.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSFileAttrsSetProc</function></funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>int <parameter>index</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>objPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The attribute value of the <varname role='parameter'>index</varname>'th element in the list returned by
the Tcl_FSFileAttrStringsProc should be set to the <varname role='parameter'>objPtr</varname> given.</para>
</refsect2>

<refsect2 xml:id='createdirectoryproc'><title>CREATEDIRECTORYPROC</title>

<para>Function to process a <function>Tcl_FSCreateDirectory</function> call.  Should be
implemented unless the FS is read-only.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSCreateDirectoryProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The return value is a standard Tcl result indicating whether an error
occurred in the process.  If successful, a new directory should have
been added to the filesystem in the location specified by
<varname role='parameter'>pathPtr</varname>.</para>
</refsect2>

<refsect2 xml:id='removedirectoryproc'><title>REMOVEDIRECTORYPROC</title>

<para>Function to process a <function>Tcl_FSRemoveDirectory</function> call.  Should be
implemented unless the FS is read-only.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSRemoveDirectoryProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>int <parameter>recursive</parameter></paramdef>
    <paramdef>Tcl_Obj ** <parameter>errorPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The return value is a standard Tcl result indicating whether an error
occurred in the process.  If successful, the directory specified by
<varname role='parameter'>pathPtr</varname> should have been removed from the filesystem.  If the
<varname role='parameter'>recursive</varname> flag is given, then a non-empty directory should be
deleted without error.  If this flag is not given, then and the
directory is non-empty a POSIX
<quote>EEXIST</quote>
error should be signaled.  If an
error does occur, the name of the file or directory which caused the
error should be placed in <varname role='parameter'>errorPtr</varname>.</para>
</refsect2>

<refsect2 xml:id='deletefileproc'><title>DELETEFILEPROC</title>

<para>Function to process a <function>Tcl_FSDeleteFile</function> call.  Should be implemented
unless the FS is read-only.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSDeleteFileProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The return value is a standard Tcl result indicating whether an error
occurred in the process.  If successful, the file specified by
<varname role='parameter'>pathPtr</varname> should have been removed from the filesystem.  Note that,
if the filesystem supports symbolic links, Tcl will always call this
function and not Tcl_FSRemoveDirectoryProc when needed to delete them
(even if they are symbolic links to directories).</para>
</refsect2>
</refsect1>

<refsect1 xml:id='filesystem_efficiency'><title>FILESYSTEM EFFICIENCY</title>
<para>These functions need not be implemented for a particular filesystem
because the core has a fallback implementation available. See each
individual description for the consequences of leaving the field NULL.</para>

<refsect2 xml:id='lstatproc'><title>LSTATPROC</title>

<para>Function to process a <function>Tcl_FSLstat</function> call.  If not implemented, Tcl
will attempt to use the <emphasis remap='I'>statProc</emphasis> defined above instead.  Therefore
it need only be implemented if a filesystem can differentiate between
<emphasis remap='B'>stat</emphasis> and <emphasis remap='B'>lstat</emphasis> calls.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSLstatProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>Tcl_StatBuf * <parameter>statPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The behavior of this function is very similar to that of the
<function>Tcl_FSStatProc</function> defined above, except that if it is applied
to a symbolic link, it returns information about the link, not
about the target file.</para>
</refsect2>

<refsect2 xml:id='copyfileproc'><title>COPYFILEPROC</title>

<para>Function to process a <function>Tcl_FSCopyFile</function> call.  If not implemented Tcl
will fall back on <emphasis remap='B'>open</emphasis>-r, <emphasis remap='B'>open</emphasis>-w and <emphasis remap='B'>fcopy</emphasis> as a
copying mechanism.
Therefore it need only be implemented if the filesystem can perform
that action more efficiently.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSCopyFileProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>srcPathPtr</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>destPathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The return value is a standard Tcl result indicating whether an error
occurred in the copying process.  Note that, <varname role='parameter'>destPathPtr</varname> is the
name of the file which should become the copy of <varname role='parameter'>srcPathPtr</varname>. It
is never the name of a directory into which <varname role='parameter'>srcPathPtr</varname> could be
copied (i.e. the function is much simpler than the Tcl level <emphasis remap='B'>file
copy</emphasis> subcommand).  Note that,
if the filesystem supports symbolic links, Tcl will always call this
function and not <emphasis remap='I'>copyDirectoryProc</emphasis> when needed to copy them
(even if they are symbolic links to directories).  Finally, if the
filesystem determines it cannot support the <emphasis remap='B'>file copy</emphasis> action,
calling <emphasis remap='B'>Tcl_SetErrno(EXDEV)</emphasis> and returning a non-<emphasis remap='B'>TCL_OK</emphasis>
result will tell Tcl to use its standard fallback mechanisms.</para>
</refsect2>

<refsect2 xml:id='renamefileproc'><title>RENAMEFILEPROC</title>

<para>Function to process a <function>Tcl_FSRenameFile</function> call.  If not implemented,
Tcl will fall back on a copy and delete mechanism.  Therefore it need
only be implemented if the filesystem can perform that action more
efficiently.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSRenameFileProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>srcPathPtr</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>destPathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The return value is a standard Tcl result indicating whether an error
occurred in the renaming process.  If the
filesystem determines it cannot support the <emphasis remap='B'>file rename</emphasis> action,
calling <emphasis remap='B'>Tcl_SetErrno(EXDEV)</emphasis> and returning a non-<emphasis remap='B'>TCL_OK</emphasis>
result will tell Tcl to use its standard fallback mechanisms.</para>
</refsect2>

<refsect2 xml:id='copydirectoryproc'><title>COPYDIRECTORYPROC</title>

<para>Function to process a <function>Tcl_FSCopyDirectory</function> call.  If not
implemented, Tcl will fall back on a recursive <emphasis remap='B'>file mkdir</emphasis>, <emphasis remap='B'>file copy</emphasis>
mechanism.  Therefore it need only be implemented if the filesystem can
perform that action more efficiently.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSCopyDirectoryProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>srcPathPtr</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>destPathPtr</parameter></paramdef>
    <paramdef>Tcl_Obj ** <parameter>errorPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The return value is a standard Tcl result indicating whether an error
occurred in the copying process.  If an error does occur, the name of
the file or directory which caused the error should be placed in
<varname role='parameter'>errorPtr</varname>. Note that, <varname role='parameter'>destPathPtr</varname> is the name of the
directory-name which should become the mirror-image of
<varname role='parameter'>srcPathPtr</varname>. It is not the name of a directory into which
<varname role='parameter'>srcPathPtr</varname> should be copied (i.e. the function is much simpler
than the Tcl level <emphasis remap='B'>file copy</emphasis> subcommand).  Finally, if the
filesystem determines it cannot support the directory copy action,
calling <emphasis remap='B'>Tcl_SetErrno(EXDEV)</emphasis> and returning a non-<emphasis remap='B'>TCL_OK</emphasis>
result will tell Tcl to use its standard fallback mechanisms.</para>
</refsect2>

<refsect2 xml:id='loadfileproc'><title>LOADFILEPROC</title>

<para>Function to process a <function>Tcl_FSLoadFile</function> call.  If not implemented, Tcl
will fall back on a copy to native-temp followed by a <function>Tcl_FSLoadFile</function> on
that temporary copy.  Therefore it need only be implemented if the
filesystem can load code directly, or it can be implemented simply to
return <emphasis remap='B'>TCL_ERROR</emphasis> to disable load functionality in this filesystem
entirely.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSLoadFileProc</function></funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
    <paramdef>Tcl_LoadHandle * <parameter>handlePtr</parameter></paramdef>
    <paramdef>Tcl_FSUnloadFileProc * <parameter>unloadProcPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Returns a standard Tcl completion code.  If an error occurs, an error
message is left in the <varname role='parameter'>interp</varname>'s result.  The function dynamically loads a
binary code file into memory.  On a successful load, the <varname role='parameter'>handlePtr</varname>
should be filled with a token for the dynamically loaded file, and the
<varname role='parameter'>unloadProcPtr</varname> should be filled in with the address of a procedure.
The unload procedure will be called with the given <type>Tcl_LoadHandle</type> as its
only parameter when Tcl needs to unload the file.  For example, for the
native filesystem, the <type>Tcl_LoadHandle</type> returned is currently a token
which can be used in the private <emphasis remap='B'>TclpFindSymbol</emphasis> to access functions
in the new code.  Each filesystem is free to define the
<type>Tcl_LoadHandle</type> as it requires.  Finally, if the
filesystem determines it cannot support the file load action,
calling <emphasis remap='B'>Tcl_SetErrno(EXDEV)</emphasis> and returning a non-<emphasis remap='B'>TCL_OK</emphasis>
result will tell Tcl to use its standard fallback mechanisms.</para>
</refsect2>

<refsect2 xml:id='unloadfileproc'><title>UNLOADFILEPROC</title>

<para>Function to unload a previously successfully loaded file.  If load was
implemented, then this should also be implemented, if there is any
cleanup action required.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef void <function>Tcl_FSUnloadFileProc</function></funcdef>
    <paramdef>Tcl_LoadHandle <parameter>loadHandle</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>Function to process a <emphasis remap='B'>Tcl_FSGetCwd</emphasis> call.  Most filesystems need not
implement this.  It will usually only be called once, if <emphasis remap='B'>getcwd</emphasis> is
called before <emphasis remap='B'>chdir</emphasis>.  May be NULL.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef <function>Tcl_Obj</function> *Tcl_FSGetCwdProc</funcdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>If the filesystem supports a native notion of a current working
directory (which might perhaps change independent of Tcl), this
function should return that cwd as the result, or NULL if the current
directory could not be determined (e.g. the user does not have
appropriate permissions on the cwd directory).  If NULL is returned, an
error message is left in the <varname role='parameter'>interp</varname>'s result.</para>
</refsect2>

<refsect2 xml:id='chdirproc'><title>CHDIRPROC</title>

<para>Function to process a <function>Tcl_FSChdir</function> call.  If filesystems do not
implement this, it will be emulated by a series of directory access
checks.  Otherwise, virtual filesystems which do implement it need only
respond with a positive return result if the <varname role='parameter'>pathPtr</varname> is a valid,
accessible directory in their filesystem.  They need not remember the
result, since that will be automatically remembered for use by
<emphasis remap='B'>Tcl_FSGetCwd</emphasis>.
Real filesystems should carry out the correct action (i.e. call the
correct system <emphasis remap='B'>chdir</emphasis> API).</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_FSChdirProc</function></funcdef>
    <paramdef>Tcl_Obj * <parameter>pathPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The <function>Tcl_FSChdirProc</function> changes the applications current working
directory to the value specified in <varname role='parameter'>pathPtr</varname>. The function returns
-1 on error or 0 on success.</para>
</refsect2>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>cd(n), file(n), load(n), open(n), pwd(n), unload(n)</para>
</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>stat, access, filesystem, vfs, virtual</para>
</refsect1>
</refentry>

