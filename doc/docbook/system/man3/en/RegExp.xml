<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='regexp3'>

<!-- '\" Copyright (c) 1994 The Regents of the University of California.
'\" Copyright (c) 1994\-1996 Sun Microsystems, Inc.
'\" Copyright (c) 1998\-1999 Scriptics Corporation -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>8.1</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_RegExpMatch</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>8.1</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_RegExpMatch</refname>
<refname>Tcl_RegExpCompile</refname>
<refname>Tcl_RegExpExec</refname>
<refname>Tcl_RegExpRange</refname>
<refname>Tcl_GetRegExpFromObj</refname>
<refname>Tcl_RegExpMatchObj</refname>
<refname>Tcl_RegExpExecObj</refname>
<refname>Tcl_RegExpGetInfo</refname>
<refpurpose>Pattern matching with regular expressions</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>Tcl_RegExpMatchObj</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>textObj</parameter></paramdef>
<paramdef><parameter>patObj</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_RegExpMatch</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>text</parameter></paramdef>
<paramdef><parameter>pattern</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_RegExp <function>Tcl_RegExpCompile</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>pattern</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_RegExpExec</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>regexp</parameter></paramdef>
<paramdef><parameter>text</parameter></paramdef>
<paramdef><parameter>start</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>void <function>Tcl_RegExpRange</function></funcdef>
<paramdef><parameter>regexp</parameter></paramdef>
<paramdef><parameter>index</parameter></paramdef>
<paramdef><parameter>startPtr</parameter></paramdef>
<paramdef><parameter>endPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_RegExp <function>Tcl_GetRegExpFromObj</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>patObj</parameter></paramdef>
<paramdef><parameter>cflags</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_RegExpExecObj</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>regexp</parameter></paramdef>
<paramdef><parameter>textObj</parameter></paramdef>
<paramdef><parameter>offset</parameter></paramdef>
<paramdef><parameter>nmatches</parameter></paramdef>
<paramdef><parameter>eflags</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>void <function>Tcl_RegExpGetInfo</function></funcdef>
<paramdef><parameter>regexp</parameter></paramdef>
<paramdef><parameter>infoPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tcl_RegExpInfo *interp in/out -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Interp"</entry><entry>"*interp"</entry><entry>"in"</entry>
<entry>
<para>Tcl interpreter to use for error reporting.  The interpreter may be
NULL if no error reporting is desired.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*textObj</entry><entry>in/out</entry>
<entry>
<para>Refers to the object from which to get the text to search.  The
internal representation of the object may be converted to a form that
can be efficiently searched.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*patObj</entry><entry>in/out</entry>
<entry>
<para>Refers to the object from which to get a regular expression. The
compiled regular expression is cached in the object.</para>
</entry>
</row>
<row><entry>char</entry><entry>*text</entry><entry>in</entry>
<entry>
<para>Text to search for a match with a regular expression.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*pattern</entry><entry>in</entry>
<entry>
<para>String in the form of a regular expression pattern.</para>
</entry>
</row>
<row><entry>Tcl_RegExp</entry><entry>regexp</entry><entry>in</entry>
<entry>
<para>Compiled regular expression.  Must have been returned previously
by <function>Tcl_GetRegExpFromObj</function> or <function>Tcl_RegExpCompile</function>.</para>
</entry>
</row>
<row><entry>char</entry><entry>*start</entry><entry>in</entry>
<entry>
<para>If <emphasis remap='I'>text</emphasis> is just a portion of some other string, this argument
identifies the beginning of the larger string.
If it is not the same as <emphasis remap='I'>text</emphasis>, then no
<quote><emphasis remap='B'>^</emphasis></quote>
matches will be allowed.</para>
</entry>
</row>
<row><entry>int</entry><entry>index</entry><entry>in</entry>
<entry>
<para>Specifies which range is desired:  0 means the range of the entire
match, 1 or greater means the range that matched a parenthesized
sub-expression.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>**startPtr</entry><entry>out</entry>
<entry>
<para>The address of the first character in the range is stored here, or
NULL if there is no such range.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>**endPtr</entry><entry>out</entry>
<entry>
<para>The address of the character just after the last one in the range
is stored here, or NULL if there is no such range.</para>
</entry>
</row>
<row><entry>int</entry><entry>cflags</entry><entry>in</entry>
<entry>
<para>OR-ed combination of the compilation flags <emphasis remap='B'>TCL_REG_ADVANCED</emphasis>,
<emphasis remap='B'>TCL_REG_EXTENDED</emphasis>, <emphasis remap='B'>TCL_REG_BASIC</emphasis>, <emphasis remap='B'>TCL_REG_EXPANDED</emphasis>,
<emphasis remap='B'>TCL_REG_QUOTE</emphasis>, <emphasis remap='B'>TCL_REG_NOCASE</emphasis>, <emphasis remap='B'>TCL_REG_NEWLINE</emphasis>,
<emphasis remap='B'>TCL_REG_NLSTOP</emphasis>, <emphasis remap='B'>TCL_REG_NLANCH</emphasis>, <emphasis remap='B'>TCL_REG_NOSUB</emphasis>, and
<emphasis remap='B'>TCL_REG_CANMATCH</emphasis>. See below for more information.</para>
</entry>
</row>
<row><entry>int</entry><entry>offset</entry><entry>in</entry>
<entry>
<para>The character offset into the text where matching should begin.
The value of the offset has no impact on <emphasis remap='B'>^</emphasis> matches.  This
behavior is controlled by <emphasis remap='I'>eflags</emphasis>.</para>
</entry>
</row>
<row><entry>int</entry><entry>nmatches</entry><entry>in</entry>
<entry>
<para>The number of matching subexpressions that should be remembered for
later use.  If this value is 0, then no subexpression match
information will be computed.  If the value is -1, then
all of the matching subexpressions will be remembered.  Any other
value will be taken as the maximum number of subexpressions to
remember.</para>
</entry>
</row>
<row><entry>int</entry><entry>eflags</entry><entry>in</entry>
<entry>
<para>OR-ed combination of the execution flags <emphasis remap='B'>TCL_REG_NOTBOL</emphasis> and
<emphasis remap='B'>TCL_REG_NOTEOL</emphasis>. See below for more information.</para>
</entry>
</row>
<row><entry>Tcl_RegExpInfo</entry><entry>*infoPtr</entry><entry>out</entry>
<entry>
<para>The address of the location where information about a previous match
should be stored by <function>Tcl_RegExpGetInfo</function>.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para><function>Tcl_RegExpMatch</function> determines whether its <emphasis remap='I'>pattern</emphasis> argument
matches <emphasis remap='I'>regexp</emphasis>, where <emphasis remap='I'>regexp</emphasis> is interpreted
as a regular expression using the rules in the <emphasis remap='B'>re_syntax</emphasis>
reference page. 
If there is a match then <function>Tcl_RegExpMatch</function> returns 1.
If there is no match then <function>Tcl_RegExpMatch</function> returns 0.
If an error occurs in the matching process (e.g. <emphasis remap='I'>pattern</emphasis>
is not a valid regular expression) then <function>Tcl_RegExpMatch</function>
returns -1 and leaves an error message in the interpreter result.
<function>Tcl_RegExpMatchObj</function> is similar to <function>Tcl_RegExpMatch</function> except it
operates on the Tcl objects <emphasis remap='I'>textObj</emphasis> and <emphasis remap='I'>patObj</emphasis> instead of
UTF strings. 
<function>Tcl_RegExpMatchObj</function> is generally more efficient than
<function>Tcl_RegExpMatch</function>, so it is the preferred interface.</para>

<para><function>Tcl_RegExpCompile</function>, <function>Tcl_RegExpExec</function>, and <function>Tcl_RegExpRange</function>
provide lower-level access to the regular expression pattern matcher.
<function>Tcl_RegExpCompile</function> compiles a regular expression string into
the internal form used for efficient pattern matching.
The return value is a token for this compiled form, which can be
used in subsequent calls to <function>Tcl_RegExpExec</function> or <function>Tcl_RegExpRange</function>.
If an error occurs while compiling the regular expression then
<function>Tcl_RegExpCompile</function> returns NULL and leaves an error message
in the interpreter result.
Note:  the return value from <function>Tcl_RegExpCompile</function> is only valid
up to the next call to <function>Tcl_RegExpCompile</function>;  it is not safe to
retain these values for long periods of time.</para>

<para><function>Tcl_RegExpExec</function> executes the regular expression pattern matcher.
It returns 1 if <emphasis remap='I'>text</emphasis> contains a range of characters that
match <emphasis remap='I'>regexp</emphasis>, 0 if no match is found, and
-1 if an error occurs.
In the case of an error, <function>Tcl_RegExpExec</function> leaves an error
message in the interpreter result.
When searching a string for multiple matches of a pattern,
it is important to distinguish between the start of the original
string and the start of the current search.
For example, when searching for the second occurrence of a
match, the <emphasis remap='I'>text</emphasis> argument might point to the character
just after the first match;  however, it is important for the
pattern matcher to know that this is not the start of the entire string,
so that it does not allow
<quote><emphasis remap='B'>^</emphasis></quote>
atoms in the pattern to match.
The <emphasis remap='I'>start</emphasis> argument provides this information by pointing
to the start of the overall string containing <emphasis remap='I'>text</emphasis>.
<emphasis remap='I'>Start</emphasis> will be less than or equal to <emphasis remap='I'>text</emphasis>;  if it
is less than <emphasis remap='I'>text</emphasis> then no <emphasis remap='B'>^</emphasis> matches will be allowed.</para>

<para><function>Tcl_RegExpRange</function> may be invoked after <function>Tcl_RegExpExec</function>
returns;  it provides detailed information about what ranges of
the string matched what parts of the pattern.
<function>Tcl_RegExpRange</function> returns a pair of pointers in <emphasis remap='I'>*startPtr</emphasis>
and <emphasis remap='I'>*endPtr</emphasis> that identify a range of characters in
the source string for the most recent call to <function>Tcl_RegExpExec</function>.
<emphasis remap='I'>Index</emphasis> indicates which of several ranges is desired:
if <emphasis remap='I'>index</emphasis> is 0, information is returned about the overall range
of characters that matched the entire pattern;  otherwise,
information is returned about the range of characters that matched the
<emphasis remap='I'>index</emphasis>'th parenthesized subexpression within the pattern.
If there is no range corresponding to <emphasis remap='I'>index</emphasis> then NULL
is stored in <emphasis remap='I'>*startPtr</emphasis> and <emphasis remap='I'>*endPtr</emphasis>.</para>

<para><function>Tcl_GetRegExpFromObj</function>, <function>Tcl_RegExpExecObj</function>, and
<function>Tcl_RegExpGetInfo</function> are object interfaces that provide the most
direct control of Henry Spencer's regular expression library.  For
users that need to modify compilation and execution options directly,
it is recommended that you use these interfaces instead of calling the
internal regexp functions.  These interfaces handle the details of UTF
to Unicode translations as well as providing improved performance
through caching in the pattern and string objects.</para>

<para><function>Tcl_GetRegExpFromObj</function> attempts to return a compiled regular
expression from the <emphasis remap='I'>patObj</emphasis>.  If the object does not already
contain a compiled regular expression it will attempt to create one
from the string in the object and assign it to the internal
representation of the <emphasis remap='I'>patObj</emphasis>.  The return value of this function
is of type <type>Tcl_RegExp</type>.  The return value is a token for this
compiled form, which can be used in subsequent calls to
<function>Tcl_RegExpExecObj</function> or <function>Tcl_RegExpGetInfo</function>.  If an error
occurs while compiling the regular expression then
<function>Tcl_GetRegExpFromObj</function> returns NULL and leaves an error message in
the interpreter result.  The regular expression token can be used as
long as the internal representation of <emphasis remap='I'>patObj</emphasis> refers to the
compiled form.  The <emphasis remap='I'>cflags</emphasis> argument is a bit-wise OR of
zero or more of the following flags that control the compilation of
<emphasis remap='I'>patObj</emphasis>:</para>
  <blockquote remap='RS'>
  <variablelist remap='TP'>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_ADVANCED</emphasis></term>
    <listitem>
<para>Compile advanced regular expressions
(<quote>ARE</quote>s)
This mode corresponds to
the normal regular expression syntax accepted by the Tcl <emphasis remap='B'>regexp</emphasis> and
<emphasis remap='B'>regsub</emphasis> commands.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_EXTENDED</emphasis></term>
    <listitem>
<para>Compile extended regular expressions
(<quote>ERE</quote>s)
This mode corresponds
to the regular expression syntax recognized by Tcl 8.0 and earlier
versions.</para> 
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_BASIC</emphasis></term>
    <listitem>
<para>Compile basic regular expressions
(<quote>BRE</quote>s)
This mode corresponds
to the regular expression syntax recognized by common Unix utilities
like <emphasis remap='B'>sed</emphasis> and <emphasis remap='B'>grep</emphasis>.  This is the default if no flags are
specified.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_EXPANDED</emphasis></term>
    <listitem>
<para>Compile the regular expression (basic, extended, or advanced) using an
expanded syntax that allows comments and whitespace.  This mode causes
non-backslashed non-bracket-expression white
space and #-to-end-of-line comments to be ignored.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_QUOTE</emphasis></term>
    <listitem>
<para>Compile a literal string, with all characters treated as ordinary characters.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_NOCASE</emphasis></term>
    <listitem>
<para>Compile for matching that ignores upper/lower case distinctions.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_NEWLINE</emphasis></term>
    <listitem>
<para>Compile for newline-sensitive matching.  By default, newline is a
completely ordinary character with no special meaning in either
regular expressions or strings.  With this flag,
<quote>[^</quote>
bracket expressions and
<quote>.</quote>
never match newline,
<quote>^</quote>
matches an empty string
after any newline in addition to its normal function, and
<quote>$</quote>
matches
an empty string before any newline in addition to its normal function.
<emphasis remap='B'>REG_NEWLINE</emphasis> is the bit-wise OR of <emphasis remap='B'>REG_NLSTOP</emphasis> and
<emphasis remap='B'>REG_NLANCH</emphasis>.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_NLSTOP</emphasis></term>
    <listitem>
<para>Compile for partial newline-sensitive matching,
with the behavior of
<quote>[^</quote>
bracket expressions and
<quote>.</quote>
affected, but not the behavior of
<quote>^</quote>
and
<quote>$</quote>.
In this mode,
<quote>[^</quote>
bracket expressions and
<quote>.</quote>
never match newline.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_NLANCH</emphasis></term>
    <listitem>
<para>Compile for inverse partial newline-sensitive matching,
with the behavior of
<quote>^</quote>
and
<quote>$</quote>
(the
<quote>anchors</quote>)
affected, but not the behavior of
<quote>[^</quote>
bracket expressions and
<quote>.</quote>.
In this mode
<quote>^</quote>
matches an empty string
after any newline in addition to its normal function, and
<quote>$</quote>
matches
an empty string before any newline in addition to its normal function.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_NOSUB</emphasis></term>
    <listitem>
<para>Compile for matching that reports only success or failure,
not what was matched.  This reduces compile overhead and may improve
performance.  Subsequent calls to <function>Tcl_RegExpGetInfo</function> or
<function>Tcl_RegExpRange</function> will not report any match information.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_CANMATCH</emphasis></term>
    <listitem>
<para>Compile for matching that reports the potential to complete a partial
match given more text (see below).</para>
    </listitem>
    </varlistentry>
  </variablelist>
  </blockquote> <!-- remap='RE' -->

<para>Only one of
<emphasis remap='B'>TCL_REG_EXTENDED</emphasis>,
<emphasis remap='B'>TCL_REG_ADVANCED</emphasis>,
<emphasis remap='B'>TCL_REG_BASIC</emphasis>, and
<emphasis remap='B'>TCL_REG_QUOTE</emphasis> may be specified.</para>

<para><function>Tcl_RegExpExecObj</function> executes the regular expression pattern
matcher.  It returns 1 if <emphasis remap='I'>objPtr</emphasis> contains a range of characters
that match <emphasis remap='I'>regexp</emphasis>, 0 if no match is found, and -1 if an error
occurs.  In the case of an error, <function>Tcl_RegExpExecObj</function> leaves an
error message in the interpreter result.  The <emphasis remap='I'>nmatches</emphasis> value
indicates to the matcher how many subexpressions are of interest.  If
<emphasis remap='I'>nmatches</emphasis> is 0, then no subexpression match information is
recorded, which may allow the matcher to make various optimizations.
If the value is -1, then all of the subexpressions in the pattern are
remembered.  If the value is a positive integer, then only that number
of subexpressions will be remembered.  Matching begins at the
specified Unicode character index given by <emphasis remap='I'>offset</emphasis>.  Unlike
<function>Tcl_RegExpExec</function>, the behavior of anchors is not affected by the
offset value.  Instead the behavior of the anchors is explicitly
controlled by the <emphasis remap='I'>eflags</emphasis> argument, which is a bit-wise OR of
zero or more of the following flags:</para>
  <blockquote remap='RS'>
  <variablelist remap='TP'>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_NOTBOL</emphasis></term>
    <listitem>
<para>The starting character will not be treated as the beginning of a
line or the beginning of the string, so
<quote>^</quote>
will not match there.
Note that this flag has no effect on how
<quote><emphasis remap='B'>\A</emphasis></quote>
matches.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><emphasis remap='B'>TCL_REG_NOTEOL</emphasis></term>
    <listitem>
<para>The last character in the string will not be treated as the end of a
line or the end of the string, so
<quote>$</quote>
will not match there.
Note that this flag has no effect on how
<quote><emphasis remap='B'>\Z</emphasis></quote>
matches.</para>
    </listitem>
    </varlistentry>
  </variablelist>
  </blockquote> <!-- remap='RE' -->

<para><function>Tcl_RegExpGetInfo</function> retrieves information about the last match
performed with a given regular expression <emphasis remap='I'>regexp</emphasis>.  The
<emphasis remap='I'>infoPtr</emphasis> argument contains a pointer to a structure that is
defined as follows:</para>

<programlisting remap='CS'>
typedef struct Tcl_RegExpInfo {
        int <emphasis remap='I'>nsubs</emphasis>;
        Tcl_RegExpIndices *<emphasis remap='I'>matches</emphasis>;
        long <emphasis remap='I'>extendStart</emphasis>;
} Tcl_RegExpInfo;
</programlisting> <!-- remap='CE' -->

<para>The <emphasis remap='I'>nsubs</emphasis> field contains a count of the number of parenthesized
subexpressions within the regular expression.  If the <emphasis remap='B'>TCL_REG_NOSUB</emphasis>
was used, then this value will be zero.  The <emphasis remap='I'>matches</emphasis> field
points to an array of <emphasis remap='I'>nsubs</emphasis> values that indicate the bounds of each
subexpression matched.  The first element in the array refers to the
range matched by the entire regular expression, and subsequent elements
refer to the parenthesized subexpressions in the order that they
appear in the pattern.  Each element is a structure that is defined as
follows:</para>

<programlisting remap='CS'>
typedef struct Tcl_RegExpIndices {
        long <emphasis remap='I'>start</emphasis>;
        long <emphasis remap='I'>end</emphasis>;
} Tcl_RegExpIndices;
</programlisting> <!-- remap='CE' -->

<para>The <emphasis remap='I'>start</emphasis> and <emphasis remap='I'>end</emphasis> values are Unicode character indices
relative to the offset location within <emphasis remap='I'>objPtr</emphasis> where matching began.
The <emphasis remap='I'>start</emphasis> index identifies the first character of the matched
subexpression.  The <emphasis remap='I'>end</emphasis> index identifies the first character
after the matched subexpression.  If the subexpression matched the
empty string, then <emphasis remap='I'>start</emphasis> and <emphasis remap='I'>end</emphasis> will be equal.  If the
subexpression did not participate in the match, then <emphasis remap='I'>start</emphasis> and
<emphasis remap='I'>end</emphasis> will be set to -1.</para>

<para>The <emphasis remap='I'>extendStart</emphasis> field in <type>Tcl_RegExpInfo</type> is only set if the
<emphasis remap='B'>TCL_REG_CANMATCH</emphasis> flag was used.  It indicates the first
character in the string where a match could occur.  If a match was
found, this will be the same as the beginning of the current match.
If no match was found, then it indicates the earliest point at which a
match might occur if additional text is appended to the string.  If it
is no match is possible even with further text, this field will be set 
to -1.</para>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>re_syntax(n)</para>
</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>match, pattern, regular expression, string, subexpression, Tcl_RegExpIndices, Tcl_RegExpInfo</para>
</refsect1>
</refentry>

