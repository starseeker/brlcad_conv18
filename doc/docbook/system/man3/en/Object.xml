<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='object3'>

<!-- '\" Copyright (c) 1996\-1997 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>8.5</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_Obj</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>8.5</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_NewObj</refname>
<refname>Tcl_DuplicateObj</refname>
<refname>Tcl_IncrRefCount</refname>
<refname>Tcl_DecrRefCount</refname>
<refname>Tcl_IsShared</refname>
<refname>Tcl_InvalidateStringRep</refname>
<refpurpose>manipulate Tcl objects</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_NewObj</funcdef>
<void/></funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_DuplicateObj</funcdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_IncrRefCount</function></funcdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_DecrRefCount</function></funcdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_IsShared</function></funcdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_InvalidateStringRep</function></funcdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tcl_Obj *objPtr -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Obj"</entry><entry>"*objPtr"</entry><entry>"in"</entry>
<entry>
<para>Points to an object;
must have been the result of a previous call to <emphasis remap='B'>Tcl_NewObj</emphasis>.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='introduction'><title>INTRODUCTION</title>
<para>This man page presents an overview of Tcl objects and how they are used.
It also describes generic procedures for managing Tcl objects.
These procedures are used to create and copy objects,
and increment and decrement the count of references (pointers) to objects.
The procedures are used in conjunction with ones
that operate on specific types of objects such as
<emphasis remap='B'>Tcl_GetIntFromObj</emphasis> and <emphasis remap='B'>Tcl_ListObjAppendElement</emphasis>.
The individual procedures are described along with the data structures
they manipulate.</para>

<para>Tcl's <emphasis remap='I'>dual-ported</emphasis> objects provide a general-purpose mechanism
for storing and exchanging Tcl values.
They largely replace the use of strings in Tcl.
For example, they are used to store variable values,
command arguments, command results, and scripts.
Tcl objects behave like strings but also hold an internal representation
that can be manipulated more efficiently.
For example, a Tcl list is now represented as an object
that holds the list's string representation
as well as an array of pointers to the objects for each list element.
Dual-ported objects avoid most runtime type conversions.
They also improve the speed of many operations
since an appropriate representation is immediately available.
The compiler itself uses Tcl objects to
cache the instruction bytecodes resulting from compiling scripts.</para>

<para>The two representations are a cache of each other and are computed lazily.
That is, each representation is only computed when necessary,
it is computed from the other representation,
and, once computed, it is saved.
In addition, a change in one representation invalidates the other one.
As an example, a Tcl program doing integer calculations can
operate directly on a variable's internal machine integer
representation without having to constantly convert
between integers and strings.
Only when it needs a string representing the variable's value,
say to print it,
will the program regenerate the string representation from the integer.
Although objects contain an internal representation,
their semantics are defined in terms of strings:
an up-to-date string can always be obtained,
and any change to the object will be reflected in that string
when the object's string representation is fetched.
Because of this representation invalidation and regeneration,
it is dangerous for extension writers to access
<function>Tcl_Obj</function> fields directly.
It is better to access Tcl_Obj information using
procedures like <emphasis remap='B'>Tcl_GetStringFromObj</emphasis> and <emphasis remap='B'>Tcl_GetString</emphasis>.</para>

<para>Objects are allocated on the heap
and are referenced using a pointer to their <function>Tcl_Obj</function> structure.
Objects are shared as much as possible.
This significantly reduces storage requirements
because some objects such as long lists are very large.
Also, most Tcl values are only read and never modified.
This is especially true for procedure arguments,
which can be shared between the caller and the called procedure.
Assignment and argument binding is done by
simply assigning a pointer to the value. 
Reference counting is used to determine when it is safe to
reclaim an object's storage.</para>

<para>Tcl objects are typed.
An object's internal representation is controlled by its type.
Several types are predefined in the Tcl core
including integer, double, list, and bytecode.
Extension writers can extend the set of types
by defining their own <emphasis remap='B'>Tcl_ObjType</emphasis> structs.</para>
</refsect1>

<refsect1 xml:id='the_tcl_obj_structure'><title>THE TCL_OBJ STRUCTURE</title>
<para>Each Tcl object is represented by a <function>Tcl_Obj</function> structure
which is defined as follows.</para>
<programlisting remap='CS'>
typedef struct Tcl_Obj {
        int <emphasis remap='I'>refCount</emphasis>;
        char *<emphasis remap='I'>bytes</emphasis>;
        int <emphasis remap='I'>length</emphasis>;
        Tcl_ObjType *<emphasis remap='I'>typePtr</emphasis>;
        union {
                long <emphasis remap='I'>longValue</emphasis>;
                double <emphasis remap='I'>doubleValue</emphasis>;
                void *<emphasis remap='I'>otherValuePtr</emphasis>;
                Tcl_WideInt <emphasis remap='I'>wideValue</emphasis>;
                struct {
                        void *<emphasis remap='I'>ptr1</emphasis>;
                        void *<emphasis remap='I'>ptr2</emphasis>;
                } <emphasis remap='I'>twoPtrValue</emphasis>;
                struct {
                        void *<emphasis remap='I'>ptr</emphasis>;
                        unsigned long <emphasis remap='I'>value</emphasis>;
                } <emphasis remap='I'>ptrAndLongRep</emphasis>;
        } <emphasis remap='I'>internalRep</emphasis>;
} Tcl_Obj;
</programlisting> <!-- remap='CE' -->
<para>The <emphasis remap='I'>bytes</emphasis> and the <emphasis remap='I'>length</emphasis> members together hold
an object's UTF-8 string representation,
which is a <emphasis remap='I'>counted string</emphasis> not containing null bytes (UTF-8 null
characters should be encoded as a two byte sequence: 192, 128.)
<emphasis remap='I'>bytes</emphasis> points to the first byte of the string representation.
The <emphasis remap='I'>length</emphasis> member gives the number of bytes.
The byte array must always have a null byte after the last data byte,
at offset <emphasis remap='I'>length</emphasis>;
this allows string representations
to be treated as conventional null-terminated C strings.
C programs use <emphasis remap='B'>Tcl_GetStringFromObj</emphasis> and <emphasis remap='B'>Tcl_GetString</emphasis> to get
an object's string representation.
If <emphasis remap='I'>bytes</emphasis> is NULL,
the string representation is invalid.</para>

<para>An object's type manages its internal representation.
The member <emphasis remap='I'>typePtr</emphasis> points to the Tcl_ObjType structure
that describes the type.
If <emphasis remap='I'>typePtr</emphasis> is NULL,
the internal representation is invalid.</para>

<para>The <emphasis remap='I'>internalRep</emphasis> union member holds
an object's internal representation.
This is either a (long) integer, a double-precision floating-point number,
a pointer to a value containing additional information
needed by the object's type to represent the object, a Tcl_WideInt
integer, two arbitrary pointers, or a pair made up of an unsigned long
integer and a pointer.</para>

<para>The <emphasis remap='I'>refCount</emphasis> member is used to tell when it is safe to free
an object's storage.
It holds the count of active references to the object.
Maintaining the correct reference count is a key responsibility
of extension writers.
Reference counting is discussed below
in the section <emphasis remap='B'>STORAGE MANAGEMENT OF OBJECTS</emphasis>.</para>

<para>Although extension writers can directly access
the members of a Tcl_Obj structure,
it is much better to use the appropriate procedures and macros.
For example, extension writers should never
read or update <emphasis remap='I'>refCount</emphasis> directly;
they should use macros such as
<function>Tcl_IncrRefCount</function> and <function>Tcl_IsShared</function> instead.</para>

<para>A key property of Tcl objects is that they hold two representations.
An object typically starts out containing only a string representation:
it is untyped and has a NULL <emphasis remap='I'>typePtr</emphasis>.
An object containing an empty string or a copy of a specified string
is created using <emphasis remap='B'>Tcl_NewObj</emphasis> or <emphasis remap='B'>Tcl_NewStringObj</emphasis> respectively.
An object's string value is gotten with
<emphasis remap='B'>Tcl_GetStringFromObj</emphasis> or <emphasis remap='B'>Tcl_GetString</emphasis>
and changed with <emphasis remap='B'>Tcl_SetStringObj</emphasis>.
If the object is later passed to a procedure like <emphasis remap='B'>Tcl_GetIntFromObj</emphasis>
that requires a specific internal representation,
the procedure will create one and set the object's <emphasis remap='I'>typePtr</emphasis>.
The internal representation is computed from the string representation.
An object's two representations are duals of each other:
changes made to one are reflected in the other.
For example, <emphasis remap='B'>Tcl_ListObjReplace</emphasis> will modify an object's
internal representation and the next call to <emphasis remap='B'>Tcl_GetStringFromObj</emphasis>
or <emphasis remap='B'>Tcl_GetString</emphasis> will reflect that change.</para>

<para>Representations are recomputed lazily for efficiency.
A change to one representation made by a procedure
such as <emphasis remap='B'>Tcl_ListObjReplace</emphasis> is not reflected immediately
in the other representation.
Instead, the other representation is marked invalid
so that it is only regenerated if it is needed later.
Most C programmers never have to be concerned with how this is done
and simply use procedures such as <emphasis remap='B'>Tcl_GetBooleanFromObj</emphasis> or
<emphasis remap='B'>Tcl_ListObjIndex</emphasis>.
Programmers that implement their own object types
must check for invalid representations
and mark representations invalid when necessary.
The procedure <function>Tcl_InvalidateStringRep</function> is used
to mark an object's string representation invalid and to
free any storage associated with the old string representation.</para>

<para>Objects usually remain one type over their life,
but occasionally an object must be converted from one type to another.
For example, a C program might build up a string in an object
with repeated calls to <emphasis remap='B'>Tcl_AppendToObj</emphasis>,
and then call <emphasis remap='B'>Tcl_ListObjIndex</emphasis> to extract a list element from
the object.
The same object holding the same string value
can have several different internal representations
at different times.
Extension writers can also force an object to be converted from one type
to another using the <emphasis remap='B'>Tcl_ConvertToType</emphasis> procedure.
Only programmers that create new object types need to be concerned
about how this is done.
A procedure defined as part of the object type's implementation
creates a new internal representation for an object
and changes its <emphasis remap='I'>typePtr</emphasis>.
See the man page for <emphasis remap='B'>Tcl_RegisterObjType</emphasis>
to see how to create a new object type.</para>
</refsect1>

<refsect1 xml:id='example_of_the_lifetime_of_an_object'><title>EXAMPLE OF THE LIFETIME OF AN OBJECT</title>
<para>As an example of the lifetime of an object,
consider the following sequence of commands:</para>
<programlisting remap='CS'>
<emphasis remap='B'>set x 123</emphasis>
</programlisting> <!-- remap='CE' -->
<para>This assigns to <emphasis remap='I'>x</emphasis> an untyped object whose
<emphasis remap='I'>bytes</emphasis> member points to <literal>123</literal> and <emphasis remap='I'>length</emphasis> member contains 3.
The object's <emphasis remap='I'>typePtr</emphasis> member is NULL.</para>
<programlisting remap='CS'>
<synopsis>
<emphasis remap='B'>puts "x is $x"</emphasis>
</synopsis>
</programlisting> <!-- remap='CE' -->
<para><emphasis remap='I'>x</emphasis>'s string representation is valid (since <emphasis remap='I'>bytes</emphasis> is non-NULL)
and is fetched for the command.</para>
<programlisting remap='CS'>
<emphasis remap='B'>incr x</emphasis>
</programlisting> <!-- remap='CE' -->
<para>The <emphasis remap='B'>incr</emphasis> command first gets an integer from <emphasis remap='I'>x</emphasis>'s object
by calling <emphasis remap='B'>Tcl_GetIntFromObj</emphasis>.
This procedure checks whether the object is already an integer object.
Since it is not, it converts the object
by setting the object's <emphasis remap='I'>internalRep.longValue</emphasis> member
to the integer <literal>123</literal>
and setting the object's <emphasis remap='I'>typePtr</emphasis>
to point to the integer Tcl_ObjType structure.
Both representations are now valid.
<emphasis remap='B'>incr</emphasis> increments the object's integer internal representation
then invalidates its string representation
(by calling <function>Tcl_InvalidateStringRep</function>)
since the string representation
no longer corresponds to the internal representation.</para>
<programlisting remap='CS'>
<synopsis>
<emphasis remap='B'>puts "x is now $x"</emphasis>
</synopsis>
</programlisting> <!-- remap='CE' -->
<para>The string representation of <emphasis remap='I'>x</emphasis>'s object is needed
and is recomputed.
The string representation is now <literal>124</literal>
and both representations are again valid.</para>
</refsect1>

<refsect1 xml:id='storage_management_of_objects'><title>STORAGE MANAGEMENT OF OBJECTS</title>
<para>Tcl objects are allocated on the heap and are shared as much as possible
to reduce storage requirements.
Reference counting is used to determine when an object is
no longer needed and can safely be freed.
An object just created by <emphasis remap='B'>Tcl_NewObj</emphasis> or <emphasis remap='B'>Tcl_NewStringObj</emphasis>
has <emphasis remap='I'>refCount</emphasis> 0.
The macro <function>Tcl_IncrRefCount</function> increments the reference count
when a new reference to the object is created.
The macro <function>Tcl_DecrRefCount</function> decrements the count
when a reference is no longer needed and,
if the object's reference count drops to zero, frees its storage.
An object shared by different code or data structures has
<emphasis remap='I'>refCount</emphasis> greater than 1.
Incrementing an object's reference count ensures that
it will not be freed too early or have its value change accidentally.</para>

<para>As an example, the bytecode interpreter shares argument objects
between calling and called Tcl procedures to avoid having to copy objects.
It assigns the call's argument objects to the procedure's
formal parameter variables.
In doing so, it calls <function>Tcl_IncrRefCount</function> to increment
the reference count of each argument since there is now a new
reference to it from the formal parameter.
When the called procedure returns,
the interpreter calls <function>Tcl_DecrRefCount</function> to decrement
each argument's reference count.
When an object's reference count drops less than or equal to zero,
<function>Tcl_DecrRefCount</function> reclaims its storage.
Most command procedures do not have to be concerned about
reference counting since they use an object's value immediately
and do not retain a pointer to the object after they return.
However, if they do retain a pointer to an object in a data structure,
they must be careful to increment its reference count
since the retained pointer is a new reference.</para>

<para>Command procedures that directly modify objects
such as those for <emphasis remap='B'>lappend</emphasis> and <emphasis remap='B'>linsert</emphasis> must be careful to
copy a shared object before changing it.
They must first check whether the object is shared
by calling <function>Tcl_IsShared</function>.
If the object is shared they must copy the object
by using <emphasis remap='B'>Tcl_DuplicateObj</emphasis>;
this returns a new duplicate of the original object
that has <emphasis remap='I'>refCount</emphasis> 0.
If the object is not shared,
the command procedure
<quote>owns</quote>
the object and can safely modify it directly.
For example, the following code appears in the command procedure
that implements <emphasis remap='B'>linsert</emphasis>.
This procedure modifies the list object passed to it in <emphasis remap='I'>objv[1]</emphasis>
by inserting <emphasis remap='I'>objc-3</emphasis> new elements before <emphasis remap='I'>index</emphasis>.</para>

<programlisting remap='CS'>
<funcsynopsis>
<funcsynopsisinfo>
listPtr = objv[1];
</funcsynopsisinfo>
</funcsynopsis>
if (Tcl_IsShared(listPtr)) {
    listPtr = Tcl_DuplicateObj(listPtr);
}
result = Tcl_ListObjReplace(interp, listPtr, index, 0,
        (objc-3), &amp;(objv[3]));
</programlisting> <!-- remap='CE' -->
<para>As another example, <emphasis remap='B'>incr</emphasis>'s command procedure
must check whether the variable's object is shared before
incrementing the integer in its internal representation.
If it is shared, it needs to duplicate the object
in order to avoid accidentally changing values in other data structures.</para>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>Tcl_ConvertToT<citerefentry><refentrytitle>ype</refentrytitle><manvolnum>3</manvolnum></citerefentry>, Tcl_GetIntFromO<citerefentry><refentrytitle>bj</refentrytitle><manvolnum>3</manvolnum></citerefentry>, Tcl_ListObjAppendE<citerefentry><refentrytitle>lement</refentrytitle><manvolnum>3</manvolnum></citerefentry>, Tcl_ListObjI<citerefentry><refentrytitle>ndex</refentrytitle><manvolnum>3</manvolnum></citerefentry>, Tcl_ListObjR<citerefentry><refentrytitle>eplace</refentrytitle><manvolnum>3</manvolnum></citerefentry>, Tcl_RegisterObjT<citerefentry><refentrytitle>ype</refentrytitle><manvolnum>3</manvolnum></citerefentry></para>
</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>internal representation, object, object creation, object type, reference counting, string representation, type conversion</para>
</refsect1>
</refentry>

