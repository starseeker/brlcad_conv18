<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='preserve3'>

<!-- '\" Copyright (c) 1990 The Regents of the University of California.
'\" Copyright (c) 1994\-1996 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>7.5</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_Preserve</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>7.5</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_Preserve</refname>
<refname>Tcl_Release</refname>
<refname>Tcl_EventuallyFree</refname>
<refpurpose>avoid freeing storage while it is being used</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef><function>Tcl_Preserve</function></funcdef>
<paramdef><parameter>clientData</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Release</function></funcdef>
<paramdef><parameter>clientData</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_EventuallyFree</function></funcdef>
<paramdef><parameter>clientData</parameter></paramdef>
<paramdef><parameter>freeProc</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tcl_FreeProc clientData -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"ClientData"</entry><entry>"clientData"</entry><entry>"in"</entry>
<entry>
<para>Token describing structure to be freed or reallocated.  Usually a pointer
to memory for structure.</para>
</entry>
</row>
<row><entry>Tcl_FreeProc</entry><entry>*freeProc</entry><entry>in</entry>
<entry>
<para>Procedure to invoke to free <emphasis remap='I'>clientData</emphasis>.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para>These three procedures help implement a simple reference count mechanism
for managing storage.  They are designed to solve a problem
having to do with widget deletion, but are also useful in many other
situations.  When a widget is deleted, its
widget record (the structure holding information specific to the
widget) must be returned to the storage allocator.
However, it is possible that the widget record is in active use
by one of the procedures on the stack at the time of the deletion.
This can happen, for example, if the command associated with a button
widget causes the button to be destroyed:  an X event causes an
event-handling C procedure in the button to be invoked, which in
turn causes the button's associated Tcl command to be executed,
which in turn causes the button to be deleted, which in turn causes
the button's widget record to be de-allocated.
Unfortunately, when the Tcl command returns, the button's
event-handling procedure will need to reference the
button's widget record.
Because of this, the widget record must not be freed as part of the
deletion, but must be retained until the event-handling procedure has
finished with it.
In other situations where the widget is deleted, it may be possible
to free the widget record immediately.</para>

<para><function>Tcl_Preserve</function> and <function>Tcl_Release</function>
implement short-term reference counts for their <emphasis remap='I'>clientData</emphasis>
argument.
The <emphasis remap='I'>clientData</emphasis> argument identifies an object and usually
consists of the address of a structure.
The reference counts guarantee that an object will not be freed
until each call to <function>Tcl_Preserve</function> for the object has been
matched by calls to <function>Tcl_Release</function>.
There may be any number of unmatched <function>Tcl_Preserve</function> calls
in effect at once.</para>

<para><function>Tcl_EventuallyFree</function> is invoked to free up its <emphasis remap='I'>clientData</emphasis>
argument.
It checks to see if there are unmatched <function>Tcl_Preserve</function> calls
for the object.
If not, then <function>Tcl_EventuallyFree</function> calls <emphasis remap='I'>freeProc</emphasis> immediately.
Otherwise <function>Tcl_EventuallyFree</function> records the fact that <emphasis remap='I'>clientData</emphasis>
needs eventually to be freed.
When all calls to <function>Tcl_Preserve</function> have been matched with
calls to <function>Tcl_Release</function> then <emphasis remap='I'>freeProc</emphasis> will be called by
<function>Tcl_Release</function> to do the cleanup.</para>

<para>All the work of freeing the object is carried out by <emphasis remap='I'>freeProc</emphasis>.
<emphasis remap='I'>FreeProc</emphasis> must have arguments and result that match the
type <type>Tcl_FreeProc</type>:</para>
<programlisting remap='CS'>
<funcsynopsis>
<funcsynopsisinfo>
typedef void Tcl_FreeProc(char *blockPtr);
</funcsynopsisinfo>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The <emphasis remap='I'>blockPtr</emphasis> argument to <emphasis remap='I'>freeProc</emphasis> will be the
same as the <emphasis remap='I'>clientData</emphasis> argument to <function>Tcl_EventuallyFree</function>.
The type of <emphasis remap='I'>blockPtr</emphasis> (<emphasis remap='B'>char *</emphasis>) is different than the type of the
<emphasis remap='I'>clientData</emphasis> argument to <function>Tcl_EventuallyFree</function> for historical
reasons, but the value is the same.</para>

<para>When the <emphasis remap='I'>clientData</emphasis> argument to <function>Tcl_EventuallyFree</function>
refers to storage allocated and returned by a prior call to
<emphasis remap='B'>Tcl_Alloc</emphasis>, <emphasis remap='B'>ckalloc</emphasis>, or another function of the Tcl library,
then the <emphasis remap='I'>freeProc</emphasis> argument should be given the special value of
<emphasis remap='B'>TCL_DYNAMIC</emphasis>.</para>

<para>This mechanism can be used to solve the problem described above
by placing <function>Tcl_Preserve</function> and <function>Tcl_Release</function> calls around
actions that may cause undesired storage re-allocation.  The
mechanism is intended only for short-term use (i.e. while procedures
are pending on the stack);  it will not work efficiently as a
mechanism for long-term reference counts.
The implementation does not depend in any way on the internal
structure of the objects being freed;  it keeps the reference
counts in a separate structure.</para>

</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>Tcl_Interp, Tcl_Alloc</para>

</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>free, reference count, storage</para>
</refsect1>
</refentry>

