<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='registerc3'>

<!-- '\" Copyright (c) 1993\-1998  Lucent Technologies, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES. -->

<!-- '\" RCS: $Id$ -->

<refentryinfo><date>3.0</date></refentryinfo>
<refmeta>
<refentrytitle>Itcl_RegisterC</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>3.0</refmiscinfo>
<refmiscinfo class='source'>itcl</refmiscinfo>
<refmiscinfo class='manual'>[incr Tcl] Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Itcl_RegisterC</refname>
<refname>Itcl_RegisterObjC</refname>
<refname>Itcl_FindC</refname>
<refpurpose>Associate a symbolic name with a C procedure.</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;itcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>Itcl_RegisterC</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
<paramdef><parameter>argProc</parameter></paramdef>
<paramdef><parameter>clientData</parameter></paramdef>
<paramdef><parameter>deleteProc</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Itcl_RegisterObjC</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
<paramdef><parameter>objProc</parameter></paramdef>
<paramdef><parameter>clientData</parameter></paramdef>
<paramdef><parameter>deleteProc</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Itcl_FindC</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
<paramdef><parameter>argProcPtr</parameter></paramdef>
<paramdef><parameter>objProcPtr</parameter></paramdef>
<paramdef><parameter>cDataPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<para>Interpreter in which to create new command.</para>
<!-- .VS 8.4 -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"CONST char"</entry><entry>"*cmdName"</entry><entry>"in"</entry>
<entry>
<!-- .VE -->
<para>Name of command.</para>
</entry>
</row>
<row><entry>Tcl_CmdProc</entry><entry>*argProc</entry><entry>in</entry>
<entry>
<para>Implementation of new command:  <emphasis remap='I'>argProc</emphasis> will be called whenever</para>
</entry>
</row>
<row><entry>Tcl_CmdProc</entry><entry>**argProcPtr</entry><entry>in/out</entry>
<entry>
<para>The Tcl_CmdProc * to receive the pointer.</para>
</entry>
</row>
<row><entry>Tcl_ObjCmdProc</entry><entry>*objProc</entry><entry>in</entry>
<entry>
<para>Implementation of the new command: <emphasis remap='I'>objProc</emphasis> will be called whenever</para>
</entry>
</row>
<row><entry>Tcl_ObjCmdProc</entry><entry>**objProcPtr</entry><entry>in/out</entry>
<entry>
<para>The Tcl_ObjCmdProc * to receive the pointer.</para>
</entry>
</row>
<row><entry>ClientData</entry><entry>clientData</entry><entry>in</entry>
<entry>
<para>Arbitrary one-word value to pass to <emphasis remap='I'>proc</emphasis> and <emphasis remap='I'>deleteProc</emphasis>.</para>
</entry>
</row>
<row><entry>ClientData</entry><entry>*cDataPtr</entry><entry>in/out</entry>
<entry>
<para>The ClientData to receive the pointer.</para>
</entry>
</row>
<row><entry>Tcl_CmdDeleteProc</entry><entry>*deleteProc</entry><entry>in</entry>
<entry>
<para>Procedure to call before <emphasis remap='I'>cmdName</emphasis> is deleted from the interpreter;
allows for command-specific cleanup.  If NULL, then no procedure is
called before the command is deleted.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para>Used to associate a symbolic name with an (argc,argv) C procedure
that handles a Tcl command.  Procedures that are registered in this
manner can be referenced in the body of an [incr Tcl] class
definition to specify C procedures to acting as methods/procs.
Usually invoked in an initialization routine for an extension,
called out in Tcl_AppInit() at the start of an application.</para>

<para>Each symbolic procedure can have an arbitrary client data value
associated with it.  This value is passed into the command
handler whenever it is invoked.</para>

<para>A symbolic procedure name can be used only once for a given style
(arg/obj) handler.  If the name is defined with an arg-style
handler, it can be redefined with an obj-style handler; or if
the name is defined with an obj-style handler, it can be redefined
with an arg-style handler.  In either case, any previous client
data is discarded and the new client data is remembered.  However,
if a name is redefined to a different handler of the same style,
this procedure returns an error.</para>

<para>Returns TCL_OK on success, or TCL_ERROR (along with an error message
in interp-&gt;result) if anything goes wrong.</para>

<para>C procedures can be integrated into an <emphasis remap='B'>[incr Tcl]</emphasis> class
definition to implement methods, procs, and the "config" code
for public variables.  Any body that starts with "<emphasis remap='B'>@</emphasis>"
is treated as the symbolic name for a C procedure.</para>

<para>Symbolic names are established by registering procedures via
<emphasis remap='B'>Itcl_RegisterC()</emphasis>.  This is usually done in the <emphasis remap='B'>Tcl_AppInit()</emphasis>
procedure, which is automatically called when the interpreter starts up.
In the following example, the procedure <emphasis remap='C'>My_FooCmd()</emphasis> is registered
with the symbolic name "foo".  This procedure can be referenced in
the <emphasis remap='B'>body</emphasis> command as "<emphasis remap='C'>@foo</emphasis>".</para>
<programlisting remap='CS'>
int
Tcl_AppInit(interp)
    Tcl_Interp *interp;     /* Interpreter for application. */
{
    if (Itcl_Init(interp) == TCL_ERROR) {
<funcsynopsis>
<funcsynopsisinfo>
        return TCL_ERROR;
</funcsynopsisinfo>
</funcsynopsis>
    }

    if (Itcl_RegisterC(interp, "foo", My_FooCmd) != TCL_OK) {
        return TCL_ERROR;
    }
}
</programlisting> <!-- remap='CE' -->
<para>C procedures are implemented just like ordinary Tcl commands.
See the <emphasis remap='B'>CrtCommand</emphasis> man page for details.  Within the procedure,
class data members can be accessed like ordinary variables
using <emphasis remap='B'>Tcl_SetVar()</emphasis>, <emphasis remap='B'>Tcl_GetVar()</emphasis>, <emphasis remap='B'>Tcl_TraceVar()</emphasis>,
etc.  Class methods and procs can be executed like ordinary commands
using <emphasis remap='B'>Tcl_Eval()</emphasis>.  <emphasis remap='B'>[incr Tcl]</emphasis> makes this possible by
automatically setting up the context before executing the C procedure.</para>

<para>This scheme provides a natural migration path for code development.
Classes can be developed quickly using Tcl code to implement the
bodies.  An entire application can be built and tested.  When
necessary, individual bodies can be implemented with C code to
improve performance.</para>

<para>See the Archetype class in <emphasis remap='B'>[incr Tk]</emphasis> for an example of how this
C linking method is used.</para>

</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>Tcl_CreateCommand, Tcl_CreateObjCommand</para>

</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>class, object</para>
</refsect1>
</refentry>

