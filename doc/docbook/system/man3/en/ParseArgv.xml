<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='parseargv3'>

<!-- '\" Copyright (c) 1990\-1992 The Regents of the University of California.
'\" Copyright (c) 1994\-1996 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refmeta>
<refentrytitle>Tk_ParseArgv</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='manual'>Tk</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tk_ParseArgv</refname>
<refpurpose>process command-line options</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tk.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>Tk_ParseArgv</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>tkwin</parameter></paramdef>
<paramdef><parameter>argcPtr</parameter></paramdef>
<paramdef><parameter>argv</parameter></paramdef>
<paramdef><parameter>argTable</parameter></paramdef>
<paramdef><parameter>flags</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tk_ArgvInfo *argTable -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Interp"</entry><entry>"*interp"</entry><entry>"in"</entry>
<entry>
<para>Interpreter to use for returning error messages.</para>
</entry>
</row>
<row><entry>Tk_Window</entry><entry>tkwin</entry><entry>in</entry>
<entry>
<para>Window to use when arguments specify Tk options.  If NULL, then
no Tk options will be processed.</para>
</entry>
</row>
<row><entry>int</entry><entry>argcPtr</entry><entry>in/out</entry>
<entry>
<para>Pointer to number of arguments in argv;  gets modified to hold
number of unprocessed arguments that remain after the call.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>**argv</entry><entry>in/out</entry>
<entry>
<para>Command line arguments passed to main program.  Modified to
hold unprocessed arguments that remain after the call.</para>
</entry>
</row>
<row><entry>Tk_ArgvInfo</entry><entry>*argTable</entry><entry>in</entry>
<entry>
<para>Array of argument descriptors, terminated by element with
type <emphasis remap='B'>TK_ARGV_END</emphasis>.</para>
</entry>
</row>
<row><entry>int</entry><entry>flags</entry><entry>in</entry>
<entry>
<para>If non-zero, then it specifies one or more flags that control the
parsing of arguments.  Different flags may be OR'ed together.
The flags currently defined are <emphasis remap='B'>TK_ARGV_DONT_SKIP_FIRST_ARG</emphasis>,
<emphasis remap='B'>TK_ARGV_NO_ABBREV</emphasis>, <emphasis remap='B'>TK_ARGV_NO_LEFTOVERS</emphasis>, and
<emphasis remap='B'>TK_ARGV_NO_DEFAULTS</emphasis>.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para><function>Tk_ParseArgv</function> processes an array of command-line arguments according
to a table describing the kinds of arguments that are expected.
Each of the arguments in <varname role='parameter'>argv</varname> is processed in turn:  if it matches
one of the entries in <emphasis remap='I'>argTable</emphasis>, the argument is processed
according to that entry and discarded.  The arguments that do not
match anything in <emphasis remap='I'>argTable</emphasis> are copied down to the beginning
of <varname role='parameter'>argv</varname> (retaining their original order) and returned to
the caller.  At the end of the call
<function>Tk_ParseArgv</function> sets <emphasis remap='I'>*argcPtr</emphasis> to hold the number of
arguments that are left in <varname role='parameter'>argv</varname>, and <emphasis remap='I'>argv[*argcPtr]</emphasis>
will hold the value NULL.  Normally, <function>Tk_ParseArgv</function>
assumes that <emphasis remap='I'>argv[0]</emphasis> is a command name, so it is treated like
an argument that does not match <emphasis remap='I'>argTable</emphasis> and returned to the
caller;  however, if the <emphasis remap='B'>TK_ARGV_DONT_SKIP_FIRST_ARG</emphasis> bit is set in
<emphasis remap='I'>flags</emphasis> then <emphasis remap='I'>argv[0]</emphasis> will be processed just like the other
elements of <varname role='parameter'>argv</varname>.</para>

<para><function>Tk_ParseArgv</function> normally returns the value <varname role='parameter'>TCL_OK</varname>.  If an error
occurs while parsing the arguments, then <emphasis remap='B'>TCL_ERROR</emphasis> is returned and
<function>Tk_ParseArgv</function> will leave an error message in <emphasis remap='I'>interp-&gt;result</emphasis>
in the standard Tcl fashion.  In
the event of an error return, <emphasis remap='I'>*argvPtr</emphasis> will not have been
modified, but <varname role='parameter'>argv</varname> could have been partially modified.  The
possible causes of errors are explained below.</para>

<para>The <emphasis remap='I'>argTable</emphasis> array specifies the kinds of arguments that are
expected;  each of its entries has the following structure:</para>
<programlisting remap='CS'>
typedef struct {
    char *<varname role='parameter'>key</varname>;
    int <emphasis remap='I'>type</emphasis>;
    char *<emphasis remap='I'>src</emphasis>;
    char *<varname role='parameter'>dst</varname>;
    char *<emphasis remap='I'>help</emphasis>;
} Tk_ArgvInfo;
</programlisting> <!-- remap='CE' -->
<para>The <varname role='parameter'>key</varname> field is a string such as
<quote>-display</quote>
or
<quote>-bg</quote>
that is compared with the values in <varname role='parameter'>argv</varname>.  <emphasis remap='I'>Type</emphasis>
indicates how to process an argument that matches <varname role='parameter'>key</varname>
(more on this below).  <emphasis remap='I'>Src</emphasis> and <varname role='parameter'>dst</varname> are additional
values used in processing the argument.  Their exact usage
depends on <emphasis remap='I'>type</emphasis>, but typically <emphasis remap='I'>src</emphasis> indicates
a value and <varname role='parameter'>dst</varname> indicates where to store the
value.  The <emphasis remap='B'>char *</emphasis> declarations for <emphasis remap='I'>src</emphasis> and <varname role='parameter'>dst</varname>
are placeholders:  the actual types may be different.  Lastly,
<emphasis remap='I'>help</emphasis> is a string giving a brief description
of this option;  this string is printed when users ask for help
about command-line options.</para>

<para>When processing an argument in <varname role='parameter'>argv</varname>, <function>Tk_ParseArgv</function>
compares the argument to each of the <varname role='parameter'>key</varname>'s in <emphasis remap='I'>argTable</emphasis>.
<function>Tk_ParseArgv</function> selects the first specifier whose <varname role='parameter'>key</varname> matches
the argument exactly, if such a specifier exists.  Otherwise
<function>Tk_ParseArgv</function> selects a specifier for which the argument
is a unique abbreviation.  If the argument is a unique abbreviation
for more than one specifier, then an error is returned.  If there
is no matching entry in <emphasis remap='I'>argTable</emphasis>, then the argument is
skipped and returned to the caller.</para>

<para>Once a matching argument specifier is found, <function>Tk_ParseArgv</function>
processes the argument according to the <emphasis remap='I'>type</emphasis> field of the
specifier.  The argument that matched <varname role='parameter'>key</varname> is called
<quote>the matching argument</quote>
in the descriptions below.  As part of the processing,
<function>Tk_ParseArgv</function> may also use the next argument in <varname role='parameter'>argv</varname>
after the matching argument, which is called
<quote>the following argument</quote>.
The legal values for <emphasis remap='I'>type</emphasis>, and the processing
that they cause, are as follows:</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_END</emphasis></term>
  <listitem>
<para>Marks the end of the table.  The last entry in <emphasis remap='I'>argTable</emphasis>
must have this type;  all of its other fields are ignored and it
will never match any arguments.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_CONSTANT</emphasis></term>
  <listitem>
<para><emphasis remap='I'>Src</emphasis> is treated as an integer and <varname role='parameter'>dst</varname> is treated
as a pointer to an integer.  <emphasis remap='I'>Src</emphasis> is stored at <emphasis remap='I'>*dst</emphasis>.
The matching argument is discarded.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_INT</emphasis></term>
  <listitem>
<para>The following argument must contain an
integer string in the format accepted by <emphasis remap='B'>strtol</emphasis> (e.g.
<quote>0</quote>
and
<quote>0x</quote>
prefixes may be used to specify octal or hexadecimal
numbers, respectively).  <emphasis remap='I'>Dst</emphasis> is treated as a pointer to an
integer;  the following argument is converted to an integer value
and stored at <emphasis remap='I'>*dst</emphasis>.  <emphasis remap='I'>Src</emphasis> is ignored.  The matching
and following arguments are discarded from <varname role='parameter'>argv</varname>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_FLOAT</emphasis></term>
  <listitem>
<para>The following argument must contain a floating-point number in
the format accepted by <emphasis remap='B'>strtol</emphasis>.
<emphasis remap='I'>Dst</emphasis> is treated as the address of a double-precision
floating point value;  the following argument is converted to a
double-precision value and stored at <emphasis remap='I'>*dst</emphasis>.  The matching
and following arguments are discarded from <varname role='parameter'>argv</varname>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_STRING</emphasis></term>
  <listitem>
<para>In this form, <varname role='parameter'>dst</varname> is treated as a pointer to a (char *);
<function>Tk_ParseArgv</function> stores at <emphasis remap='I'>*dst</emphasis> a pointer to the following
argument, and discards the matching and following arguments from
<varname role='parameter'>argv</varname>.  <emphasis remap='I'>Src</emphasis> is ignored.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_UID</emphasis></term>
  <listitem>
<para>This form is similar to <emphasis remap='B'>TK_ARGV_STRING</emphasis>, except that the argument
is turned into a Tk_Uid by calling <emphasis remap='B'>Tk_GetUid</emphasis>.
<emphasis remap='I'>Dst</emphasis> is treated as a pointer to a
Tk_Uid; <function>Tk_ParseArgv</function> stores at <emphasis remap='I'>*dst</emphasis> the Tk_Uid
corresponding to the following
argument, and discards the matching and following arguments from
<varname role='parameter'>argv</varname>.  <emphasis remap='I'>Src</emphasis> is ignored.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_CONST_OPTION</emphasis></term>
  <listitem>
<para>This form causes a Tk option to be set (as if the <emphasis remap='B'>option</emphasis>
command had been invoked).  The <emphasis remap='I'>src</emphasis> field is treated as a
pointer to a string giving the value of an option, and <varname role='parameter'>dst</varname>
is treated as a pointer to the name of the option.  The matching
argument is discarded.  If <emphasis remap='I'>tkwin</emphasis> is NULL, then argument
specifiers of this type are ignored (as if they did not exist).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_OPTION_VALUE</emphasis></term>
  <listitem>
<para>This form is similar to <emphasis remap='B'>TK_ARGV_CONST_OPTION</emphasis>, except that the
value of the option is taken from the following argument instead
of from <emphasis remap='I'>src</emphasis>.  <emphasis remap='I'>Dst</emphasis> is used as the name of the option.
<emphasis remap='I'>Src</emphasis> is ignored.  The matching and following arguments
are discarded.  If <emphasis remap='I'>tkwin</emphasis> is NULL, then argument
specifiers of this type are ignored (as if they did not exist).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_OPTION_NAME_VALUE</emphasis></term>
  <listitem>
<para>In this case the following argument is taken as the name of a Tk
option and the argument after that is taken as the value for that
option.  Both <emphasis remap='I'>src</emphasis> and <varname role='parameter'>dst</varname> are ignored.  All three
arguments are discarded from <varname role='parameter'>argv</varname>.  If <emphasis remap='I'>tkwin</emphasis> is NULL,
then argument
specifiers of this type are ignored (as if they did not exist).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_HELP</emphasis></term>
  <listitem>
<para>When this kind of option is encountered, <function>Tk_ParseArgv</function> uses the
<emphasis remap='I'>help</emphasis> fields of <emphasis remap='I'>argTable</emphasis> to format a message describing
all the valid arguments.  The message is placed in <emphasis remap='I'>interp-&gt;result</emphasis>
and <function>Tk_ParseArgv</function> returns <emphasis remap='B'>TCL_ERROR</emphasis>.  When this happens, the
caller normally prints the help message and aborts.  If the <varname role='parameter'>key</varname>
field of a <emphasis remap='B'>TK_ARGV_HELP</emphasis> specifier is NULL, then the specifier will
never match any arguments;  in this case the specifier simply provides
extra documentation, which will be included when some other
<emphasis remap='B'>TK_ARGV_HELP</emphasis> entry causes help information to be returned.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_REST</emphasis></term>
  <listitem>
<para>This option is used by programs or commands that allow the last
several of their options to be the name and/or options for some
other program.  If a <emphasis remap='B'>TK_ARGV_REST</emphasis> argument is found, then
<function>Tk_ParseArgv</function> does not process any
of the remaining arguments;  it returns them all at
the beginning of <varname role='parameter'>argv</varname> (along with any other unprocessed arguments).
In addition, <function>Tk_ParseArgv</function> treats <varname role='parameter'>dst</varname> as the address of an
integer value, and stores at <emphasis remap='I'>*dst</emphasis> the index of the first of the
<emphasis remap='B'>TK_ARGV_REST</emphasis> options in the returned <varname role='parameter'>argv</varname>.  This allows the
program to distinguish the <emphasis remap='B'>TK_ARGV_REST</emphasis> options from other
unprocessed options that preceded the <emphasis remap='B'>TK_ARGV_REST</emphasis>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_FUNC</emphasis></term>
  <listitem>
<para>For this kind of argument, <emphasis remap='I'>src</emphasis> is treated as the address of
a procedure, which is invoked to process the following argument.
The procedure should have the following structure:</para>
  <blockquote remap='RS'>
<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>int <function>func</function></funcdef>
    <paramdef>char * <parameter>dst</parameter></paramdef>
    <paramdef>char * <parameter>key</parameter></paramdef>
    <paramdef>char * <parameter>nextArg</parameter></paramdef>
</funcprototype>
</funcsynopsis>
{
}
</programlisting> <!-- remap='CE' -->
<para>The <varname role='parameter'>dst</varname> and <varname role='parameter'>key</varname> parameters will contain the
corresponding fields from the <emphasis remap='I'>argTable</emphasis> entry, and
<varname role='parameter'>nextArg</varname> will point to the following argument from <varname role='parameter'>argv</varname>
(or NULL if there are not any more arguments left in <varname role='parameter'>argv</varname>).
If <function>func</function> uses <varname role='parameter'>nextArg</varname> (so that
<function>Tk_ParseArgv</function> should discard it), then it should return 1.  Otherwise it
should return 0 and <emphasis remap='B'>TkParseArgv</emphasis> will process the following
argument in the normal fashion.  In either event the matching argument
is discarded.
    </para></blockquote> <!-- remap='RE' -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_GENFUNC</emphasis></term>
  <listitem>
<para>This form provides a more general procedural escape.  It treats
<emphasis remap='I'>src</emphasis> as the address of a procedure, and passes that procedure
all of the remaining arguments.  The procedure should have the following
form:</para>
  <blockquote remap='RS'>
<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>int <function>genfunc</function></funcdef>
    <paramdef>char * <parameter>dst</parameter></paramdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>char * <parameter>key</parameter></paramdef>
    <paramdef>int <parameter>argc</parameter></paramdef>
    <paramdef>char ** <parameter>argv</parameter></paramdef>
</funcprototype>
</funcsynopsis>
{
}
</programlisting> <!-- remap='CE' -->
<para>The <varname role='parameter'>dst</varname> and <varname role='parameter'>key</varname> parameters will contain the
corresponding fields from the <emphasis remap='I'>argTable</emphasis> entry.  <emphasis remap='I'>Interp</emphasis>
will be the same as the <varname role='parameter'>interp</varname> argument to <emphasis remap='B'>Tcl_ParseArgv</emphasis>.
<emphasis remap='I'>Argc</emphasis> and <varname role='parameter'>argv</varname> refer to all of the options after the
matching one.  <emphasis remap='I'>Genfunc</emphasis> should behave in a fashion similar
to <function>Tk_ParseArgv</function>:  parse as many of the remaining arguments as it can,
then return any that are left by compacting them to the beginning of
<varname role='parameter'>argv</varname> (starting at <varname role='parameter'>argv</varname>[0]).  <emphasis remap='I'>Genfunc</emphasis>
should return a count of how many arguments are left in <varname role='parameter'>argv</varname>;
<function>Tk_ParseArgv</function> will process them.  If <function>genfunc</function> encounters
an error then it should leave an error message in <emphasis remap='I'>interp-&gt;result</emphasis>,
in the usual Tcl fashion, and return -1;  when this happens
<function>Tk_ParseArgv</function> will abort its processing and return <emphasis remap='B'>TCL_ERROR</emphasis>.
    </para></blockquote> <!-- remap='RE' -->
  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 xml:id='flags'><title>FLAGS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_DONT_SKIP_FIRST_ARG</emphasis></term>
  <listitem>
<para><function>Tk_ParseArgv</function> normally treats <emphasis remap='I'>argv[0]</emphasis> as a program
or command name, and returns it to the caller just as if it
had not matched <emphasis remap='I'>argTable</emphasis>.  If this flag is given, then
<emphasis remap='I'>argv[0]</emphasis> is not given special treatment.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_NO_ABBREV</emphasis></term>
  <listitem>
<para>Normally, <function>Tk_ParseArgv</function> accepts unique abbreviations for
<varname role='parameter'>key</varname> values in <emphasis remap='I'>argTable</emphasis>.  If this flag is given then
only exact matches will be acceptable.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_NO_LEFTOVERS</emphasis></term>
  <listitem>
<para>Normally, <function>Tk_ParseArgv</function> returns unrecognized arguments to the
caller.  If this bit is set in <emphasis remap='I'>flags</emphasis> then <function>Tk_ParseArgv</function>
will return an error if it encounters any argument that does not
match <emphasis remap='I'>argTable</emphasis>.  The only exception to this rule is <emphasis remap='I'>argv[0]</emphasis>,
which will be returned to the caller with no errors as
long as <emphasis remap='B'>TK_ARGV_DONT_SKIP_FIRST_ARG</emphasis> is not specified.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TK_ARGV_NO_DEFAULTS</emphasis></term>
  <listitem>
<para>Normally, <function>Tk_ParseArgv</function> searches an internal table of
standard argument specifiers in addition to <emphasis remap='I'>argTable</emphasis>.  If
this bit is set in <emphasis remap='I'>flags</emphasis>, then <function>Tk_ParseArgv</function> will
use only <emphasis remap='I'>argTable</emphasis> and not its default table.</para>
  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 xml:id='example'><title>EXAMPLE</title>
<para>Here is an example definition of an <emphasis remap='I'>argTable</emphasis> and
some sample command lines that use the options.  Note the effect
on <varname role='parameter'>argc</varname> and <varname role='parameter'>argv</varname>;  arguments processed by <function>Tk_ParseArgv</function>
are eliminated from <varname role='parameter'>argv</varname>, and <varname role='parameter'>argc</varname>
is updated to reflect reduced number of arguments.</para>
<programlisting remap='CS'>
<funcsynopsis>
<funcsynopsisinfo>
/* * Define and set default values for globals. */ </funcsynopsisinfo>
<funcsynopsisinfo>
int debugFlag = 0;
int numReps = 100;
char defaultFileName[] = "out";
char *fileName = defaultFileName;
Boolean exec = FALSE;

/* * Define option descriptions. */ </funcsynopsisinfo>
</funcsynopsis>
Tk_ArgvInfo argTable[] = {
    {"-X", TK_ARGV_CONSTANT, (char *) 1, (char *) &amp;debugFlag,
        "Turn on debugging printfs"},
    {"-N", TK_ARGV_INT, (char *) NULL, (char *) &amp;numReps,
        "Number of repetitions"},
    {"-of", TK_ARGV_STRING, (char *) NULL, (char *) &amp;fileName,
        "Name of file for output"},
    {"x", TK_ARGV_REST, (char *) NULL, (char *) &amp;exec,
        "File to exec, followed by any arguments (must be last argument)."},
    {(char *) NULL, TK_ARGV_END, (char *) NULL, (char *) NULL,
        (char *) NULL}
<funcsynopsis>
<funcsynopsisinfo>
};

</funcsynopsisinfo>
<funcprototype>
<funcdef><function>main</function></funcdef>
    <paramdef>int <parameter>argc</parameter></paramdef>
    <paramdef>char * <parameter>argv</parameter>[]</paramdef>
</funcprototype>
</funcsynopsis>
{
    ...

    if (Tk_ParseArgv(interp, tkwin, &amp;argc, argv, argTable, 0) != TCL_OK) {
<funcsynopsis>
<funcprototype>
<funcdef><function>fprintf</function></funcdef>
    <paramdef><parameter>stderr</parameter></paramdef>
    <paramdef><parameter>"%s\n"</parameter></paramdef>
    <paramdef><parameter>interp-&gt;result</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>exit</function></funcdef>
    <paramdef><parameter>1</parameter></paramdef>
</funcprototype>
</funcsynopsis>
    }

    /*
     * Remainder of the program.
     */
}
</programlisting> <!-- remap='CE' -->
<para>Note that default values can be assigned to variables named in
<emphasis remap='I'>argTable</emphasis>:  the variables will only be overwritten if the
particular arguments are present in <varname role='parameter'>argv</varname>.
Here are some example command lines and their effects.</para>
<programlisting remap='CS'>
prog -N 200 infile        # just sets the numReps variable to 200
prog -of out200 infile    # sets fileName to reference "out200"
prog -XN 10 infile        # sets the debug flag, also sets numReps
</programlisting> <!-- remap='CE' -->
<para>In all of the above examples, <varname role='parameter'>argc</varname> will be set by <function>Tk_ParseArgv</function> to 2,
<varname role='parameter'>argv</varname>[0] will be
<quote>prog</quote>,
<varname role='parameter'>argv</varname>[1] will be
<quote>infile</quote>,
and <varname role='parameter'>argv</varname>[2] will be NULL.</para>
</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>arguments, command line, options</para>
</refsect1>
</refentry>

