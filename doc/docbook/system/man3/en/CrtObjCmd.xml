<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='crtobjcmd3'>

<!-- '\" Copyright (c) 1996\-1997 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>8.0</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_CreateObjCommand</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>8.0</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_CreateObjCommand</refname>
<refname>Tcl_DeleteCommand</refname>
<refname>Tcl_DeleteCommandFromToken</refname>
<refname>Tcl_GetCommandInfo</refname>
<refname>Tcl_GetCommandInfoFromToken</refname>
<refname>Tcl_SetCommandInfo</refname>
<refname>Tcl_SetCommandInfoFromToken</refname>
<refname>Tcl_GetCommandName</refname>
<refname>Tcl_GetCommandFullName</refname>
<refname>Tcl_GetCommandFromObj</refname>
<refpurpose>implement new commands in C</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>Tcl_Command <function>Tcl_CreateObjCommand</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
<paramdef><parameter>proc</parameter></paramdef>
<paramdef><parameter>clientData</parameter></paramdef>
<paramdef><parameter>deleteProc</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_DeleteCommand</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_DeleteCommandFromToken</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>token</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetCommandInfo</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
<paramdef><parameter>infoPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_SetCommandInfo</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>cmdName</parameter></paramdef>
<paramdef><parameter>infoPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_GetCommandInfoFromToken</function></funcdef>
<paramdef><parameter>token</parameter></paramdef>
<paramdef><parameter>infoPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_SetCommandInfoFromToken</function></funcdef>
<paramdef><parameter>token</parameter></paramdef>
<paramdef><parameter>infoPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>const char *<function>Tcl_GetCommandName</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>token</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>void <function>Tcl_GetCommandFullName</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>token</parameter></paramdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>Tcl_Command <function>Tcl_GetCommandFromObj</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>objPtr</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tcl_CmdDeleteProc *deleteProc in/out -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Interp"</entry><entry>"*interp"</entry><entry>"in"</entry>
<entry>
<para>Interpreter in which to create a new command or that contains a command.</para>
</entry>
</row>
<row><entry>char</entry><entry>*cmdName</entry><entry>in</entry>
<entry>
<para>Name of command.</para>
</entry>
</row>
<row><entry>Tcl_ObjCmdProc</entry><entry>*proc</entry><entry>in</entry>
<entry>
<para>Implementation of the new command: <emphasis remap='I'>proc</emphasis> will be called whenever
<emphasis remap='I'>cmdName</emphasis> is invoked as a command.</para>
</entry>
</row>
<row><entry>ClientData</entry><entry>clientData</entry><entry>in</entry>
<entry>
<para>Arbitrary one-word value to pass to <emphasis remap='I'>proc</emphasis> and <emphasis remap='I'>deleteProc</emphasis>.</para>
</entry>
</row>
<row><entry>Tcl_CmdDeleteProc</entry><entry>*deleteProc</entry><entry>in</entry>
<entry>
<para>Procedure to call before <emphasis remap='I'>cmdName</emphasis> is deleted from the interpreter;
allows for command-specific cleanup. If NULL, then no procedure is
called before the command is deleted.</para>
</entry>
</row>
<row><entry>Tcl_Command</entry><entry>token</entry><entry>in</entry>
<entry>
<para>Token for command, returned by previous call to <function>Tcl_CreateObjCommand</function>.
The command must not have been deleted.</para>
</entry>
</row>
<row><entry>Tcl_CmdInfo</entry><entry>*infoPtr</entry><entry>in/out</entry>
<entry>
<para>Pointer to structure containing various information about a
Tcl command.</para>
</entry>
</row>
<row><entry>Tcl_Obj</entry><entry>*objPtr</entry><entry>in</entry>
<entry>
<para>Object containing the name of a Tcl command.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para><function>Tcl_CreateObjCommand</function> defines a new command in <varname role='parameter'>interp</varname>
and associates it with procedure <emphasis remap='I'>proc</emphasis>
such that whenever <emphasis remap='I'>name</emphasis> is
invoked as a Tcl command (e.g., via a call to <emphasis remap='B'>Tcl_EvalObjEx</emphasis>)
the Tcl interpreter will call <emphasis remap='I'>proc</emphasis> to process the command.</para>

<para><function>Tcl_CreateObjCommand</function> deletes any existing command
<emphasis remap='I'>name</emphasis> already associated with the interpreter
(however see below for an exception where the existing command
is not deleted).
It returns a token that may be used to refer
to the command in subsequent calls to <function>Tcl_GetCommandName</function>.
If <emphasis remap='I'>name</emphasis> contains any <emphasis remap='B'>::</emphasis> namespace qualifiers,
then the command is added to the specified namespace;
otherwise the command is added to the global namespace.
If <function>Tcl_CreateObjCommand</function> is called for an interpreter that is in
the process of being deleted, then it does not create a new command
and it returns NULL.
<emphasis remap='I'>proc</emphasis> should have arguments and result that match the type
<type>Tcl_ObjCmdProc</type>:</para>
<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef int <function>Tcl_ObjCmdProc</function></funcdef>
    <paramdef>ClientData <parameter>clientData</parameter></paramdef>
    <paramdef>Tcl_Interp * <parameter>interp</parameter></paramdef>
    <paramdef>int <parameter>objc</parameter></paramdef>
    <paramdef>Tcl_Obj *const <parameter>objv</parameter>[]</paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>When <emphasis remap='I'>proc</emphasis> is invoked, the <varname role='parameter'>clientData</varname> and <varname role='parameter'>interp</varname> parameters
will be copies of the <varname role='parameter'>clientData</varname> and <varname role='parameter'>interp</varname> arguments given to
<function>Tcl_CreateObjCommand</function>.  Typically, <varname role='parameter'>clientData</varname> points to an
application-specific data structure that describes what to do when the
command procedure is invoked. <emphasis remap='I'>Objc</emphasis> and <varname role='parameter'>objv</varname> describe the
arguments to the command, <varname role='parameter'>objc</varname> giving the number of argument objects
(including the command name) and <varname role='parameter'>objv</varname> giving the values of the
arguments.  The <varname role='parameter'>objv</varname> array will contain <varname role='parameter'>objc</varname> values, pointing to
the argument objects.  Unlike <emphasis remap='I'>argv</emphasis>[<emphasis remap='I'>argv</emphasis>] used in a
string-based command procedure, <varname role='parameter'>objv</varname>[<varname role='parameter'>objc</varname>] will not contain NULL.</para>

<para>Additionally, when <emphasis remap='I'>proc</emphasis> is invoked, it must not modify the contents
of the <varname role='parameter'>objv</varname> array by assigning new pointer values to any element of the
array (for example, <varname role='parameter'>objv</varname>[<literal>2</literal>] = <emphasis remap='B'>NULL</emphasis>) because this will
cause memory to be lost and the runtime stack to be corrupted.  The
<emphasis remap='B'>const</emphasis> in the declaration of <varname role='parameter'>objv</varname> will cause ANSI-compliant
compilers to report any such attempted assignment as an error.  However,
it is acceptable to modify the internal representation of any individual
object argument.  For instance, the user may call
<emphasis remap='B'>Tcl_GetIntFromObj</emphasis> on <varname role='parameter'>objv</varname>[<literal>2</literal>] to obtain the integer
representation of that object; that call may change the type of the object
that <varname role='parameter'>objv</varname>[<literal>2</literal>] points at, but will not change where
<varname role='parameter'>objv</varname>[<literal>2</literal>] points.</para>

<para><emphasis remap='I'>proc</emphasis> must return an integer code that is either <emphasis remap='B'>TCL_OK</emphasis>,
<emphasis remap='B'>TCL_ERROR</emphasis>, <emphasis remap='B'>TCL_RETURN</emphasis>, <emphasis remap='B'>TCL_BREAK</emphasis>, or <emphasis remap='B'>TCL_CONTINUE</emphasis>.
See the Tcl overview man page
for details on what these codes mean.  Most normal commands will only
return <emphasis remap='B'>TCL_OK</emphasis> or <emphasis remap='B'>TCL_ERROR</emphasis>.
In addition, if <emphasis remap='I'>proc</emphasis> needs to return a non-empty result,
it can call <emphasis remap='B'>Tcl_SetObjResult</emphasis> to set the interpreter's result.
In the case of a <emphasis remap='B'>TCL_OK</emphasis> return code this gives the result
of the command,
and in the case of <emphasis remap='B'>TCL_ERROR</emphasis> this gives an error message.
Before invoking a command procedure,
<emphasis remap='B'>Tcl_EvalObjEx</emphasis> sets interpreter's result to
point to an object representing an empty string, so simple
commands can return an empty result by doing nothing at all.</para>

<para>The contents of the <varname role='parameter'>objv</varname> array belong to Tcl and are not
guaranteed to persist once <emphasis remap='I'>proc</emphasis> returns: <emphasis remap='I'>proc</emphasis> should
not modify them.
Call <emphasis remap='B'>Tcl_SetObjResult</emphasis> if you want
to return something from the <varname role='parameter'>objv</varname> array.</para>

<para>Ordinarily, <function>Tcl_CreateObjCommand</function> deletes any existing command
<emphasis remap='I'>name</emphasis> already associated with the interpreter.
However, if the existing command was created by a previous call to
<emphasis remap='B'>Tcl_CreateCommand</emphasis>,
<function>Tcl_CreateObjCommand</function> does not delete the command
but instead arranges for the Tcl interpreter to call the
<type>Tcl_ObjCmdProc</type> <emphasis remap='I'>proc</emphasis> in the future.
The old string-based <emphasis remap='B'>Tcl_CmdProc</emphasis> associated with the command
is retained and its address can be obtained by subsequent 
<function>Tcl_GetCommandInfo</function> calls. This is done for backwards compatibility.</para>

<para><emphasis remap='I'>DeleteProc</emphasis> will be invoked when (if) <emphasis remap='I'>name</emphasis> is deleted.
This can occur through a call to <function>Tcl_DeleteCommand</function>,
<function>Tcl_DeleteCommandFromToken</function>, or <emphasis remap='B'>Tcl_DeleteInterp</emphasis>,
or by replacing <emphasis remap='I'>name</emphasis> in another call to <function>Tcl_CreateObjCommand</function>.
<emphasis remap='I'>DeleteProc</emphasis> is invoked before the command is deleted, and gives the
application an opportunity to release any structures associated
with the command.  <emphasis remap='I'>DeleteProc</emphasis> should have arguments and
result that match the type <type>Tcl_CmdDeleteProc</type>:</para>
<programlisting remap='CS'>
<funcsynopsis>
<funcprototype>
<funcdef>typedef void <function>Tcl_CmdDeleteProc</function></funcdef>
    <paramdef>ClientData <parameter>clientData</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</programlisting> <!-- remap='CE' -->
<para>The <varname role='parameter'>clientData</varname> argument will be the same as the <varname role='parameter'>clientData</varname>
argument passed to <function>Tcl_CreateObjCommand</function>.</para>

<para><function>Tcl_DeleteCommand</function> deletes a command from a command interpreter.
Once the call completes, attempts to invoke <emphasis remap='I'>cmdName</emphasis> in
<varname role='parameter'>interp</varname> will result in errors.
If <emphasis remap='I'>cmdName</emphasis> is not bound as a command in <varname role='parameter'>interp</varname> then
<function>Tcl_DeleteCommand</function> does nothing and returns -1;  otherwise
it returns 0.
There are no restrictions on <emphasis remap='I'>cmdName</emphasis>:  it may refer to
a built-in command, an application-specific command, or a Tcl procedure.
If <emphasis remap='I'>name</emphasis> contains any <emphasis remap='B'>::</emphasis> namespace qualifiers,
the command is deleted from the specified namespace.</para>

<para>Given a token returned by <function>Tcl_CreateObjCommand</function>,
<function>Tcl_DeleteCommandFromToken</function> deletes the command
from a command interpreter.
It will delete a command even if that command has been renamed.
Once the call completes, attempts to invoke the command in
<varname role='parameter'>interp</varname> will result in errors.
If the command corresponding to <emphasis remap='I'>token</emphasis>
has already been deleted from <varname role='parameter'>interp</varname> then
<function>Tcl_DeleteCommand</function> does nothing and returns -1;
otherwise it returns 0.</para>

<para><function>Tcl_GetCommandInfo</function> checks to see whether its <emphasis remap='I'>cmdName</emphasis> argument
exists as a command in <varname role='parameter'>interp</varname>.
<emphasis remap='I'>cmdName</emphasis> may include <emphasis remap='B'>::</emphasis> namespace qualifiers
to identify a command in a particular namespace.
If the command is not found, then it returns 0.
Otherwise it places information about the command
in the <type>Tcl_CmdInfo</type> structure
pointed to by <emphasis remap='I'>infoPtr</emphasis> and returns 1.
A <type>Tcl_CmdInfo</type> structure has the following fields:</para>
<programlisting remap='CS'>
typedef struct Tcl_CmdInfo {
    int <emphasis remap='I'>isNativeObjectProc</emphasis>;
    Tcl_ObjCmdProc *<emphasis remap='I'>objProc</emphasis>;
    ClientData <emphasis remap='I'>objClientData</emphasis>;
    Tcl_CmdProc *<emphasis remap='I'>proc</emphasis>;
    ClientData <varname role='parameter'>clientData</varname>;
    Tcl_CmdDeleteProc *<emphasis remap='I'>deleteProc</emphasis>;
    ClientData <emphasis remap='I'>deleteData</emphasis>;
    Tcl_Namespace *<emphasis remap='I'>namespacePtr</emphasis>;
} Tcl_CmdInfo;
</programlisting> <!-- remap='CE' -->
<para>The <emphasis remap='I'>isNativeObjectProc</emphasis> field has the value 1
if <function>Tcl_CreateObjCommand</function> was called to register the command;
it is 0 if only <emphasis remap='B'>Tcl_CreateCommand</emphasis> was called.
It allows a program to determine whether it is faster to
call <emphasis remap='I'>objProc</emphasis> or <emphasis remap='I'>proc</emphasis>:
<emphasis remap='I'>objProc</emphasis> is normally faster
if <emphasis remap='I'>isNativeObjectProc</emphasis> has the value 1.
The fields <emphasis remap='I'>objProc</emphasis> and <emphasis remap='I'>objClientData</emphasis>
have the same meaning as the <emphasis remap='I'>proc</emphasis> and <varname role='parameter'>clientData</varname>
arguments to <function>Tcl_CreateObjCommand</function>;
they hold information about the object-based command procedure
that the Tcl interpreter calls to implement the command.
The fields <emphasis remap='I'>proc</emphasis> and <varname role='parameter'>clientData</varname>
hold information about the string-based command procedure
that implements the command.
If <emphasis remap='B'>Tcl_CreateCommand</emphasis> was called for this command,
this is the procedure passed to it;
otherwise, this is a compatibility procedure
registered by <function>Tcl_CreateObjCommand</function>
that simply calls the command's
object-based procedure after converting its string arguments to Tcl objects.
The field <emphasis remap='I'>deleteData</emphasis> is the ClientData value
to pass to <emphasis remap='I'>deleteProc</emphasis>;  it is normally the same as
<varname role='parameter'>clientData</varname> but may be set independently using the
<function>Tcl_SetCommandInfo</function> procedure.
The field <emphasis remap='I'>namespacePtr</emphasis> holds a pointer to the
Tcl_Namespace that contains the command.</para>

<para><function>Tcl_GetCommandInfoFromToken</function> is identical to
<function>Tcl_GetCommandInfo</function> except that it uses a command token returned
from <function>Tcl_CreateObjCommand</function> in place of the command name.  If the
<emphasis remap='I'>token</emphasis> parameter is NULL, it returns 0; otherwise, it returns 1
and fills in the structure designated by <emphasis remap='I'>infoPtr</emphasis>.</para>

<para><function>Tcl_SetCommandInfo</function> is used to modify the procedures and
ClientData values associated with a command.
Its <emphasis remap='I'>cmdName</emphasis> argument is the name of a command in <varname role='parameter'>interp</varname>.
<emphasis remap='I'>cmdName</emphasis> may include <emphasis remap='B'>::</emphasis> namespace qualifiers
to identify a command in a particular namespace.
If this command does not exist then <function>Tcl_SetCommandInfo</function> returns 0.
Otherwise, it copies the information from <emphasis remap='I'>*infoPtr</emphasis> to
Tcl's internal structure for the command and returns 1.</para>

<para><function>Tcl_SetCommandInfoFromToken</function> is identical to
<function>Tcl_SetCommandInfo</function> except that it takes a command token as
returned by <function>Tcl_CreateObjCommand</function> instead of the command name.
If the <emphasis remap='I'>token</emphasis> parameter is NULL, it returns 0.  Otherwise, it
copies the information from <emphasis remap='I'>*infoPtr</emphasis> to Tcl's internal structure
for the command and returns 1.</para>

<para>Note that <function>Tcl_SetCommandInfo</function> and
<function>Tcl_SetCommandInfoFromToken</function> both allow the ClientData for a
command's deletion procedure to be given a different value than the
ClientData for its command procedure.</para>

<para>Note that neither <function>Tcl_SetCommandInfo</function> nor
<function>Tcl_SetCommandInfoFromToken</function> will change a command's namespace.
Use <emphasis remap='B'>Tcl_Eval</emphasis> to call the <emphasis remap='B'>rename</emphasis> command to do that.</para>

<para><function>Tcl_GetCommandName</function> provides a mechanism for tracking commands
that have been renamed.
Given a token returned by <function>Tcl_CreateObjCommand</function>
when the command was created, <function>Tcl_GetCommandName</function> returns the
string name of the command.  If the command has been renamed since it
was created, then <function>Tcl_GetCommandName</function> returns the current name.
This name does not include any <emphasis remap='B'>::</emphasis> namespace qualifiers.
The command corresponding to <emphasis remap='I'>token</emphasis> must not have been deleted.
The string returned by <function>Tcl_GetCommandName</function> is in dynamic memory
owned by Tcl and is only guaranteed to retain its value as long as the
command is not deleted or renamed;  callers should copy the string if
they need to keep it for a long time.</para>

<para><function>Tcl_GetCommandFullName</function> produces the fully qualified name
of a command from a command token.  
The name, including all namespace prefixes,
is appended to the object specified by <emphasis remap='I'>objPtr</emphasis>.</para>

<para><function>Tcl_GetCommandFromObj</function> returns a token for the command
specified by the name in a <type>Tcl_Obj</type>.
The command name is resolved relative to the current namespace.
Returns NULL if the command is not found.</para>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para>Tcl_CreateCommand, Tcl_ResetResult, Tcl_SetObjResult</para>

</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>bind, command, create, delete, namespace, object</para>
</refsect1>
</refentry>

