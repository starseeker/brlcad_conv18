<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man+tkman by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='parsecmd3'>

<!-- '\" Copyright (c) 1997 Sun Microsystems, Inc. -->

<!-- '\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\"  -->
<refentryinfo><date>8.3</date></refentryinfo>
<refmeta>
<refentrytitle>Tcl_ParseCommand</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>8.3</refmiscinfo>
<refmiscinfo class='source'>Tcl</refmiscinfo>
<refmiscinfo class='manual'>Tcl Library Procedures</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Tcl_ParseCommand</refname>
<refname>Tcl_ParseExpr</refname>
<refname>Tcl_ParseBraces</refname>
<refname>Tcl_ParseQuotedString</refname>
<refname>Tcl_ParseVarName</refname>
<refname>Tcl_ParseVar</refname>
<refname>Tcl_FreeParse</refname>
<refname>Tcl_EvalTokens</refname>
<refname>Tcl_EvalTokensStandard</refname>
<refpurpose>parse Tcl scripts and expressions</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;tcl.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>Tcl_ParseCommand</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>start</parameter></paramdef>
<paramdef><parameter>numBytes</parameter></paramdef>
<paramdef><parameter>nested</parameter></paramdef>
<paramdef><parameter>parsePtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ParseExpr</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>start</parameter></paramdef>
<paramdef><parameter>numBytes</parameter></paramdef>
<paramdef><parameter>parsePtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ParseBraces</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>start</parameter></paramdef>
<paramdef><parameter>numBytes</parameter></paramdef>
<paramdef><parameter>parsePtr</parameter></paramdef>
<paramdef><parameter>append</parameter></paramdef>
<paramdef><parameter>termPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ParseQuotedString</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>start</parameter></paramdef>
<paramdef><parameter>numBytes</parameter></paramdef>
<paramdef><parameter>parsePtr</parameter></paramdef>
<paramdef><parameter>append</parameter></paramdef>
<paramdef><parameter>termPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_ParseVarName</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>start</parameter></paramdef>
<paramdef><parameter>numBytes</parameter></paramdef>
<paramdef><parameter>parsePtr</parameter></paramdef>
<paramdef><parameter>append</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>const char *<function>Tcl_ParseVar</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>start</parameter></paramdef>
<paramdef><parameter>termPtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_FreeParse</function></funcdef>
<paramdef><parameter>usedParsePtr</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef><function>Tcl_Obj</function> *Tcl_EvalTokens</funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>tokenPtr</parameter></paramdef>
<paramdef><parameter>numTokens</parameter></paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function>Tcl_EvalTokensStandard</function></funcdef>
<paramdef><parameter>interp</parameter></paramdef>
<paramdef><parameter>tokenPtr</parameter></paramdef>
<paramdef><parameter>numTokens</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='arguments'><title>ARGUMENTS</title>
<!-- .AS Tcl_Interp *usedParsePtr out -->
<informaltable>
<tgroup cols='3'>
<tbody>

<row><entry>"Tcl_Interp"</entry><entry>"*interp"</entry><entry>"out"</entry>
<entry>
<para>For procedures other than <function>Tcl_FreeParse</function>, <emphasis remap='B'>Tcl_EvalTokens</emphasis>
and <function>Tcl_EvalTokensStandard</function>, used only for error reporting;
if NULL, then no error messages are left after errors.
For <emphasis remap='B'>Tcl_EvalTokens</emphasis> and <function>Tcl_EvalTokensStandard</function>,
determines the context for evaluating the
script and also is used for error reporting; must not be NULL.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>*start</entry><entry>in</entry>
<entry>
<para>Pointer to first character in string to parse.</para>
</entry>
</row>
<row><entry>int</entry><entry>numBytes</entry><entry>in</entry>
<entry>
<para>Number of bytes in string to parse, not including any terminating null
character.  If less than 0 then the script consists of all characters
following <emphasis remap='I'>start</emphasis> up to the first null character.</para>
</entry>
</row>
<row><entry>int</entry><entry>nested</entry><entry>in</entry>
<entry>
<para>Non-zero means that the script is part of a command substitution so an
unquoted close bracket should be treated as a command terminator.  If zero,
close brackets have no special meaning.</para> 
</entry>
</row>
<row><entry>int</entry><entry>append</entry><entry>in</entry>
<entry>
<para>Non-zero means that <emphasis remap='I'>*parsePtr</emphasis> already contains valid tokens; the new
tokens should be appended to those already present.  Zero means that
<emphasis remap='I'>*parsePtr</emphasis> is uninitialized; any information in it is ignored.
This argument is normally 0.</para>
</entry>
</row>
<row><entry>Tcl_Parse</entry><entry>*parsePtr</entry><entry>out</entry>
<entry>
<para>Points to structure to fill in with information about the parsed
command, expression, variable name, etc.
Any previous information in this structure
is ignored, unless <emphasis remap='I'>append</emphasis> is non-zero in a call to
<function>Tcl_ParseBraces</function>, <function>Tcl_ParseQuotedString</function>,
or <function>Tcl_ParseVarName</function>.</para>
</entry>
</row>
<row><entry>"const char"</entry><entry>**termPtr</entry><entry>out</entry>
<entry>
<para>If not NULL, points to a location where
<function>Tcl_ParseBraces</function>, <function>Tcl_ParseQuotedString</function>, and
<function>Tcl_ParseVar</function> will store a pointer to the character
just after the terminating character (the close-brace, the last
character of the variable name, or the close-quote (respectively))
if the parse was successful.</para>
</entry>
</row>
<row><entry>Tcl_Parse</entry><entry>*usedParsePtr</entry><entry>in</entry>
<entry>
<para>Points to structure that was filled in by a previous call to
<function>Tcl_ParseCommand</function>, <function>Tcl_ParseExpr</function>, <function>Tcl_ParseVarName</function>, etc.</para>
<!-- .BE -->
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</refsect1>

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para>These procedures parse Tcl commands or portions of Tcl commands such as
expressions or references to variables.
Each procedure takes a pointer to a script (or portion thereof)
and fills in the structure pointed to by <emphasis remap='I'>parsePtr</emphasis>
with a collection of tokens describing the information that was parsed.
The procedures normally return <emphasis remap='B'>TCL_OK</emphasis>.
However, if an error occurs then they return <emphasis remap='B'>TCL_ERROR</emphasis>,
leave an error message in <emphasis remap='I'>interp</emphasis>'s result
(if <emphasis remap='I'>interp</emphasis> is not NULL),
and leave nothing in <emphasis remap='I'>parsePtr</emphasis>.</para>

<para><function>Tcl_ParseCommand</function> is a procedure that parses Tcl
scripts.  Given a pointer to a script, it
parses the first command from the script.  If the command was parsed
successfully, <function>Tcl_ParseCommand</function> returns <emphasis remap='B'>TCL_OK</emphasis> and fills in the
structure pointed to by <emphasis remap='I'>parsePtr</emphasis> with information about the
structure of the command (see below for details).
If an error occurred in parsing the command then
<emphasis remap='B'>TCL_ERROR</emphasis> is returned, an error message is left in <emphasis remap='I'>interp</emphasis>'s
result, and no information is left at <emphasis remap='I'>*parsePtr</emphasis>.</para>

<para><function>Tcl_ParseExpr</function> parses Tcl expressions.
Given a pointer to a script containing an expression,
<function>Tcl_ParseExpr</function> parses the expression.
If the expression was parsed successfully,
<function>Tcl_ParseExpr</function> returns <emphasis remap='B'>TCL_OK</emphasis> and fills in the
structure pointed to by <emphasis remap='I'>parsePtr</emphasis> with information about the
structure of the expression (see below for details).
If an error occurred in parsing the command then
<emphasis remap='B'>TCL_ERROR</emphasis> is returned, an error message is left in <emphasis remap='I'>interp</emphasis>'s
result, and no information is left at <emphasis remap='I'>*parsePtr</emphasis>.</para>

<para><function>Tcl_ParseBraces</function> parses a string or command argument
enclosed in braces such as
<emphasis remap='B'>{hello}</emphasis> or <emphasis remap='B'>{string \t with \t tabs}</emphasis>
from the beginning of its argument <emphasis remap='I'>start</emphasis>.
The first character of <emphasis remap='I'>start</emphasis> must be <emphasis remap='B'>{</emphasis>. 
If the braced string was parsed successfully,
<function>Tcl_ParseBraces</function> returns <emphasis remap='B'>TCL_OK</emphasis>,
fills in the structure pointed to by <emphasis remap='I'>parsePtr</emphasis>
with information about the structure of the string
(see below for details),
and stores a pointer to the character just after the terminating <emphasis remap='B'>}</emphasis>
in the location given by <emphasis remap='I'>*termPtr</emphasis>.
If an error occurs while parsing the string
then <emphasis remap='B'>TCL_ERROR</emphasis> is returned,
an error message is left in <emphasis remap='I'>interp</emphasis>'s result,
and no information is left at <emphasis remap='I'>*parsePtr</emphasis> or <emphasis remap='I'>*termPtr</emphasis>.</para>

<para><function>Tcl_ParseQuotedString</function> parses a double-quoted string such as
<emphasis remap='B'>"sum is [expr {$a+$b}]"</emphasis>
from the beginning of the argument <emphasis remap='I'>start</emphasis>.
The first character of <emphasis remap='I'>start</emphasis> must be <emphasis remap='B'>"</emphasis>. 
If the double-quoted string was parsed successfully,
<function>Tcl_ParseQuotedString</function> returns <emphasis remap='B'>TCL_OK</emphasis>,
fills in the structure pointed to by <emphasis remap='I'>parsePtr</emphasis>
with information about the structure of the string
(see below for details),
and stores a pointer to the character just after the terminating <emphasis remap='B'>"</emphasis>
in the location given by <emphasis remap='I'>*termPtr</emphasis>.
If an error occurs while parsing the string
then <emphasis remap='B'>TCL_ERROR</emphasis> is returned,
an error message is left in <emphasis remap='I'>interp</emphasis>'s result,
and no information is left at <emphasis remap='I'>*parsePtr</emphasis> or <emphasis remap='I'>*termPtr</emphasis>.</para>

<para><function>Tcl_ParseVarName</function> parses a Tcl variable reference such as
<emphasis remap='B'>$abc</emphasis> or <emphasis remap='B'>$x([expr {$index + 1}])</emphasis> from the beginning of its
<emphasis remap='I'>start</emphasis> argument.
The first character of <emphasis remap='I'>start</emphasis> must be <emphasis remap='B'>$</emphasis>. 
If a variable name was parsed successfully, <function>Tcl_ParseVarName</function>
returns <emphasis remap='B'>TCL_OK</emphasis> and fills in the structure pointed to by
<emphasis remap='I'>parsePtr</emphasis> with information about the structure of the variable name
(see below for details).  If an error
occurs while parsing the command then <emphasis remap='B'>TCL_ERROR</emphasis> is returned, an
error message is left in <emphasis remap='I'>interp</emphasis>'s result (if <emphasis remap='I'>interp</emphasis> is not
NULL), and no information is left at <emphasis remap='I'>*parsePtr</emphasis>.</para>

<para><function>Tcl_ParseVar</function> parse a Tcl variable reference such as <emphasis remap='B'>$abc</emphasis>
or <emphasis remap='B'>$x([expr {$index + 1}])</emphasis> from the beginning of its <emphasis remap='I'>start</emphasis>
argument.  The first character of <emphasis remap='I'>start</emphasis> must be <emphasis remap='B'>$</emphasis>.  If
the variable name is parsed successfully, <function>Tcl_ParseVar</function> returns a
pointer to the string value of the variable.  If an error occurs while
parsing, then NULL is returned and an error message is left in
<emphasis remap='I'>interp</emphasis>'s result.</para>

<para>The information left at <emphasis remap='I'>*parsePtr</emphasis>
by <function>Tcl_ParseCommand</function>, <function>Tcl_ParseExpr</function>, <function>Tcl_ParseBraces</function>,
<function>Tcl_ParseQuotedString</function>, and <function>Tcl_ParseVarName</function>
may include dynamically allocated memory.
If these five parsing procedures return <emphasis remap='B'>TCL_OK</emphasis>
then the caller must invoke <function>Tcl_FreeParse</function> to release
the storage at <emphasis remap='I'>*parsePtr</emphasis>.
These procedures ignore any existing information in
<emphasis remap='I'>*parsePtr</emphasis> (unless <emphasis remap='I'>append</emphasis> is non-zero),
so if repeated calls are being made to any of them
then <function>Tcl_FreeParse</function> must be invoked once after each call.</para>

<para><function>Tcl_EvalTokensStandard</function> evaluates a sequence of parse tokens from
a Tcl_Parse structure.  The tokens typically consist
of all the tokens in a word or all the tokens that make up the index for
a reference to an array variable.  <function>Tcl_EvalTokensStandard</function> performs the
substitutions requested by the tokens and concatenates the
resulting values. 
The return value from <function>Tcl_EvalTokensStandard</function> is a Tcl completion
code with one of the values <emphasis remap='B'>TCL_OK</emphasis>, <emphasis remap='B'>TCL_ERROR</emphasis>,
<emphasis remap='B'>TCL_RETURN</emphasis>, <emphasis remap='B'>TCL_BREAK</emphasis>, or <emphasis remap='B'>TCL_CONTINUE</emphasis>, or possibly
some other integer value originating in an extension.
In addition, a result value or error message is left in <emphasis remap='I'>interp</emphasis>'s
result; it can be retrieved using <emphasis remap='B'>Tcl_GetObjResult</emphasis>.</para>

<para><emphasis remap='B'>Tcl_EvalTokens</emphasis> differs from <function>Tcl_EvalTokensStandard</function> only in
the return convention used: it returns the result in a new Tcl_Obj.
The reference count of the object returned as result has been
incremented, so the caller must
invoke <emphasis remap='B'>Tcl_DecrRefCount</emphasis> when it is finished with the object.
If an error or other exception occurs while evaluating the tokens
(such as a reference to a non-existent variable) then the return value
is NULL and an error message is left in <emphasis remap='I'>interp</emphasis>'s result. The use
of <emphasis remap='B'>Tcl_EvalTokens</emphasis> is deprecated.</para>

</refsect1>

<refsect1 xml:id='tcl_parse_structure'><title>TCL_PARSE STRUCTURE</title>
<para><function>Tcl_ParseCommand</function>, <function>Tcl_ParseExpr</function>, <function>Tcl_ParseBraces</function>,
<function>Tcl_ParseQuotedString</function>, and <function>Tcl_ParseVarName</function>
return parse information in two data structures, Tcl_Parse and Tcl_Token:</para>
<programlisting remap='CS'>
typedef struct Tcl_Parse {
        const char *<emphasis remap='I'>commentStart</emphasis>;
        int <emphasis remap='I'>commentSize</emphasis>;
        const char *<emphasis remap='I'>commandStart</emphasis>;
        int <emphasis remap='I'>commandSize</emphasis>;
        int <emphasis remap='I'>numWords</emphasis>;
        Tcl_Token *<emphasis remap='I'>tokenPtr</emphasis>;
        int <emphasis remap='I'>numTokens</emphasis>;
        ...
} Tcl_Parse;

typedef struct Tcl_Token {
        int <emphasis remap='I'>type</emphasis>;
        const char *<emphasis remap='I'>start</emphasis>;
        int <emphasis remap='I'>size</emphasis>;
        int <emphasis remap='I'>numComponents</emphasis>;
} Tcl_Token;
</programlisting> <!-- remap='CE' -->

<para>The first five fields of a Tcl_Parse structure
are filled in only by <function>Tcl_ParseCommand</function>.
These fields are not used by the other parsing procedures.</para>

<para><function>Tcl_ParseCommand</function> fills in a Tcl_Parse structure
with information that describes one Tcl command and any comments that
precede the command.
If there are comments,
the <emphasis remap='I'>commentStart</emphasis> field points to the <emphasis remap='B'>#</emphasis> character that begins
the first comment and <emphasis remap='I'>commentSize</emphasis> indicates the number of bytes
in all of the comments preceding the command, including the newline
character that terminates the last comment.
If the command is not preceded by any comments, <emphasis remap='I'>commentSize</emphasis> is 0.
<function>Tcl_ParseCommand</function> also sets the <emphasis remap='I'>commandStart</emphasis> field
to point to the first character of the first
word in the command (skipping any comments and leading space) and 
<emphasis remap='I'>commandSize</emphasis> gives the total number of bytes in the command,
including the character pointed to by <emphasis remap='I'>commandStart</emphasis> up to and
including the newline, close bracket, or semicolon character that
terminates the command.  The <emphasis remap='I'>numWords</emphasis> field gives the
total number of words in the command.</para>

<para>All parsing procedures set the remaining fields,
<emphasis remap='I'>tokenPtr</emphasis> and <emphasis remap='I'>numTokens</emphasis>.
The <emphasis remap='I'>tokenPtr</emphasis> field points to the first in an array of Tcl_Token
structures that describe the components of the entity being parsed.
The <emphasis remap='I'>numTokens</emphasis> field gives the total number of tokens
present in the array.
Each token contains four fields.
The <emphasis remap='I'>type</emphasis> field selects one of several token types
that are described below.  The <emphasis remap='I'>start</emphasis> field
points to the first character in the token and the <emphasis remap='I'>size</emphasis> field
gives the total number of characters in the token.  Some token types,
such as <emphasis remap='B'>TCL_TOKEN_WORD</emphasis> and <emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis>, consist of
several component tokens, which immediately follow the parent token;
the <emphasis remap='I'>numComponents</emphasis> field describes how many of these there are.
The <emphasis remap='I'>type</emphasis> field has one of the following values:</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_WORD</emphasis></term>
  <listitem>
<para>This token ordinarily describes one word of a command
but it may also describe a quoted or braced string in an expression.
The token describes a component of the script that is
the result of concatenating together a sequence of subcomponents,
each described by a separate subtoken.
The token starts with the first non-blank
character of the component (which may be a double-quote or open brace)
and includes all characters in the component up to but not including the
space, semicolon, close bracket, close quote, or close brace that
terminates the component.  The <emphasis remap='I'>numComponents</emphasis> field counts the total
number of sub-tokens that make up the word, including sub-tokens
of <emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis> and <emphasis remap='B'>TCL_TOKEN_BS</emphasis> tokens.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_SIMPLE_WORD</emphasis></term>
  <listitem>
<para>This token has the same meaning as <emphasis remap='B'>TCL_TOKEN_WORD</emphasis>, except that
the word is guaranteed to consist of a single <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis>
sub-token.  The <emphasis remap='I'>numComponents</emphasis> field is always 1.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_EXPAND_WORD</emphasis></term>
  <listitem>
<!-- .VS 8.5 -->
<para>This token has the same meaning as <emphasis remap='B'>TCL_TOKEN_WORD</emphasis>, except that
the command parser notes this word began with the expansion
prefix <emphasis remap='B'>{*}</emphasis>, indicating that after substitution,
the list value of this word should be expanded to form multiple
arguments in command evaluation.  This
token type can only be created by Tcl_ParseCommand.</para>
<!-- .VE 8.5 -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_TEXT</emphasis></term>
  <listitem>
<para>The token describes a range of literal text that is part of a word.
The <emphasis remap='I'>numComponents</emphasis> field is always 0.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_BS</emphasis></term>
  <listitem>
<para>The token describes a backslash sequence such as <emphasis remap='B'>\n</emphasis> or <emphasis remap='B'>\0xa3</emphasis>.
The <emphasis remap='I'>numComponents</emphasis> field is always 0.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_COMMAND</emphasis></term>
  <listitem>
<para>The token describes a command whose result must be substituted into
the word.  The token includes the square brackets that surround the
command.  The <emphasis remap='I'>numComponents</emphasis> field is always 0 (the nested command
is not parsed; call <function>Tcl_ParseCommand</function> recursively if you want to
see its tokens).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis></term>
  <listitem>
<para>The token describes a variable substitution, including the
<emphasis remap='B'>$</emphasis>, variable name, and array index (if there is one) up through the
close parenthesis that terminates the index.  This token is followed
by one or more additional tokens that describe the variable name and
array index.  If <emphasis remap='I'>numComponents</emphasis>  is 1 then the variable is a
scalar and the next token is a <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis> token that gives the
variable name.  If <emphasis remap='I'>numComponents</emphasis> is greater than 1 then the
variable is an array: the first sub-token is a <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis>
token giving the array name and the remaining sub-tokens are
<emphasis remap='B'>TCL_TOKEN_TEXT</emphasis>, <emphasis remap='B'>TCL_TOKEN_BS</emphasis>, <emphasis remap='B'>TCL_TOKEN_COMMAND</emphasis>, and
<emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis> tokens that must be concatenated to produce the
array index. The <emphasis remap='I'>numComponents</emphasis> field includes nested sub-tokens
that are part of <emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis> tokens in the array index.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis></term>
  <listitem>
<para>The token describes one subexpression of an expression
(or an entire expression).
A subexpression may consist of a value
such as an integer literal, variable substitution,
or parenthesized subexpression;
it may also consist of an operator and its operands.
The token starts with the first non-blank character of the subexpression
up to but not including the space, brace, close-paren, or bracket
that terminates the subexpression.
This token is followed by one or more additional tokens
that describe the subexpression.
If the first sub-token after the <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> token
is a <emphasis remap='B'>TCL_TOKEN_OPERATOR</emphasis> token,
the subexpression consists of an operator and its token operands.
If the operator has no operands, the subexpression consists of
just the <emphasis remap='B'>TCL_TOKEN_OPERATOR</emphasis> token.
Each operand is described by a <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> token.
Otherwise, the subexpression is a value described by
one of the token types <emphasis remap='B'>TCL_TOKEN_WORD</emphasis>, <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis>,
<emphasis remap='B'>TCL_TOKEN_BS</emphasis>, <emphasis remap='B'>TCL_TOKEN_COMMAND</emphasis>, 
<emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis>, and <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis>.
The <emphasis remap='I'>numComponents</emphasis> field
counts the total number of sub-tokens that make up the subexpression;
this includes the sub-tokens for any nested <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> tokens.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>TCL_TOKEN_OPERATOR</emphasis></term>
  <listitem>
<para>The token describes one operator of an expression
such as <emphasis remap='B'>&amp;&amp;</emphasis> or <emphasis remap='B'>hypot</emphasis>.
A <emphasis remap='B'>TCL_TOKEN_OPERATOR</emphasis> token is always preceded by a
<emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> token
that describes the operator and its operands;
the <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> token's <emphasis remap='I'>numComponents</emphasis> field
can be used to determine the number of operands.
A binary operator such as <emphasis remap='B'>*</emphasis>
is followed by two <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> tokens
that describe its operands.
A unary operator like <emphasis remap='B'>-</emphasis>
is followed by a single <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> token
for its operand.
If the operator is a math function such as <emphasis remap='B'>log10</emphasis>,
the <emphasis remap='B'>TCL_TOKEN_OPERATOR</emphasis> token will give its name and
the following <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> tokens will describe
its operands;
if there are no operands (as with <emphasis remap='B'>rand</emphasis>),
no <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> tokens follow.
There is one trinary operator, <emphasis remap='B'>?</emphasis>,
that appears in if-then-else subexpressions
such as <emphasis remap='I'>x</emphasis><emphasis remap='B'>?</emphasis><emphasis remap='I'>y</emphasis><emphasis remap='B'>:</emphasis><emphasis remap='I'>z</emphasis>;
in this case, the <emphasis remap='B'>?</emphasis> <emphasis remap='B'>TCL_TOKEN_OPERATOR</emphasis> token
is followed by three <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis> tokens for the operands
<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>, and <emphasis remap='I'>z</emphasis>.
The <emphasis remap='I'>numComponents</emphasis> field for a <emphasis remap='B'>TCL_TOKEN_OPERATOR</emphasis> token
is always 0.</para>
  </listitem>
  </varlistentry>
</variablelist>

<para>After <function>Tcl_ParseCommand</function> returns, the first token pointed to by
the <emphasis remap='I'>tokenPtr</emphasis> field of the
Tcl_Parse structure always has type <emphasis remap='B'>TCL_TOKEN_WORD</emphasis> or
<!-- .VS 8.5 -->
<emphasis remap='B'>TCL_TOKEN_SIMPLE_WORD</emphasis> or <emphasis remap='B'>TCL_TOKEN_EXPAND_WORD</emphasis>.  
It is followed by the sub-tokens
that must be concatenated to produce the value of that word.
The next token is the <emphasis remap='B'>TCL_TOKEN_WORD</emphasis> or <emphasis remap='B'>TCL_TOKEN_SIMPLE_WORD</emphasis>
of <emphasis remap='B'>TCL_TOKEN_EXPAND_WORD</emphasis> token for the second word,
followed by sub-tokens for that
word, and so on until all <emphasis remap='I'>numWords</emphasis> have been accounted
for.</para>
<!-- .VE 8.5 -->

<para>After <function>Tcl_ParseExpr</function> returns, the first token pointed to by
the <emphasis remap='I'>tokenPtr</emphasis> field of the
Tcl_Parse structure always has type <emphasis remap='B'>TCL_TOKEN_SUB_EXPR</emphasis>.
It is followed by the sub-tokens that must be evaluated
to produce the value of the expression.
Only the token information in the Tcl_Parse structure
is modified: the <emphasis remap='I'>commentStart</emphasis>, <emphasis remap='I'>commentSize</emphasis>,
<emphasis remap='I'>commandStart</emphasis>, and <emphasis remap='I'>commandSize</emphasis> fields are not modified
by <function>Tcl_ParseExpr</function>.</para>

<para>After <function>Tcl_ParseBraces</function> returns,
the array of tokens pointed to by the <emphasis remap='I'>tokenPtr</emphasis> field of the
Tcl_Parse structure will contain a single <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis> token
if the braced string does not contain any backslash-newlines.
If the string does contain backslash-newlines,
the array of tokens will contain one or more
<emphasis remap='B'>TCL_TOKEN_TEXT</emphasis> or <emphasis remap='B'>TCL_TOKEN_BS</emphasis> sub-tokens
that must be concatenated to produce the value of the string.
If the braced string was just <emphasis remap='B'>{}</emphasis>
(that is, the string was empty),
the single <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis> token will have a <emphasis remap='I'>size</emphasis> field
containing zero;
this ensures that at least one token appears
to describe the braced string.
Only the token information in the Tcl_Parse structure
is modified: the <emphasis remap='I'>commentStart</emphasis>, <emphasis remap='I'>commentSize</emphasis>,
<emphasis remap='I'>commandStart</emphasis>, and <emphasis remap='I'>commandSize</emphasis> fields are not modified
by <function>Tcl_ParseBraces</function>.</para>

<para>After <function>Tcl_ParseQuotedString</function> returns,
the array of tokens pointed to by the <emphasis remap='I'>tokenPtr</emphasis> field of the
Tcl_Parse structure depends on the contents of the quoted string.
It will consist of one or more <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis>, <emphasis remap='B'>TCL_TOKEN_BS</emphasis>,
<emphasis remap='B'>TCL_TOKEN_COMMAND</emphasis>, and <emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis> sub-tokens.
The array always contains at least one token;
for example, if the argument <emphasis remap='I'>start</emphasis> is empty,
the array returned consists of a single <emphasis remap='B'>TCL_TOKEN_TEXT</emphasis> token
with a zero <emphasis remap='I'>size</emphasis> field.
Only the token information in the Tcl_Parse structure
is modified: the <emphasis remap='I'>commentStart</emphasis>, <emphasis remap='I'>commentSize</emphasis>,
<emphasis remap='I'>commandStart</emphasis>, and <emphasis remap='I'>commandSize</emphasis> fields are not modified.</para>

<para>After <function>Tcl_ParseVarName</function> returns, the first token pointed to by
the <emphasis remap='I'>tokenPtr</emphasis> field of the
Tcl_Parse structure always has type <emphasis remap='B'>TCL_TOKEN_VARIABLE</emphasis>.  It
is followed by the sub-tokens that make up the variable name as
described above.  The total length of the variable name is
contained in the <emphasis remap='I'>size</emphasis> field of the first token.
As in <function>Tcl_ParseExpr</function>,
only the token information in the Tcl_Parse structure
is modified by <function>Tcl_ParseVarName</function>:
the <emphasis remap='I'>commentStart</emphasis>, <emphasis remap='I'>commentSize</emphasis>,
<emphasis remap='I'>commandStart</emphasis>, and <emphasis remap='I'>commandSize</emphasis> fields are not modified.</para>

<para>All of the character pointers in the
Tcl_Parse and Tcl_Token structures refer
to characters in the <emphasis remap='I'>start</emphasis> argument passed to
<function>Tcl_ParseCommand</function>, <function>Tcl_ParseExpr</function>, <function>Tcl_ParseBraces</function>,
<function>Tcl_ParseQuotedString</function>, and <function>Tcl_ParseVarName</function>.</para>

<para>There are additional fields in the Tcl_Parse structure after the
<emphasis remap='I'>numTokens</emphasis> field, but these are for the private use of
<function>Tcl_ParseCommand</function>, <function>Tcl_ParseExpr</function>, <function>Tcl_ParseBraces</function>,
<function>Tcl_ParseQuotedString</function>, and <function>Tcl_ParseVarName</function>; they should not be
referenced by code outside of these procedures.</para>

</refsect1>

<refsect1 xml:id='keywords'><title>KEYWORDS</title>
<para>backslash substitution, braces, command, expression, parse, token, variable substitution</para>
</refsect1>
</refentry>

